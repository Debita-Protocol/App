/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type { FunctionFragment, Result } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../common";

export declare namespace MarketManager {
  export type CoreMarketDataStruct = {
    bondPool: PromiseOrValue<string>;
    longZCB: PromiseOrValue<string>;
    shortZCB: PromiseOrValue<string>;
    description: PromiseOrValue<string>;
    creationTimestamp: PromiseOrValue<BigNumberish>;
    resolutionTimestamp: PromiseOrValue<BigNumberish>;
    assessmentBound: PromiseOrValue<BigNumberish>;
  };

  export type CoreMarketDataStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    bondPool: string;
    longZCB: string;
    shortZCB: string;
    description: string;
    creationTimestamp: BigNumber;
    resolutionTimestamp: BigNumber;
    assessmentBound: BigNumber;
  };

  export type MarketParametersStruct = {
    N: PromiseOrValue<BigNumberish>;
    sigma: PromiseOrValue<BigNumberish>;
    alpha: PromiseOrValue<BigNumberish>;
    omega: PromiseOrValue<BigNumberish>;
    delta: PromiseOrValue<BigNumberish>;
    r: PromiseOrValue<BigNumberish>;
    s: PromiseOrValue<BigNumberish>;
    steak: PromiseOrValue<BigNumberish>;
  };

  export type MarketParametersStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    N: BigNumber;
    sigma: BigNumber;
    alpha: BigNumber;
    omega: BigNumber;
    delta: BigNumber;
    r: BigNumber;
    s: BigNumber;
    steak: BigNumber;
  };

  export type MarketPhaseDataStruct = {
    duringAssessment: PromiseOrValue<boolean>;
    onlyReputable: PromiseOrValue<boolean>;
    resolved: PromiseOrValue<boolean>;
    alive: PromiseOrValue<boolean>;
    atLoss: PromiseOrValue<boolean>;
    base_budget: PromiseOrValue<BigNumberish>;
  };

  export type MarketPhaseDataStructOutput = [
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    BigNumber
  ] & {
    duringAssessment: boolean;
    onlyReputable: boolean;
    resolved: boolean;
    alive: boolean;
    atLoss: boolean;
    base_budget: BigNumber;
  };
}

export interface MarketManagerInterface extends utils.Interface {
  functions: {
    "_getValidators(uint256)": FunctionFragment;
    "approvalCondition(uint256)": FunctionFragment;
    "assessment_probs(uint256,address)": FunctionFragment;
    "buyBond(uint256,int256,uint256,bytes)": FunctionFragment;
    "buyBondLevered(uint256,uint256,uint256,uint256)": FunctionFragment;
    "calcImpliedProbability(uint256,uint256,uint256)": FunctionFragment;
    "claimFunnel(uint256,uint16,uint256)": FunctionFragment;
    "coverBondShort(uint256,uint256,uint256,bytes)": FunctionFragment;
    "deactivateMarket(uint256,bool,bool)": FunctionFragment;
    "denyMarket(uint256)": FunctionFragment;
    "duringMarketAssessment(uint256)": FunctionFragment;
    "fulfillRandomWords(uint256,uint256[])": FunctionFragment;
    "getCurrentMarketPhase(uint256)": FunctionFragment;
    "getFinalStake(uint256)": FunctionFragment;
    "getHedgePrice(uint256)": FunctionFragment;
    "getHedgeQuantity(address,uint256)": FunctionFragment;
    "getInitialStake(uint256)": FunctionFragment;
    "getLeveragePosition(uint256,address)": FunctionFragment;
    "getMarket(uint256)": FunctionFragment;
    "getMaxLeverage(address)": FunctionFragment;
    "getNumApproved(uint256)": FunctionFragment;
    "getNumResolved(uint256)": FunctionFragment;
    "getParameters(uint256)": FunctionFragment;
    "getPhaseData(uint256)": FunctionFragment;
    "getPool(uint256)": FunctionFragment;
    "getShortZCB(uint256)": FunctionFragment;
    "getTotalStaked(uint256)": FunctionFragment;
    "getTraderBudget(uint256,address)": FunctionFragment;
    "getValidatorRequiredCollateral(uint256)": FunctionFragment;
    "getZCB(uint256)": FunctionFragment;
    "get_redemption_price(uint256)": FunctionFragment;
    "godfxn1(uint256,uint256,uint256)": FunctionFragment;
    "isMarketApproved(uint256)": FunctionFragment;
    "isReputable(address,uint256)": FunctionFragment;
    "isValidator(uint256,address)": FunctionFragment;
    "isVerified(address)": FunctionFragment;
    "leveragePosition(uint256,address)": FunctionFragment;
    "loggedCollaterals(uint256)": FunctionFragment;
    "longTrades(uint256,address)": FunctionFragment;
    "makeEmptyMarketData()": FunctionFragment;
    "marketActive(uint256)": FunctionFragment;
    "marketCondition(uint256)": FunctionFragment;
    "marketCount()": FunctionFragment;
    "markets(uint256)": FunctionFragment;
    "newMarket(uint256,uint256,address,address,address,string,uint256)": FunctionFragment;
    "numValidatorLeftToApproval(uint256)": FunctionFragment;
    "onlyReputable(uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "parameters(uint256)": FunctionFragment;
    "queuedRepThreshold()": FunctionFragment;
    "queuedRepUpdates(address)": FunctionFragment;
    "redeem(uint256)": FunctionFragment;
    "redeemDeniedLeveredBond(uint256)": FunctionFragment;
    "redeemDeniedMarket(uint256,bool)": FunctionFragment;
    "redeemLeveredBond(uint256)": FunctionFragment;
    "redeemShortZCB(uint256)": FunctionFragment;
    "resolveCondition(uint256)": FunctionFragment;
    "restriction_data(uint256)": FunctionFragment;
    "riskTransferPenalty()": FunctionFragment;
    "sellBond(uint256,uint256,uint256,bytes)": FunctionFragment;
    "setMarketPhase(uint256,bool,bool,uint256)": FunctionFragment;
    "setParameters((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256),uint256,uint256)": FunctionFragment;
    "setReputationPhase(uint256,bool)": FunctionFragment;
    "setUpperBound(uint256,uint256)": FunctionFragment;
    "shortBond(uint256,uint256,uint256,bytes)": FunctionFragment;
    "shortTrades(uint256,address)": FunctionFragment;
    "tradeCallBack(uint256,bytes)": FunctionFragment;
    "unlockValidatorStake(uint256)": FunctionFragment;
    "updateRedemptionPrice(uint256,bool,uint256,uint256,bool)": FunctionFragment;
    "updateValidatorStake(uint256,uint256,uint256)": FunctionFragment;
    "validatorApprove(uint256)": FunctionFragment;
    "validatorResolve(uint256)": FunctionFragment;
    "viewValidators(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "_getValidators"
      | "approvalCondition"
      | "assessment_probs"
      | "buyBond"
      | "buyBondLevered"
      | "calcImpliedProbability"
      | "claimFunnel"
      | "coverBondShort"
      | "deactivateMarket"
      | "denyMarket"
      | "duringMarketAssessment"
      | "fulfillRandomWords"
      | "getCurrentMarketPhase"
      | "getFinalStake"
      | "getHedgePrice"
      | "getHedgeQuantity"
      | "getInitialStake"
      | "getLeveragePosition"
      | "getMarket"
      | "getMaxLeverage"
      | "getNumApproved"
      | "getNumResolved"
      | "getParameters"
      | "getPhaseData"
      | "getPool"
      | "getShortZCB"
      | "getTotalStaked"
      | "getTraderBudget"
      | "getValidatorRequiredCollateral"
      | "getZCB"
      | "get_redemption_price"
      | "godfxn1"
      | "isMarketApproved"
      | "isReputable"
      | "isValidator"
      | "isVerified"
      | "leveragePosition"
      | "loggedCollaterals"
      | "longTrades"
      | "makeEmptyMarketData"
      | "marketActive"
      | "marketCondition"
      | "marketCount"
      | "markets"
      | "newMarket"
      | "numValidatorLeftToApproval"
      | "onlyReputable"
      | "owner"
      | "parameters"
      | "queuedRepThreshold"
      | "queuedRepUpdates"
      | "redeem"
      | "redeemDeniedLeveredBond"
      | "redeemDeniedMarket"
      | "redeemLeveredBond"
      | "redeemShortZCB"
      | "resolveCondition"
      | "restriction_data"
      | "riskTransferPenalty"
      | "sellBond"
      | "setMarketPhase"
      | "setParameters"
      | "setReputationPhase"
      | "setUpperBound"
      | "shortBond"
      | "shortTrades"
      | "tradeCallBack"
      | "unlockValidatorStake"
      | "updateRedemptionPrice"
      | "updateValidatorStake"
      | "validatorApprove"
      | "validatorResolve"
      | "viewValidators"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "_getValidators",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "approvalCondition",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "assessment_probs",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "buyBond",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "buyBondLevered",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "calcImpliedProbability",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "claimFunnel",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "coverBondShort",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deactivateMarket",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "denyMarket",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "duringMarketAssessment",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillRandomWords",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentMarketPhase",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getFinalStake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getHedgePrice",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getHedgeQuantity",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getInitialStake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getLeveragePosition",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarket",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxLeverage",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNumApproved",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNumResolved",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getParameters",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPhaseData",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPool",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getShortZCB",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalStaked",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTraderBudget",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getValidatorRequiredCollateral",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getZCB",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "get_redemption_price",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "godfxn1",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isMarketApproved",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isReputable",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "isValidator",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "isVerified",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "leveragePosition",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "loggedCollaterals",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "longTrades",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "makeEmptyMarketData",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "marketActive",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketCondition",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "markets",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "newMarket",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "numValidatorLeftToApproval",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "onlyReputable",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "parameters",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "queuedRepThreshold",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "queuedRepUpdates",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "redeem",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemDeniedLeveredBond",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemDeniedMarket",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemLeveredBond",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "redeemShortZCB",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "resolveCondition",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "restriction_data",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "riskTransferPenalty",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "sellBond",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setMarketPhase",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setParameters",
    values: [
      MarketManager.MarketParametersStruct,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setReputationPhase",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setUpperBound",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "shortBond",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "shortTrades",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "tradeCallBack",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockValidatorStake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateRedemptionPrice",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateValidatorStake",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "validatorApprove",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "validatorResolve",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "viewValidators",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(
    functionFragment: "_getValidators",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approvalCondition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "assessment_probs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "buyBond", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "buyBondLevered",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calcImpliedProbability",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimFunnel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "coverBondShort",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deactivateMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "denyMarket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "duringMarketAssessment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillRandomWords",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentMarketPhase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFinalStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHedgePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getHedgeQuantity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getInitialStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLeveragePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getMarket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMaxLeverage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNumApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNumResolved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPhaseData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getPool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getShortZCB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalStaked",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTraderBudget",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getValidatorRequiredCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getZCB", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "get_redemption_price",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "godfxn1", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isMarketApproved",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isReputable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isValidator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isVerified", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "leveragePosition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "loggedCollaterals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "longTrades", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "makeEmptyMarketData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketCondition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "marketCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "markets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "newMarket", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "numValidatorLeftToApproval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onlyReputable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "parameters", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "queuedRepThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "queuedRepUpdates",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "redeem", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "redeemDeniedLeveredBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemDeniedMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemLeveredBond",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "redeemShortZCB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "resolveCondition",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "restriction_data",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "riskTransferPenalty",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sellBond", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setMarketPhase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReputationPhase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setUpperBound",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "shortBond", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "shortTrades",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tradeCallBack",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unlockValidatorStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateRedemptionPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateValidatorStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validatorApprove",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validatorResolve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "viewValidators",
    data: BytesLike
  ): Result;

  events: {};
}

export interface MarketManager extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MarketManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    _getValidators(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approvalCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    assessment_probs(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    buyBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    buyBondLevered(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _leverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    calcImpliedProbability(
      bondAmount: PromiseOrValue<BigNumberish>,
      collateral_amount: PromiseOrValue<BigNumberish>,
      budget: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    claimFunnel(
      marketId: PromiseOrValue<BigNumberish>,
      point: PromiseOrValue<BigNumberish>,
      funnel: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    coverBondShort(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deactivateMarket(
      marketId: PromiseOrValue<BigNumberish>,
      atLoss: PromiseOrValue<boolean>,
      resolve: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    denyMarket(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    duringMarketAssessment(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    fulfillRandomWords(
      requestId: PromiseOrValue<BigNumberish>,
      randomWords: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getCurrentMarketPhase(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getFinalStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getHedgePrice(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getHedgeQuantity(
      trader: PromiseOrValue<string>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getInitialStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getLeveragePosition(
      marketId: PromiseOrValue<BigNumberish>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getMarket(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketManager.CoreMarketDataStructOutput]>;

    getMaxLeverage(
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getNumApproved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getNumResolved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getParameters(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketManager.MarketParametersStructOutput]>;

    getPhaseData(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[MarketManager.MarketPhaseDataStructOutput]>;

    getPool(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getShortZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getTotalStaked(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getTraderBudget(
      marketId: PromiseOrValue<BigNumberish>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getValidatorRequiredCollateral(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    get_redemption_price(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    godfxn1(
      marketId: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      N: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isMarketApproved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isReputable(
      trader: PromiseOrValue<string>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isValidator(
      marketId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    isVerified(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    leveragePosition(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { debt: BigNumber; amount: BigNumber }>;

    loggedCollaterals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    longTrades(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    makeEmptyMarketData(
      overrides?: CallOverrides
    ): Promise<[MarketManager.CoreMarketDataStructOutput]>;

    marketActive(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    marketCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    marketCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    markets(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, string, string, BigNumber, BigNumber, BigNumber] & {
        bondPool: string;
        longZCB: string;
        shortZCB: string;
        description: string;
        creationTimestamp: BigNumber;
        resolutionTimestamp: BigNumber;
        assessmentBound: BigNumber;
      }
    >;

    newMarket(
      marketId: PromiseOrValue<BigNumberish>,
      principal: PromiseOrValue<BigNumberish>,
      bondPool: PromiseOrValue<string>,
      _longZCB: PromiseOrValue<string>,
      _shortZCB: PromiseOrValue<string>,
      _description: PromiseOrValue<string>,
      _duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    numValidatorLeftToApproval(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    onlyReputable(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    parameters(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        N: BigNumber;
        sigma: BigNumber;
        alpha: BigNumber;
        omega: BigNumber;
        delta: BigNumber;
        r: BigNumber;
        s: BigNumber;
        steak: BigNumber;
      }
    >;

    queuedRepThreshold(overrides?: CallOverrides): Promise<[number]>;

    queuedRepUpdates(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[number]>;

    redeem(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    redeemDeniedLeveredBond(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    redeemDeniedMarket(
      marketId: PromiseOrValue<BigNumberish>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    redeemLeveredBond(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    redeemShortZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    resolveCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    restriction_data(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean, boolean, boolean, boolean, BigNumber] & {
        duringAssessment: boolean;
        onlyReputable: boolean;
        resolved: boolean;
        alive: boolean;
        atLoss: boolean;
        base_budget: BigNumber;
      }
    >;

    riskTransferPenalty(overrides?: CallOverrides): Promise<[BigNumber]>;

    sellBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setMarketPhase(
      marketId: PromiseOrValue<BigNumberish>,
      duringAssessment: PromiseOrValue<boolean>,
      _onlyReputable: PromiseOrValue<boolean>,
      base_budget: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setParameters(
      param: MarketManager.MarketParametersStruct,
      utilizationRate: PromiseOrValue<BigNumberish>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setReputationPhase(
      marketId: PromiseOrValue<BigNumberish>,
      _onlyReputable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setUpperBound(
      marketId: PromiseOrValue<BigNumberish>,
      new_upper_bound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    shortBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    shortTrades(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    tradeCallBack(
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unlockValidatorStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateRedemptionPrice(
      marketId: PromiseOrValue<BigNumberish>,
      atLoss: PromiseOrValue<boolean>,
      extra_gain: PromiseOrValue<BigNumberish>,
      loss: PromiseOrValue<BigNumberish>,
      premature: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateValidatorStake(
      marketId: PromiseOrValue<BigNumberish>,
      principal: PromiseOrValue<BigNumberish>,
      principal_loss: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    validatorApprove(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    validatorResolve(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    viewValidators(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;
  };

  _getValidators(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approvalCondition(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  assessment_probs(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  buyBond(
    _marketId: PromiseOrValue<BigNumberish>,
    _amountIn: PromiseOrValue<BigNumberish>,
    _priceLimit: PromiseOrValue<BigNumberish>,
    _tradeRequestData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  buyBondLevered(
    _marketId: PromiseOrValue<BigNumberish>,
    _amountIn: PromiseOrValue<BigNumberish>,
    _priceLimit: PromiseOrValue<BigNumberish>,
    _leverage: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  calcImpliedProbability(
    bondAmount: PromiseOrValue<BigNumberish>,
    collateral_amount: PromiseOrValue<BigNumberish>,
    budget: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimFunnel(
    marketId: PromiseOrValue<BigNumberish>,
    point: PromiseOrValue<BigNumberish>,
    funnel: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  coverBondShort(
    _marketId: PromiseOrValue<BigNumberish>,
    _amountIn: PromiseOrValue<BigNumberish>,
    _priceLimit: PromiseOrValue<BigNumberish>,
    _tradeRequestData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deactivateMarket(
    marketId: PromiseOrValue<BigNumberish>,
    atLoss: PromiseOrValue<boolean>,
    resolve: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  denyMarket(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  duringMarketAssessment(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  fulfillRandomWords(
    requestId: PromiseOrValue<BigNumberish>,
    randomWords: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getCurrentMarketPhase(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getFinalStake(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getHedgePrice(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getHedgeQuantity(
    trader: PromiseOrValue<string>,
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getInitialStake(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getLeveragePosition(
    marketId: PromiseOrValue<BigNumberish>,
    manager: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber]>;

  getMarket(
    _id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketManager.CoreMarketDataStructOutput>;

  getMaxLeverage(
    manager: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getNumApproved(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getNumResolved(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getParameters(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketManager.MarketParametersStructOutput>;

  getPhaseData(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<MarketManager.MarketPhaseDataStructOutput>;

  getPool(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getShortZCB(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  getTotalStaked(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTraderBudget(
    marketId: PromiseOrValue<BigNumberish>,
    trader: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getValidatorRequiredCollateral(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getZCB(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>;

  get_redemption_price(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  godfxn1(
    marketId: PromiseOrValue<BigNumberish>,
    r: PromiseOrValue<BigNumberish>,
    N: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isMarketApproved(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isReputable(
    trader: PromiseOrValue<string>,
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isValidator(
    marketId: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  isVerified(
    trader: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  leveragePosition(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<[BigNumber, BigNumber] & { debt: BigNumber; amount: BigNumber }>;

  loggedCollaterals(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  longTrades(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  makeEmptyMarketData(
    overrides?: CallOverrides
  ): Promise<MarketManager.CoreMarketDataStructOutput>;

  marketActive(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  marketCondition(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  marketCount(overrides?: CallOverrides): Promise<BigNumber>;

  markets(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [string, string, string, string, BigNumber, BigNumber, BigNumber] & {
      bondPool: string;
      longZCB: string;
      shortZCB: string;
      description: string;
      creationTimestamp: BigNumber;
      resolutionTimestamp: BigNumber;
      assessmentBound: BigNumber;
    }
  >;

  newMarket(
    marketId: PromiseOrValue<BigNumberish>,
    principal: PromiseOrValue<BigNumberish>,
    bondPool: PromiseOrValue<string>,
    _longZCB: PromiseOrValue<string>,
    _shortZCB: PromiseOrValue<string>,
    _description: PromiseOrValue<string>,
    _duration: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  numValidatorLeftToApproval(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  onlyReputable(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  parameters(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber
    ] & {
      N: BigNumber;
      sigma: BigNumber;
      alpha: BigNumber;
      omega: BigNumber;
      delta: BigNumber;
      r: BigNumber;
      s: BigNumber;
      steak: BigNumber;
    }
  >;

  queuedRepThreshold(overrides?: CallOverrides): Promise<number>;

  queuedRepUpdates(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<number>;

  redeem(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  redeemDeniedLeveredBond(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  redeemDeniedMarket(
    marketId: PromiseOrValue<BigNumberish>,
    isLong: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  redeemLeveredBond(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  redeemShortZCB(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  resolveCondition(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  restriction_data(
    arg0: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<
    [boolean, boolean, boolean, boolean, boolean, BigNumber] & {
      duringAssessment: boolean;
      onlyReputable: boolean;
      resolved: boolean;
      alive: boolean;
      atLoss: boolean;
      base_budget: BigNumber;
    }
  >;

  riskTransferPenalty(overrides?: CallOverrides): Promise<BigNumber>;

  sellBond(
    _marketId: PromiseOrValue<BigNumberish>,
    _amountIn: PromiseOrValue<BigNumberish>,
    _priceLimit: PromiseOrValue<BigNumberish>,
    _tradeRequestData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setMarketPhase(
    marketId: PromiseOrValue<BigNumberish>,
    duringAssessment: PromiseOrValue<boolean>,
    _onlyReputable: PromiseOrValue<boolean>,
    base_budget: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setParameters(
    param: MarketManager.MarketParametersStruct,
    utilizationRate: PromiseOrValue<BigNumberish>,
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setReputationPhase(
    marketId: PromiseOrValue<BigNumberish>,
    _onlyReputable: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setUpperBound(
    marketId: PromiseOrValue<BigNumberish>,
    new_upper_bound: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  shortBond(
    _marketId: PromiseOrValue<BigNumberish>,
    _amountIn: PromiseOrValue<BigNumberish>,
    _priceLimit: PromiseOrValue<BigNumberish>,
    _tradeRequestData: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  shortTrades(
    arg0: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  tradeCallBack(
    amount: PromiseOrValue<BigNumberish>,
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unlockValidatorStake(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateRedemptionPrice(
    marketId: PromiseOrValue<BigNumberish>,
    atLoss: PromiseOrValue<boolean>,
    extra_gain: PromiseOrValue<BigNumberish>,
    loss: PromiseOrValue<BigNumberish>,
    premature: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateValidatorStake(
    marketId: PromiseOrValue<BigNumberish>,
    principal: PromiseOrValue<BigNumberish>,
    principal_loss: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  validatorApprove(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  validatorResolve(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  viewValidators(
    marketId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  callStatic: {
    _getValidators(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    approvalCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    assessment_probs(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    buyBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amountIn: BigNumber; amountOut: BigNumber }
    >;

    buyBondLevered(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _leverage: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amountIn: BigNumber; amountOut: BigNumber }
    >;

    calcImpliedProbability(
      bondAmount: PromiseOrValue<BigNumberish>,
      collateral_amount: PromiseOrValue<BigNumberish>,
      budget: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimFunnel(
      marketId: PromiseOrValue<BigNumberish>,
      point: PromiseOrValue<BigNumberish>,
      funnel: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    coverBondShort(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amountIn: BigNumber; amountOut: BigNumber }
    >;

    deactivateMarket(
      marketId: PromiseOrValue<BigNumberish>,
      atLoss: PromiseOrValue<boolean>,
      resolve: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    denyMarket(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    duringMarketAssessment(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    fulfillRandomWords(
      requestId: PromiseOrValue<BigNumberish>,
      randomWords: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    getCurrentMarketPhase(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFinalStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHedgePrice(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHedgeQuantity(
      trader: PromiseOrValue<string>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInitialStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLeveragePosition(
      marketId: PromiseOrValue<BigNumberish>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    getMarket(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketManager.CoreMarketDataStructOutput>;

    getMaxLeverage(
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNumApproved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNumResolved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getParameters(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketManager.MarketParametersStructOutput>;

    getPhaseData(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<MarketManager.MarketPhaseDataStructOutput>;

    getPool(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getShortZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getTotalStaked(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTraderBudget(
      marketId: PromiseOrValue<BigNumberish>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getValidatorRequiredCollateral(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    get_redemption_price(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    godfxn1(
      marketId: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      N: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    isMarketApproved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isReputable(
      trader: PromiseOrValue<string>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isValidator(
      marketId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    isVerified(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    leveragePosition(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber] & { debt: BigNumber; amount: BigNumber }>;

    loggedCollaterals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    longTrades(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    makeEmptyMarketData(
      overrides?: CallOverrides
    ): Promise<MarketManager.CoreMarketDataStructOutput>;

    marketActive(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    marketCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    marketCount(overrides?: CallOverrides): Promise<BigNumber>;

    markets(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [string, string, string, string, BigNumber, BigNumber, BigNumber] & {
        bondPool: string;
        longZCB: string;
        shortZCB: string;
        description: string;
        creationTimestamp: BigNumber;
        resolutionTimestamp: BigNumber;
        assessmentBound: BigNumber;
      }
    >;

    newMarket(
      marketId: PromiseOrValue<BigNumberish>,
      principal: PromiseOrValue<BigNumberish>,
      bondPool: PromiseOrValue<string>,
      _longZCB: PromiseOrValue<string>,
      _shortZCB: PromiseOrValue<string>,
      _description: PromiseOrValue<string>,
      _duration: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    numValidatorLeftToApproval(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    onlyReputable(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    parameters(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
      ] & {
        N: BigNumber;
        sigma: BigNumber;
        alpha: BigNumber;
        omega: BigNumber;
        delta: BigNumber;
        r: BigNumber;
        s: BigNumber;
        steak: BigNumber;
      }
    >;

    queuedRepThreshold(overrides?: CallOverrides): Promise<number>;

    queuedRepUpdates(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<number>;

    redeem(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redeemDeniedLeveredBond(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redeemDeniedMarket(
      marketId: PromiseOrValue<BigNumberish>,
      isLong: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    redeemLeveredBond(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    redeemShortZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    resolveCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    restriction_data(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [boolean, boolean, boolean, boolean, boolean, BigNumber] & {
        duringAssessment: boolean;
        onlyReputable: boolean;
        resolved: boolean;
        alive: boolean;
        atLoss: boolean;
        base_budget: BigNumber;
      }
    >;

    riskTransferPenalty(overrides?: CallOverrides): Promise<BigNumber>;

    sellBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amountIn: BigNumber; amountOut: BigNumber }
    >;

    setMarketPhase(
      marketId: PromiseOrValue<BigNumberish>,
      duringAssessment: PromiseOrValue<boolean>,
      _onlyReputable: PromiseOrValue<boolean>,
      base_budget: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setParameters(
      param: MarketManager.MarketParametersStruct,
      utilizationRate: PromiseOrValue<BigNumberish>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setReputationPhase(
      marketId: PromiseOrValue<BigNumberish>,
      _onlyReputable: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setUpperBound(
      marketId: PromiseOrValue<BigNumberish>,
      new_upper_bound: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    shortBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amountIn: BigNumber; amountOut: BigNumber }
    >;

    shortTrades(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tradeCallBack(
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    unlockValidatorStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateRedemptionPrice(
      marketId: PromiseOrValue<BigNumberish>,
      atLoss: PromiseOrValue<boolean>,
      extra_gain: PromiseOrValue<BigNumberish>,
      loss: PromiseOrValue<BigNumberish>,
      premature: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateValidatorStake(
      marketId: PromiseOrValue<BigNumberish>,
      principal: PromiseOrValue<BigNumberish>,
      principal_loss: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    validatorApprove(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    validatorResolve(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    viewValidators(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string[]>;
  };

  filters: {};

  estimateGas: {
    _getValidators(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approvalCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    assessment_probs(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    buyBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    buyBondLevered(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _leverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    calcImpliedProbability(
      bondAmount: PromiseOrValue<BigNumberish>,
      collateral_amount: PromiseOrValue<BigNumberish>,
      budget: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimFunnel(
      marketId: PromiseOrValue<BigNumberish>,
      point: PromiseOrValue<BigNumberish>,
      funnel: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    coverBondShort(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deactivateMarket(
      marketId: PromiseOrValue<BigNumberish>,
      atLoss: PromiseOrValue<boolean>,
      resolve: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    denyMarket(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    duringMarketAssessment(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    fulfillRandomWords(
      requestId: PromiseOrValue<BigNumberish>,
      randomWords: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getCurrentMarketPhase(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getFinalStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHedgePrice(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getHedgeQuantity(
      trader: PromiseOrValue<string>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getInitialStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLeveragePosition(
      marketId: PromiseOrValue<BigNumberish>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMarket(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMaxLeverage(
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNumApproved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNumResolved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getParameters(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPhaseData(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPool(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getShortZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalStaked(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTraderBudget(
      marketId: PromiseOrValue<BigNumberish>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getValidatorRequiredCollateral(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    get_redemption_price(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    godfxn1(
      marketId: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      N: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isMarketApproved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isReputable(
      trader: PromiseOrValue<string>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isValidator(
      marketId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    isVerified(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    leveragePosition(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    loggedCollaterals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    longTrades(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    makeEmptyMarketData(overrides?: CallOverrides): Promise<BigNumber>;

    marketActive(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketCount(overrides?: CallOverrides): Promise<BigNumber>;

    markets(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    newMarket(
      marketId: PromiseOrValue<BigNumberish>,
      principal: PromiseOrValue<BigNumberish>,
      bondPool: PromiseOrValue<string>,
      _longZCB: PromiseOrValue<string>,
      _shortZCB: PromiseOrValue<string>,
      _description: PromiseOrValue<string>,
      _duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    numValidatorLeftToApproval(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    onlyReputable(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    parameters(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    queuedRepThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    queuedRepUpdates(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    redeem(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    redeemDeniedLeveredBond(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    redeemDeniedMarket(
      marketId: PromiseOrValue<BigNumberish>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    redeemLeveredBond(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    redeemShortZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    resolveCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    restriction_data(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    riskTransferPenalty(overrides?: CallOverrides): Promise<BigNumber>;

    sellBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setMarketPhase(
      marketId: PromiseOrValue<BigNumberish>,
      duringAssessment: PromiseOrValue<boolean>,
      _onlyReputable: PromiseOrValue<boolean>,
      base_budget: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setParameters(
      param: MarketManager.MarketParametersStruct,
      utilizationRate: PromiseOrValue<BigNumberish>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setReputationPhase(
      marketId: PromiseOrValue<BigNumberish>,
      _onlyReputable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setUpperBound(
      marketId: PromiseOrValue<BigNumberish>,
      new_upper_bound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    shortBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    shortTrades(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    tradeCallBack(
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unlockValidatorStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateRedemptionPrice(
      marketId: PromiseOrValue<BigNumberish>,
      atLoss: PromiseOrValue<boolean>,
      extra_gain: PromiseOrValue<BigNumberish>,
      loss: PromiseOrValue<BigNumberish>,
      premature: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateValidatorStake(
      marketId: PromiseOrValue<BigNumberish>,
      principal: PromiseOrValue<BigNumberish>,
      principal_loss: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    validatorApprove(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    validatorResolve(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    viewValidators(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    _getValidators(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approvalCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    assessment_probs(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    buyBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    buyBondLevered(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _leverage: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    calcImpliedProbability(
      bondAmount: PromiseOrValue<BigNumberish>,
      collateral_amount: PromiseOrValue<BigNumberish>,
      budget: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimFunnel(
      marketId: PromiseOrValue<BigNumberish>,
      point: PromiseOrValue<BigNumberish>,
      funnel: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    coverBondShort(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deactivateMarket(
      marketId: PromiseOrValue<BigNumberish>,
      atLoss: PromiseOrValue<boolean>,
      resolve: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    denyMarket(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    duringMarketAssessment(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    fulfillRandomWords(
      requestId: PromiseOrValue<BigNumberish>,
      randomWords: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getCurrentMarketPhase(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getFinalStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getHedgePrice(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getHedgeQuantity(
      trader: PromiseOrValue<string>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getInitialStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLeveragePosition(
      marketId: PromiseOrValue<BigNumberish>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMarket(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMaxLeverage(
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNumApproved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNumResolved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getParameters(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPhaseData(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPool(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getShortZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalStaked(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTraderBudget(
      marketId: PromiseOrValue<BigNumberish>,
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getValidatorRequiredCollateral(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    get_redemption_price(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    godfxn1(
      marketId: PromiseOrValue<BigNumberish>,
      r: PromiseOrValue<BigNumberish>,
      N: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isMarketApproved(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isReputable(
      trader: PromiseOrValue<string>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isValidator(
      marketId: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isVerified(
      trader: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    leveragePosition(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    loggedCollaterals(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    longTrades(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    makeEmptyMarketData(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketActive(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    markets(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    newMarket(
      marketId: PromiseOrValue<BigNumberish>,
      principal: PromiseOrValue<BigNumberish>,
      bondPool: PromiseOrValue<string>,
      _longZCB: PromiseOrValue<string>,
      _shortZCB: PromiseOrValue<string>,
      _description: PromiseOrValue<string>,
      _duration: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    numValidatorLeftToApproval(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    onlyReputable(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    parameters(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    queuedRepThreshold(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    queuedRepUpdates(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    redeem(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    redeemDeniedLeveredBond(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    redeemDeniedMarket(
      marketId: PromiseOrValue<BigNumberish>,
      isLong: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    redeemLeveredBond(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    redeemShortZCB(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    resolveCondition(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    restriction_data(
      arg0: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    riskTransferPenalty(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    sellBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setMarketPhase(
      marketId: PromiseOrValue<BigNumberish>,
      duringAssessment: PromiseOrValue<boolean>,
      _onlyReputable: PromiseOrValue<boolean>,
      base_budget: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setParameters(
      param: MarketManager.MarketParametersStruct,
      utilizationRate: PromiseOrValue<BigNumberish>,
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setReputationPhase(
      marketId: PromiseOrValue<BigNumberish>,
      _onlyReputable: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setUpperBound(
      marketId: PromiseOrValue<BigNumberish>,
      new_upper_bound: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    shortBond(
      _marketId: PromiseOrValue<BigNumberish>,
      _amountIn: PromiseOrValue<BigNumberish>,
      _priceLimit: PromiseOrValue<BigNumberish>,
      _tradeRequestData: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    shortTrades(
      arg0: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    tradeCallBack(
      amount: PromiseOrValue<BigNumberish>,
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unlockValidatorStake(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateRedemptionPrice(
      marketId: PromiseOrValue<BigNumberish>,
      atLoss: PromiseOrValue<boolean>,
      extra_gain: PromiseOrValue<BigNumberish>,
      loss: PromiseOrValue<BigNumberish>,
      premature: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateValidatorStake(
      marketId: PromiseOrValue<BigNumberish>,
      principal: PromiseOrValue<BigNumberish>,
      principal_loss: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    validatorApprove(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    validatorResolve(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    viewValidators(
      marketId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
