{
  "language": "Solidity",
  "sources": {
    "contracts/bonds/bondingcurve.sol": {
      "content": "pragma solidity ^0.8.4;\nimport {OwnedERC20} from \"../turbo/OwnedShareToken.sol\";\nimport \"hardhat/console.sol\";\n//import \"../prb/PRBMathUD60x18.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {config} from \"../protocol/helpers.sol\"; \n\n\nabstract contract BondingCurve is OwnedERC20 {\n  // ASSUMES 18 TRAILING DECIMALS IN UINT256\n  using SafeERC20 for ERC20;\n  using FixedPointMathLib for uint256;\n\n  uint256 internal price_upper_bound;\n  uint256 internal price_lower_bound;\n  uint256 internal reserves; //in collateral_dec \n  uint256 internal max_quantity;\n  uint256 internal math_precision; \n  uint256 public collateral_dec;\n  uint256 internal discounted_reserves; \n  ERC20 collateral; // NEED TO CHANGE ONCE VAULT IS DONE\n  uint256 discounted_supply;\n\n  address shortZCB; \n  constructor (\n    string memory name,\n    string memory symbol,\n    address owner, // market manager.\n    address _collateral\n    ) OwnedERC20(name, symbol, owner) {\n    collateral = ERC20(_collateral);\n\n    math_precision = config.WAD;\n    collateral_dec = collateral.decimals();\n\n  }\n\n  /// @notice account for discounted/shorted supply \n  function totalSupplyAdjusted() public view returns(uint256) {\n    return totalSupply() - discounted_supply; \n  }\n\n  /// @notice priceupperbound/lowerbound are not price, but instead percentage of max reserves(principal) like alpha \n  function setUpperBound(uint256 upper_bound) public onlyOwner {\n    price_upper_bound = upper_bound;\n  }\n\n  function setLowerBound(uint256 lower_bound) public onlyOwner {\n    price_lower_bound = lower_bound;\n  }\n\n  function setMaxQuantity(uint256 _max_quantity) public onlyOwner {\n    max_quantity = _max_quantity;\n  }\n\n  function setShortZCB(address shortZCB_ad) public onlyOwner{\n    shortZCB = shortZCB_ad; \n  }\n\n\n\n  /**\n   @notice called by market manager, like trustedMint but returns amount out\n   @param collateral_amount: amount of collateral in. => w/ collateral decimals\n   @param min_amount_out: reverts if actual tokens returned less\n   */\n  function trustedBuy(\n    address trader, \n    uint256 collateral_amount,\n    uint256 min_amount_out\n    ) public returns (uint256 tokensOut) {\n    require(msg.sender == owner || msg.sender == shortZCB); \n    require(collateral.balanceOf(trader)>= collateral_amount,\"not enough balance\"); \n    require(reserves+collateral_amount <=  price_upper_bound, \"exceeds trade boundary\"); \n\n    tokensOut = calculatePurchaseReturn(collateral_amount);\n    require(tokensOut >= min_amount_out, \"Slippage err\"); \n    unchecked{reserves += collateral_amount;}\n\n    collateral.safeTransferFrom(trader, address(this), collateral_amount);\n    _mint(trader, tokensOut);\n\n   }\n\n   /**\n   @param zcb_amount: amount of zcb tokens burned, needs to be in WAD \n   */\n  function trustedSell(\n    address trader, \n    uint256 zcb_amount, \n    uint256 min_collateral_out\n    ) public returns (uint256 collateral_out) {\n    require(msg.sender == owner || msg.sender == shortZCB); \n\n    // in collateral_dec rounded down to nearest int\n    collateral_out = calculateSaleReturn(zcb_amount);\n    require(reserves-collateral_out >= price_lower_bound, \"exceeds trade boundary\"); \n    require(collateral_out>=min_collateral_out, \"Slippage Err\"); \n\n    unchecked{reserves -= collateral_out;}\n\n    _burn(trader, zcb_amount);\n\n    collateral.safeTransfer(trader, collateral_out);\n\n   }\n\n   /// @notice only called for selling discounted supplies or short supplies \n  function trustedDiscountedMint(address receiver, uint256 zcb_amount) external virtual  onlyOwner {\n    discounted_supply += zcb_amount; \n    _mint(receiver, zcb_amount); \n   }\n\n  function trustedDiscountedBurn(address receiver, uint256 zcb_amount) external virtual onlyOwner{\n    discounted_supply -= zcb_amount; \n    _burn(receiver, zcb_amount); \n\n  }\n\n  function trustedApproveCollateralTransfer(address trader, uint256 amount) public onlyOwner {\n    collateral.approve(trader, amount);\n   }\n\n\n  /**\n   @notice calculates tokens returns from input collateral\n   @dev shouldn't be calling this function, should be calculating amount from frontend.\n   @param amount: input collateral (ds)\n   */\n  function calculatePurchaseReturn(uint256 amount) public view  returns (uint256) {\n    return _calculatePurchaseReturn(amount);\n   }\n\n  /**\n   @notice calculates collateral returns from selling tokens\n   @param amount: amount of tokens selling\n   returns in collateral dec \n   */\n  function calculateSaleReturn(uint256 amount) public view  returns (uint256) {\n    return _calculateSaleReturn(amount);\n   }\n\n\n  /// @notice gets required amount of collateral to purchase X amount of tokens\n  /// need to get area under the curve from current supply X_  to X_+X \n  function calcAreaUnderCurve(uint256 amount) public view  returns(uint){\n    return _calcAreaUnderCurve(amount); \n  }\n\n  /**\n   @notice calculates expected price given user buys X tokens\n   @param amount: hypothetical amount of tokens bought\n   */ \n  function calculateExpectedPrice(uint256 amount) public view  returns (uint256 result) {\n    result = _calculateExpectedPrice(amount);\n   }\n\n  function getTotalCollateral() public view returns (uint256 result) {\n    result = collateral.balanceOf(address(this));\n   }\n\n  function getCollateral() public view returns (address) {\n    return address(collateral);\n   } \n\n  function getTotalZCB() public view returns (uint256 result) {\n    result = totalSupply();\n   }\n\n  function getMaxQuantity() public view returns (uint256 result) {\n    result = max_quantity;\n   }\n\n  function getUpperBound() public view returns (uint256 result) {\n    result = price_upper_bound;\n   }\n\n  function getLowerBound() public view returns (uint256 result) {\n    result = price_lower_bound;\n   }\n\n  function getReserves() public view returns(uint256){\n    return reserves; \n   }\n  function getDiscountedReserves() public view returns(uint256){\n    return discounted_reserves; \n  }\n\n  function get_discount_cap() public view returns(uint256){\n    return _get_discount_cap();  \n  }\n\n  function getParams() public view returns(uint,uint){\n    return _getParams(); \n  }\n\n  /**\n   @dev amount is tokens burned.\n   */\n  function calculateDecreasedPrice(uint256 amount) public view  virtual returns (uint256) {\n    return _calculateDecreasedPrice(amount);\n  }\n\n  /**\n   @dev doesn't perform any checks, checks performed by caller\n   */\n  function incrementReserves(uint256 amount) public onlyOwner{\n    reserves += amount;\n   }\n\n  /**\n   @dev doesn't perform any checks, checks performed by caller\n   */\n  function decrementReserves(uint256 amount) public onlyOwner {\n    reserves -= amount;\n   }\n\n  function incrementDiscountedReserves(uint256 amount) public onlyOwner{\n    discounted_reserves += amount; \n  }\n\n\n\n\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override virtual {\n    // on _mint\n    if (from == address(0) && price_upper_bound > 0) {\n      console.log(\"beforeTT: price_upper_bound\", price_upper_bound);\n      // require(_calculateExpectedPrice(amount) <= price_upper_bound, \"above price upper bound\");\n    }\n    // on _burn\n    else if (to == address(0) && price_lower_bound > 0) {\n      // require(_calculateDecreasedPrice(amount) >= price_lower_bound, \"below price lower bound\");\n    }\n  }\n\n\n  /// @notice calculates implied probability of the trader \n  /// @param budget of trader in collateral decimals \n  function calcImpliedProbability(uint256 collateral_amount, uint256 budget) public view returns(uint256 prob){\n\n    uint256 zcb_amount = calculatePurchaseReturn(collateral_amount); \n    uint256 avg_price = calcAveragePrice(zcb_amount); //18 decimals \n    uint256 b = avg_price.mulWadDown(math_precision - avg_price);\n    uint256 ratio = zcb_amount.divWadDown(budget); \n\n    return ratio.mulWadDown(b)+ avg_price;\n  }\n\n  /// @notice caluclates average price for the user to buy amount tokens \n  /// @dev which is average under the curve divided by amount \n  /// amount is the amount of bonds, 18 decimals \n  function calcAveragePrice(uint256 amount) public view returns(uint256){\n\n    uint256 area = calcAreaUnderCurve(amount); //this takes in 18 \n\n    //area is in decimal 6, amount is in 18\n    // uint256 area_in_precision = area*(10**12); \n    uint256 result = area.divWadDown(amount); \n    //returns a 18 decimal avg price \n    return result; \n  }\n\n  function calculateArbitraryPurchaseReturn(uint256 amount, uint256 supply) public view returns(uint256) {\n    return _calculateArbitraryPurchaseReturn(amount, supply); \n  }\n\n  function _get_discount_cap() internal view virtual returns(uint256); \n\n  function _calcAreaUnderCurve(uint256 amount) internal view  virtual returns(uint256 result); \n\n  function _calculatePurchaseReturn(uint256 amount)  internal view virtual returns(uint256 result);\n\n  function _calculateSaleReturn(uint256 amount) internal view  virtual returns (uint256 result);\n\n  function _calculateExpectedPrice(uint256 amount) internal view  virtual returns (uint256 result);\n\n  function _calculateDecreasedPrice(uint256 amount) internal view  virtual returns (uint256 result);\n\n  function _calculateArbitraryPurchaseReturn(uint256 amount, uint256 supply)  internal view  virtual returns(uint256); \n\n  function _getParams() public view virtual returns(uint,uint); \n\n\n\n\n\n\n\n///DEPRECATED\n  /**\n   @notice used for calculating reputation score on resolved market.\n   */\n\n\n  function redeem(\n    address receiver, \n    uint256 zcb_redeem_amount, \n    uint256 collateral_redeem_amount\n    ) external  onlyOwner {\n    _burn(receiver, zcb_redeem_amount);\n    collateral.safeTransfer(receiver, collateral_redeem_amount); \n    reserves -= collateral_redeem_amount;\n   }\n\n  function redeemPostAssessment(\n    address redeemer,\n    uint256 collateral_amount\n    ) external  onlyOwner{\n    uint256 redeem_amount = balanceOf(redeemer);\n    _burn(redeemer, redeem_amount); \n    collateral.safeTransfer(redeemer, collateral_amount); \n    reserves -= collateral_amount;\n   }\n\n  function burnFirstLoss(\n    uint256 burn_collateral_amount\n    ) external onlyOwner{\n    collateral.safeTransfer(owner, burn_collateral_amount); \n    reserves -= burn_collateral_amount;\n   }\n\n  /**\n   @notice buy bond tokens with necessary checks and transfers of collateral.\n   @param amount: amount of collateral/ds paid in exchange for tokens\n   @dev amount has number of collateral decimals\n   */\n  function buy(uint256 amount) public {\n    uint256 tokens = _calculatePurchaseReturn(amount);\n    reserves += amount; // CAN REPLACE WITH collateral.balanceOf(this)\n    _mint(msg.sender, tokens);\n    collateral.safeTransferFrom(msg.sender, address(this), amount);\n  }\n\n  /**\n   @notice sell bond tokens with necessary checks and transfers of collateral\n   @param amount: amount of tokens selling. 60.18.\n   */\n  function sell(uint256 amount) public {\n    uint256 sale = _calculateSaleReturn(amount);\n    _burn(msg.sender, amount);\n    collateral.safeTransfer(msg.sender, sale);\n    reserves -= sale;\n   }\n  /// @notice calculates score necessary to update reputation score\n  function calculateScore(uint256 priceOut, bool atLoss) public view returns(uint){\n    return _calculateScore(priceOut, atLoss);\n  }\n\n  function _calculateScore(uint256 priceOut, bool atLoss) view internal virtual returns(uint256 score);\n\n  }"
    },
    "contracts/turbo/OwnedShareToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../libraries/Ownable.sol\";\n\ncontract OwnedERC20 is ERC20, Ownable {\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address _owner\n    ) ERC20(name_, symbol_) {\n        owner = _owner;\n    }\n\n    function trustedTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        _transfer(_from, _to, _amount);\n    }\n\n    function trustedMint(address _target, uint256 _amount) external virtual onlyOwner {\n        _mint(_target, _amount);\n    }\n\n    function trustedBurn(address _target, uint256 _amount) external virtual onlyOwner {\n        _burn(_target, _amount);\n    }\n\n    function trustedBurnAll(address _target) external onlyOwner returns (uint256) {\n        uint256 _balance = balanceOf(_target);\n        _burn(_target, _balance);\n        return _balance;\n    }\n\n    function onTransferOwnership(address, address) internal override {}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/protocol/helpers.sol": {
      "content": "pragma solidity ^0.8.4;\n\n\nlibrary config{\n\n  uint256 public constant WAD_PRECISION = 18; \n  uint256 public constant WAD = 1e18; \n  uint256 public constant USDC_dec = 1e6; \n  uint256 public constant roundLimit = 1e14; //0.0001 \n\n  //Max amount in one transaction \n  uint256 private constant max_amount = 1e8 * WAD; \n\n  //Min amount in one transaction \n  uint256 private constant min_amount = WAD/1e4; \n\n  function convertToWad(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\n    //number should not be 18 dec, but in collateral_dec\n    new_number = number * (10 ** (WAD_PRECISION - dec));\n    assert(new_number <= max_amount); \n  }\n\n  function wadToDec(uint256 number, uint256 dec) internal pure returns(uint256 new_number){\n    // number should be 18 dec \n    assert(isInWad(number)); \n    new_number = number/(10 ** (WAD_PRECISION - dec)); \n\n  }\n\n  function isInWad(uint256 number) internal pure returns(bool){\n    return (number >= min_amount); \n  }\n\n\n\n\n}"
    },
    "contracts/libraries/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./IOwnable.sol\";\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\nabstract contract Ownable is IOwnable {\n    address internal owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function getOwner() public view override returns (address) {\n        return owner;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public override onlyOwner returns (bool) {\n        require(_newOwner != address(0));\n        onTransferOwnership(owner, _newOwner);\n        owner = _newOwner;\n        return true;\n    }\n\n    // Subclasses of this token may want to send additional logs through the centralized Augur log emitter contract\n    function onTransferOwnership(address, address) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/libraries/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IOwnable {\n    function getOwner() external view returns (address);\n\n    function transferOwnership(address _newOwner) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/protocol/controller.sol": {
      "content": "pragma solidity ^0.8.4;\nimport {MarketManager, WrappedCollateral} from \"./marketmanager.sol\";\nimport {ReputationNFT} from \"./reputationtoken.sol\";\nimport {OwnedERC20} from \"../turbo/OwnedShareToken.sol\";\nimport {LinearBondingCurve} from \"../bonds/LinearBondingCurve.sol\";\nimport {BondingCurve} from \"../bonds/bondingcurve.sol\";\nimport {LinearBondingCurveFactory} from \"../bonds/LinearBondingCurveFactory.sol\"; \nimport {Vault} from \"../vaults/vault.sol\";\nimport {Instrument} from \"../vaults/instrument.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {VaultFactory} from \"./factories.sol\"; \nimport \"hardhat/console.sol\";\nimport \"@interep/contracts/IInterep.sol\";\nimport {config} from \"./helpers.sol\"; \nimport {ShortBondingCurve} from \"../bonds/LinearShortZCB.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\n\ncontract Controller {\n  using SafeMath for uint256;\n  using FixedPointMathLib for uint256;\n\n  struct MarketData {\n      address instrument_address;\n      address recipient;\n  }\n\n  struct ApprovalData{\n    uint256 approved_principal; \n    uint256 approved_yield; \n  }\n  \n  event MarketInitiated(uint256 marketId, address recipient);\n\n  mapping(uint256=>ApprovalData) approvalDatas; \n\n  function getApprovalData(uint256 marketId) public view returns (ApprovalData memory) {\n    approvalDatas[marketId];\n  }\n\n  mapping(address => bool) public  verified;\n  mapping(uint256 => MarketData) public market_data; // id => recipient\n  mapping(address=> uint256) public ad_to_id; //utilizer address to marketId\n  // mapping(address=>uint256[]) public utilizer_marketIds; //utilizer address to multiple marketIds\n  mapping(uint256=> Vault) public vaults; // vault id to Vault contract\n  mapping(uint256=> uint256) public id_parent; //marketId-> vaultId \n  mapping(uint256=> uint256) public vault_debt; //vault debt for each marketId\n  mapping(uint256=>uint256[]) public vault_to_marketIds;\n\n  address creator_address;\n\n  IInterep interep;\n  // TrustedMarketFactoryV3 marketFactory;\n  MarketManager marketManager;\n  ReputationNFT repNFT; \n  LinearBondingCurveFactory linearBCFactory; \n  VaultFactory vaultFactory; \n\n  uint256 constant TWITTER_UNRATED_GROUP_ID = 16106950158033643226105886729341667676405340206102109927577753383156646348711;\n  bytes32 constant private signal = bytes32(\"twitter-unrated\");\n  uint256 constant private insurance_constant = 5e5; //1 is 1e6, also needs to be able to be changed \n  uint256 constant PRICE_PRECISION = 1e18; \n  \n  // Bond Curve Name\n  string constant baseName = \"Bond\";\n  string constant baseSymbol = \"B\";\n  string constant s_baseName = \"sBond\";\n  string constant s_baseSymbol = \"sB\";\n  uint256 nonce = 0;\n\n  /* ========== MODIFIERS ========== */\n  // modifier onlyValidator(uint256 marketId) {\n  //     require(marketManager.isValidator(marketId, msg.sender)|| msg.sender == creator_address);\n  //     _;\n  // }\n\n  modifier onlyOwner() {\n      require(msg.sender == creator_address, \"Only Owner can call this function\");\n      _;\n  }\n  modifier onlyManager() {\n      require(msg.sender == address(marketManager) || msg.sender == creator_address, \"Only Manager can call this function\");\n      _;\n  }\n\n  constructor (\n      address _creator_address,\n      address _interep_address\n  ) {\n      creator_address = _creator_address;\n      interep = IInterep(_interep_address);\n\n      linearBCFactory = new LinearBondingCurveFactory(); \n  }\n\n  /*----Setup Functions----*/\n\n  function setMarketManager(address _marketManager) public onlyOwner {\n      require(_marketManager != address(0));\n      marketManager = MarketManager(_marketManager);\n  }\n\n  function setReputationNFT(address NFT_address) public onlyOwner{\n      repNFT = ReputationNFT(NFT_address); \n  }\n\n  function setVaultFactory(address _vaultFactory) public onlyOwner {\n    vaultFactory = VaultFactory(_vaultFactory); \n  }\n\n  function verifyAddress(\n      uint256 nullifier_hash, \n      uint256 external_nullifier,\n      uint256[8] calldata proof\n  ) external  {\n      require(!verified[msg.sender], \"address already verified\");\n      interep.verifyProof(TWITTER_UNRATED_GROUP_ID, signal, nullifier_hash, external_nullifier, proof);\n      verified[msg.sender] = true;\n  }\n\n  function testVerifyAddress() external {\n    verified[msg.sender] = true;\n  }\n\n\n  function mintRepNFT(\n    address NFT_address,\n    address trader\n    ) external  {\n    ReputationNFT(NFT_address).mint(msg.sender);\n  }\n\n  /// @notice called only when redeeming, transfer funds from vault \n  function redeem_transfer(\n    uint256 amount, \n    address to, \n    uint256 marketId) \n  external onlyManager{\n    console.log('vault debt', vault_debt[marketId], amount); \n    // require(vault_debt[marketId] >= amount, \"No funds left for redemption\"); \n    // unchecked{ vault_debt[marketId] -= amount;} \n\n    vaults[id_parent[marketId]].trusted_transfer(amount,to); \n  }\n\n  /**\n   @notice creates vault\n   @param underlying: underlying asset for vault\n   @param _onlyVerified: only verified users can mint shares\n   @param _r: minimum reputation score to mint shares\n   @param _asset_limit: max number of shares for a single address\n   @param _total_asset_limit: max number of shares for entire vault\n   @param default_params: default params for markets created by vault\n   */\n  function createVault(\n    address underlying,\n    bool _onlyVerified, \n    uint256 _r, \n    uint256 _asset_limit, \n    uint256 _total_asset_limit, \n    MarketManager.MarketParameters memory default_params \n  ) public {\n    (Vault newVault, uint256 vaultId) = vaultFactory.newVault(\n     underlying, \n     address(this),\n     _onlyVerified, \n     _r, \n     _asset_limit,\n     _total_asset_limit,\n     default_params\n    );\n\n    vaults[vaultId] = newVault;\n  }\n\n\n\n  function marketIdToVaultId(uint256 marketId) public view returns(uint256){\n    return id_parent[marketId]; \n  }\n\n  function getMarketIds(uint256 vaultId) public view returns (uint256[] memory) {\n    return vault_to_marketIds[vaultId];\n  }\n\n  /////INITIATORS/////\n\n  /**\n   @param P: principal\n   @param I: expected yield (total interest)\n   @param sigma is the proportion of P that is going to be bought at a discount \n   */\n  function createZCBs(\n    uint256 P,\n    uint256 I, \n    uint256 sigma, \n    uint256 marketId\n    ) internal returns (BondingCurve, ShortBondingCurve) {\n\n    WrappedCollateral wCollateral = new WrappedCollateral(\n      \"name\", \n      \"symbol\", \n      address(this), \n      address(getVault(marketId).UNDERLYING())\n      ); \n\n    BondingCurve _long = linearBCFactory.newLongZCB(\n      string(abi.encodePacked(baseName, \"-\", Strings.toString(nonce))),\n     string(abi.encodePacked(baseSymbol, Strings.toString(nonce))), \n     address(marketManager),\n     address(wCollateral),\n    // getVaultAd( marketId), \n     P,\n     I, \n     sigma);\n\n    ShortBondingCurve _short = linearBCFactory.newShortZCB(\n      string(abi.encodePacked(s_baseName, \"-\", Strings.toString(nonce))), \n      string(abi.encodePacked(s_baseSymbol, Strings.toString(nonce))), \n      address(marketManager),\n      address(wCollateral),  \n\n      // getVaultAd( marketId), \n      address(_long), \n      marketId); \n\n    nonce++;\n\n    return (_long, _short);\n  }\n\n\n\n  /// @notice initiates market, called by frontend loan proposal or instrument form submit button.\n  /// @dev Instrument should already be deployed \n  /// @param recipient: utilizer for the associated instrument\n  /// @param instrumentData: instrument arguments\n  /// @param vaultId: vault identifier\n  function initiateMarket(\n    address recipient,\n    Vault.InstrumentData memory instrumentData, \n    uint256 vaultId\n  ) external  {\n    require(instrumentData.Instrument_address != address(0), \"must not be zero address\");\n    require(instrumentData.principal >= config.WAD, \"Precision err\"); \n    require(address(vaults[vaultId]) != address(0), \"Vault doesn't' exist\");\n    require(recipient != address(0), \"recipient must not be zero address\");\n\n    Vault vault = Vault(vaults[vaultId]); \n\n    uint256 marketId = marketManager.marketCount();\n    \n    id_parent[marketId] = vaultId;\n    vault_to_marketIds[vaultId].push(marketId);\n\n    marketManager.setParameters(\n      vault.get_vault_params(), \n      vault.utilizationRate(), \n      marketId\n    ); \n\n    (BondingCurve _long, ShortBondingCurve _short) = createZCBs(\n      instrumentData.principal,\n      instrumentData.expectedYield, \n      marketManager.getParameters(marketId).sigma, \n      marketId\n    );\n\n    marketManager.newMarket(\n      marketId, \n      instrumentData.principal, \n      instrumentData.expectedYield,      \n      _long,\n      _short,\n      instrumentData.description,\n      block.timestamp\n    );\n\n    ad_to_id[recipient] = marketId; //only for testing purposes, one utilizer should be able to create multiple markets\n    instrumentData.marketId = marketId;\n\n    vault.addProposal(instrumentData);\n\n    market_data[marketId] = MarketData(instrumentData.Instrument_address, recipient);\n\n    repNFT.storeTopReputation(marketManager.getParameters(marketId).r,  marketId); \n\n    emit MarketInitiated(marketId, recipient);\n  }\n\n\n\n\n  /// @notice Resolve function 1\n  /// @notice Prepare market/instrument for closing, called separately before resolveMarket\n  /// exists to circumvent manipulations   \n  function beforeResolve(uint256 marketId) \n  external \n  //onlyKeepers \n  {\n    vaults[id_parent[marketId]].beforeResolve(marketId);\n  }\n\n\n  /**\n  Resolve function 2\n  @notice main function called at maturity OR premature resolve of instrument(from early default)\n  \n  When market finishes at maturity, need to \n  1. burn all vault tokens in bc \n  2. mint all incoming redeeming vault tokens \n\n  Validators can call this function as they are incentivized to redeem\n  any funds left for the instrument , irrespective of whether it is in profit or inloss. \n  */\n  function resolveMarket(\n    uint256 marketId\n  ) external \n  //onlyValidators\n  {\n    (bool atLoss,\n    uint256 extra_gain,\n    uint256 principal_loss, \n    bool premature) = vaults[id_parent[marketId]].resolveInstrument(marketId); \n\n    marketManager.update_redemption_price(marketId, atLoss, extra_gain, principal_loss, premature); \n\n    cleanUpDust(marketId); \n  }\n\n  /// @notice When market resolves, should collect \n  /// remaining liquidity and/or dust from the wCollateral and send them  \n  /// back to the vault\n  /// @dev should be called before redeem_transfer is allowed \n  function cleanUpDust(\n    uint256 marketId\n    ) internal {\n    WrappedCollateral(marketManager.getZCB(marketId).getCollateral()).flush(getVaultAd( marketId));\n  }\n\n  /// @notice checks for maturity, resolve at maturity\n  /// @param marketId: called for anyone.\n  function checkInstrument(\n      uint256 marketId\n  ) external\n  ///onlyKeepers \n   returns (bool) {\n    Vault.InstrumentData memory data = vaults[id_parent[marketId]].fetchInstrumentData( marketId);\n      \n    require(data.marketId > 0 && data.trusted, \"instrument must be active\");\n    require(data.maturityDate > 0, \"instrument hasn't been approved yet\" );\n\n    if (block.timestamp >= data.maturityDate) {\n        // this.resolveMarket(marketId);\n        this.beforeResolve(marketId); \n        return true;\n    }\n    return false;\n  }\n\n\n  /// @notice when market is resolved(maturity/early default), calculates score\n  /// and update each assessment phase trader's reputation, called by individual traders when redeeming \n  function updateReputation(\n    uint256 marketId, \n    address trader, \n    bool increment) \n  external onlyManager {\n    uint256 implied_probs = marketManager.assessment_probs(marketId, trader);\n\n    if (increment) {\n      uint256 scoreToAdd = implied_probs.mulDivDown(implied_probs, config.WAD); //Experiment\n      repNFT.addScore(trader, scoreToAdd);\n    } else{\n      uint256 scoreToDeduct = implied_probs.mulDivDown(implied_probs, config.WAD); //Experiment\n      repNFT.decrementScore(trader, scoreToDeduct); \n    }\n  }\n\n  /// @notice function that closes the instrument/market before maturity, maybe to realize gains/cut losses fast\n  /// or debt is prematurely fully repaid, or underlying strategy is deemed dangerous, etc.  \n  /// @dev withdraws all balance from the instrument. \n  /// If assets in instrument is not in underlying, need all balances to be divested to underlying \n  /// Ideally this should be called by several validators, maybe implement a voting scheme and have a keeper call it.\n  /// @param emergency ascribes cases where the instrument should be forcefully liquidated back to the vault\n  function forceCloseInstrument(uint256 marketId, bool emergency) external returns(bool){\n    Vault vault = vaults[id_parent[marketId]]; \n\n    // Prepare for close \n    vault.closeInstrument(marketId); \n\n    // Harvests/records all profit & losses\n    vault.beforeResolve(marketId); \n\n    return true;\n\n    //Now the resolveMarket function should be called in the next transaction \n  }\n\n  /// @notice called by the validator when market conditions are met\n  /// need to move the collateral in the wCollateral to \n  function approveMarket(\n      uint256 marketId\n  ) external onlyManager {\n    Vault vault = vaults[id_parent[marketId]]; \n    BondingCurve bc = marketManager.getZCB(marketId); \n\n    require(marketManager.getCurrentMarketPhase(marketId) == 3,\"Market Condition Not met\");\n    require(vault.instrumentApprovalCondition(marketId), \"Instrument approval condition met\");\n\n    fetchAndStoreMarketDataForApproval(marketId, bc); \n\n    // For market to go to a post assessment stage there always needs to be a lower bound set  \n    marketManager.approveMarketAndSetLowerBound(marketId); \n\n    // move liquidity from wCollateral to vault, which will be used to fund the instrument\n    // this debt will be stored to later pull back to wCollateral  \n    uint256 reserves_to_push = bc.getReserves() + bc.getDiscountedReserves(); \n    console.log('bc reserves', bc.getReserves(), bc.getDiscountedReserves()); \n    console.log('wcollateral balance before',vault.UNDERLYING().balanceOf(bc.getCollateral()));  \n    WrappedCollateral(bc.getCollateral()).trustedTransfer(address(vault), reserves_to_push); \n    vault_debt[marketId] = reserves_to_push;\n    console.log('wcollateral balance',vault.UNDERLYING().balanceOf(bc.getCollateral()));  \n\n    // Trust and deposit to the instrument contract\n    vault.trustInstrument(marketId, approvalDatas[marketId]);\n  }\n\n\n  /// @notice receives necessary market information. Only applicable for creditlines \n  /// required for market approval such as max principal, quoted interest rate\n  function fetchAndStoreMarketDataForApproval(uint256 marketId, BondingCurve bc) internal{\n\n    (uint256 proposed_principal, uint256 proposed_yield) = vaults[id_parent[marketId]].viewPrincipalAndYield(marketId); \n\n    // get max_principal which is (s+1) * total long bought for creditline, or just be\n    // proposed principal for other instruments \n    uint256 max_principal = (marketManager.getParameters(marketId).s + config.WAD).mulWadDown(\n                            bc.getTotalCollateral()) ; \n    console.log('maxprincipal', max_principal, bc.getTotalCollateral()); \n    max_principal = min(max_principal, proposed_principal); \n\n    // Notional amount denominated in underlying, which is the area between curve and 1 at the x-axis point \n    // where area under curve is max_principal \n    uint256 quoted_interest = bc.calculateArbitraryPurchaseReturn(max_principal, 0) - max_principal; \n    console.log('quoted', quoted_interest); \n\n    approvalDatas[marketId] = ApprovalData(max_principal, quoted_interest); \n  }\n\n\n  function denyMarket(\n      uint256 marketId\n  ) external  \n  //onlyValidator(marketId) \n  {\n    require(marketManager.duringMarketAssessment(marketId), \"Not during assessment\");\n    \n    marketManager.denyMarket(marketId);\n\n    vaults[id_parent[marketId]].denyInstrument(marketId);\n\n    cleanUpDust(marketId); \n\n  }\n\n \n  /* --------GETTER FUNCTIONS---------  */\n  function getMarketId(address recipient) public view returns(uint256){\n    return ad_to_id[recipient];\n  }\n\n  function getVault(uint256 marketId) public view returns(Vault){\n    return vaults[id_parent[marketId]]; \n  }\n  function getVaultAd(uint256 marketId) public view returns(address){\n    return address(vaults[id_parent[marketId]]); \n  }\n\n  function isVerified(address addr)  public view returns (bool) {\n    return verified[addr];\n  }\n\n  function getVaultfromId(uint256 vaultId) public view returns(address){\n    return address(vaults[vaultId]); \n  }\n\n  function marketId_to_vaultId(uint256 marketId) public view returns(uint256){\n    return id_parent[marketId]; \n  }\n\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n      return a >= b ? a : b;\n  }\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n      return a <= b ? a : b;\n  }\n\n\n\n///  deprecated\n/// @notice called when market is resolved \n  function redeem_mint(\n    uint256 amount, \n    address to, \n    uint256 marketId) \n  external onlyManager{\n    vaults[id_parent[marketId]].controller_mint(amount,to); \n  }\n\n}\n\n"
    },
    "contracts/protocol/marketmanager.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport \"./owned.sol\";\nimport \"./reputationtoken.sol\"; \nimport {BondingCurve} from \"../bonds/bondingcurve.sol\";\nimport {Controller} from \"./controller.sol\";\nimport {OwnedERC20} from \"../turbo/OwnedShareToken.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"hardhat/console.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {LinearShortZCB, ShortBondingCurve} from \"../bonds/LinearShortZCB.sol\"; \nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {VRFConsumerBaseV2} from \"../chainlink/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2Interface} from \"../chainlink/VRFCoordinatorV2Interface.sol\";\nimport {config} from \"./helpers.sol\";\n\n/// @notice simple wrapped collateral to be used in markets instead of \n/// collateral. Redeemable for collateral one to one \ncontract WrappedCollateral is OwnedERC20 {\n\n  ERC20 collateral; \n  uint256 dec_dif; \n  constructor (\n      string memory name,\n      string memory symbol,\n      address owner, \n      address _collateral\n      ) OwnedERC20(name, symbol, owner) {\n      collateral = ERC20(_collateral);\n\n      // collateral_dec = collateral.decimals();\n      collateral.approve(owner, type(uint256).max); \n\n      dec_dif = decimals() - collateral.decimals(); //12 for USDC, 0 for 18\n    }\n\n  /// @notice called when buying \n  /// @param _amount is always in 18 \n  function mint(address _from, address _target, uint256 _amount) external {\n    uint256 amount = _amount/(10**dec_dif); \n    collateral.transferFrom(_from, address(this), amount); \n    _mint(_target, _amount); \n  }\n\n  /// @notice called when selling \n  function redeem(address _from, address _target, uint256 _amount) external {\n    uint256 amount = _amount/(10**dec_dif); \n\n    _burn(_from, _amount); \n    collateral.transfer(_target, amount); \n  }\n\n  function trustedTransfer(address _target, uint256 _amount) external {\n    require(msg.sender == owner, \"Not owner\"); \n    uint256 amount = _amount/(10**dec_dif); \n    collateral.transfer(_target, amount); \n  }\n\n  function flush(address flushTo) external onlyOwner{\n\n    collateral.transfer(flushTo, collateral.balanceOf(address(this))); \n  }\n\n}\n\ncontract MarketManager is Owned\n // VRFConsumerBaseV2 \n {\n  using FixedPointMathLib for uint256;\n\n  // Chainlink state variables\n  VRFCoordinatorV2Interface COORDINATOR;\n  uint64 private immutable subscriptionId;\n  bytes32 private keyHash;\n  uint32 private callbackGasLimit = 100000;\n  uint16 private requestConfirmations = 3;\n  uint256 total_validator_bought; // should be a mapping no?\n  bool private _mutex;\n\n  ReputationNFT rep;\n  Controller controller;\n  CoreMarketData[] public markets;\n\n  mapping(uint256 => uint256) requestToMarketId; // chainlink request id to marketId\n  mapping(uint256 => ValidatorData) validator_data; //marketId-> total amount of zcb validators can buy \n  mapping(uint256=> mapping(address=> uint256)) sale_data; //marketId-> total amount of zcb bought\n  mapping(uint256=>uint256) private redemption_prices; //redemption price for each market, set when market resolves \n  mapping(uint256=>mapping(address=>uint256)) private assessment_collaterals;  //marketId-> trader->collateralIn\n  mapping(uint256=>mapping(address=>uint256)) private assessment_prices; \n  mapping(uint256=>mapping(address=>bool)) private assessment_trader;\n  mapping(uint256=>mapping(address=>uint256) ) public assessment_probs; \n  mapping(uint256=> MarketPhaseData) public restriction_data; // market ID => restriction data\n  mapping(uint256=> uint256) collateral_pot; // marketID => total collateral recieved\n  mapping(uint256=> CDP) private debt_pools; // marketID => debt info\n  mapping(uint256=> MarketParameters) private parameters; //marketId-> params\n  mapping(uint256=> mapping(address=>bool)) private redeemed; \n  mapping(uint256=>mapping(address=>bool)) isShortZCB; //marketId-> address-> isshortZCB\n  mapping(uint256=>mapping(address=>uint256) )assessment_shorts; // short collateral during assessment\n\n  struct CoreMarketData {\n    BondingCurve long;\n    ShortBondingCurve short;\n    string description; // instrument description\n    uint256 creationTimestamp;\n    uint256 resolutionTimestamp;\n  }\n\n  struct CDP{\n    mapping(address=>uint256) collateral_amount;\n    mapping(address=>uint256) borrowed_amount; \n    uint256 total_debt; \n    uint256 total_collateral;\n  }\n\n  struct MarketPhaseData {\n    bool duringAssessment;\n    bool onlyReputable;\n    bool resolved;\n    uint256 min_rep_score;\n    bool alive;\n    bool atLoss;\n    uint256 base_budget;\n  }\n\n  struct ValidatorData{\n    uint256 val_cap;// total zcb validators can buy at a discount\n    uint256 avg_price; //price the validators can buy zcb at a discount \n    address[] candidates; // possible validators\n    address[] validators;\n    uint8 confirmations;\n    bool requested; // true if already requested random numbers from array.\n    mapping(address => uint256) sales; // amount of zcb bought per validator\n    uint256 totalSales; // total amount of zcb bought;\n    uint256 numApprovedValidators; \n  }\n\n  /// @param N: upper bound on number of validators chosen.\n  /// @param sigma: validators' stake\n  /// @param alpha: minimum managers' stake\n  /// @param omega: high reputation's stake \n  /// @param delta: Upper and lower bound for price which is added/subtracted from alpha \n  /// @param r:  reputation ranking for onlyRep phase\n  /// @param s: senior coefficient; how much senior capital the managers can attract at approval \n  /// param beta: how much volatility managers are absorbing \n  /// param leverage: how much leverage managers can apply \n  /// param base_budget: higher base_budget means lower decentralization, \n  /// @dev omega always <= alpha\n  struct MarketParameters{\n    uint32 N;\n    uint256 sigma; \n    uint256 alpha; \n    uint256 omega;\n    uint256 delta; \n    uint256 r;\n    uint256 s; \n  }\n\n\n  modifier onlyController(){\n    require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \"is not controller\"); \n    _;\n  }\n\n\n  modifier _lock_() {\n    require(!_mutex, \"ERR_REENTRY\");\n    _mutex = true;\n    _;\n    _mutex = false;\n  }\n\n  constructor(\n    address _creator_address,\n    address reputationNFTaddress,  \n    address _controllerAddress,\n    address _vrfCoordinator, // 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed\n     bytes32 _keyHash, // 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f\n    uint64 _subscriptionId // 1713\n  ) \n    Owned(_creator_address) \n    //VRFConsumerBaseV2(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed) \n  {\n    rep = ReputationNFT(reputationNFTaddress);\n    controller = Controller(_controllerAddress);\n    keyHash = bytes32(0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f);\n    subscriptionId = 1713;\n    COORDINATOR = VRFCoordinatorV2Interface(0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed);\n    \n    // push empty market\n    markets.push(\n      makeEmptyMarketData()\n    );\n  }\n\n  function makeEmptyMarketData() public pure returns (CoreMarketData memory) {\n    return CoreMarketData(\n        BondingCurve(address(0)),\n        ShortBondingCurve(address(0)),\n        \"\",\n        0,\n        0\n      );\n  }\n\n  function marketCount() public view returns (uint256) {\n    return markets.length;\n  }\n\n  function getMarket(uint256 _id) public view returns (CoreMarketData memory) {\n        if (_id >= markets.length) {\n            return makeEmptyMarketData();\n        } else {\n            return markets[_id];\n        }\n  }\n\n\n  /// @notice parameters have to be set prior \n  function newMarket(\n    uint256 marketId, \n    uint256 principal, \n    uint256 expectedYield, \n    BondingCurve _long, \n    ShortBondingCurve _short, \n    string calldata _description, \n    uint256 _creationTimestamp\n    ) external onlyController{\n\n    markets.push(CoreMarketData(\n      _long,\n      _short,\n      _description,\n      _creationTimestamp,\n      0\n    ));\n\n    uint256 base_budget = 1000 * config.WAD; //TODO \n\n    setMarketPhase(marketId, true, true, base_budget);  \n    \n    setCurves(marketId);\n    \n    setValidatorCap(marketId, principal, expectedYield); \n    \n    setUpperBound(marketId, principal.mulWadDown(parameters[marketId].alpha+ parameters[marketId].delta));  \n\n  }\n\n  /*----Phase Functions----*/\n\n  /// @notice list of parameters in this system for each market, should vary for each instrument \n  /// @dev calculates market driven s from utilization rate. If u-r high,  then s should be low, as 1) it disincentivizes \n  /// managers to approving as more proportion of the profit goes to the LP, and 2) disincentivizes the borrower \n  /// to borrow as it lowers approved principal and increases interest rate \n  function setParameters(\n    MarketParameters memory param,\n    uint256 utilizationRate,\n    uint256 marketId \n    ) external onlyController{\n\n    parameters[marketId] = param; \n    parameters[marketId].s = param.s.mulWadDown(config.WAD - utilizationRate); // experiment\n    console.log('utilization rate/s', utilizationRate, parameters[marketId].s);  \n  }\n\n  /// @notice gets the top percentile reputation score threshold \n  function calcMinRepScore(uint256 marketId) internal view returns(uint256){\n    return rep.getMinRepScore(parameters[marketId].r, marketId); \n  }\n\n  /// @notice sets market phase data\n  /// @dev called on market initialization by controller\n  /// @param base_budget: base budget (amount of vault tokens to spend) as a market manager during the assessment stage\n  function setMarketPhase(\n    uint256 marketId, \n    bool duringAssessment,\n    bool _onlyReputable,\n    uint256 base_budget\n  ) internal {\n    MarketPhaseData storage data = restriction_data[marketId]; \n    data.onlyReputable = _onlyReputable; \n    data.duringAssessment = duringAssessment;\n    data.min_rep_score = calcMinRepScore(marketId);\n    data.base_budget = base_budget;\n    data.alive = true;\n  }\n\n  \n  /// @notice setup for long and short ZCBs.\n   \n  function setCurves(\n    uint256 marketId\n  ) internal {\n    isShortZCB[marketId][address(markets[marketId].short)] = true;\n    markets[marketId].long.setShortZCB(address(markets[marketId].short));\n  }\n\n  /// @notice used to transition from reputationphases \n  function setReputationPhase(\n    uint256 marketId,\n    bool _onlyReputable\n  ) internal {\n    require(restriction_data[marketId].alive, \"market must be alive\");\n    restriction_data[marketId].onlyReputable = _onlyReputable;\n  }\n\n  function getPhaseData(\n    uint256 marketId\n  ) public view returns (MarketPhaseData memory)  {\n    return restriction_data[marketId];\n  }\n  \n  /// @notice main approval function called by controller\n  /// @dev if market is alive and market is not during assessment, it is approved. \n  function approveMarketAndSetLowerBound(\n    uint256 marketId\n    ) external onlyController {\n    require(restriction_data[marketId].alive);\n\n    restriction_data[marketId].duringAssessment = false; \n    uint256 lower_bound = (parameters[marketId].alpha - parameters[marketId].delta)\n                  .mulWadDown(controller\n                  .getVault(marketId)\n                  .fetchInstrumentData(marketId)\n                  .principal ); \n\n    setLowerBound(marketId, lower_bound) ; \n  }\n\n  /// @notice called by controller when market is initialized \n  function setUpperBound(\n    uint256 marketId, \n    uint256 new_upper_bound\n    ) internal  {\n    markets[marketId].long.setUpperBound(new_upper_bound);\n  }\n    \n  /// @notice called by controller when market is approved\n  function setLowerBound(\n    uint256 marketId, \n    uint256 new_lower_bound\n    ) private {\n    // BondingCurve(controller.getZCB_ad(marketId)).setLowerBound(new_lower_bound);\n    markets[marketId].long.setLowerBound(new_lower_bound);\n  }\n  \n  /// @notice Called when market should end, a) when denied b) when maturity \n  /// @param resolve is true when instrument does not resolve prematurely\n  function deactivateMarket(uint256 marketId, bool atLoss, bool resolve) internal{\n    restriction_data[marketId].resolved = resolve; \n    restriction_data[marketId].atLoss = atLoss; \n    restriction_data[marketId].alive = false; //TODO alive should be true, => alive is false when everyone has redeemed.\n  }\n\n\n  /* \n  Returns Minimal reputation score to participate in the onlyReputation phase\n  TODO\n  */\n  function getMinRepScore(uint256 marketId) public view returns(uint256){\n    return restriction_data[marketId].min_rep_score;\n  }\n\n\n  /* Conditions */\n  \n  /// @dev verification of trader initializes reputation score at 0, to gain reputation need to participate in markets.\n  function isVerified(address trader) public view returns(bool){\n    return (controller.isVerified(trader) || trader == owner);\n  }\n\n  function isReputable(address trader, uint256 marketId) public view returns(bool){\n    return (restriction_data[marketId].min_rep_score <= rep.getReputationScore(trader) || trader == owner); \n  }\n\n  function duringMarketAssessment(\n    uint256 marketId) public view returns(bool){\n    return restriction_data[marketId].duringAssessment; \n  }\n\n  function onlyReputable(\n    uint256 marketId\n    ) public view returns(bool){\n    return restriction_data[marketId].onlyReputable; \n\n  }\n\n  function isMarketApproved(uint256 marketId) public view returns(bool){\n    return(!restriction_data[marketId].duringAssessment && restriction_data[marketId].alive); \n    \n  }\n\n  function marketActive(uint256 marketId) public view returns(bool){\n    return restriction_data[marketId].alive; \n  }\n\n  /// @notice returns true if amount bought is greater than the insurance threshold\n  function marketCondition(uint256 marketId) public view returns(bool){\n    //BondingCurve bc = BondingCurve(controller.getZCB_ad(marketId)); \n    BondingCurve bc = markets[marketId].long;\n    uint256 principal = controller.getVault(marketId).fetchInstrumentData(marketId).principal;\n    uint256 total_bought = bc.getTotalCollateral();\n\n    return (total_bought>= principal.mulWadDown(parameters[marketId].alpha)); \n  }\n\n  /// @notice returns whether current market is in phase \n  /// 1: onlyReputable, which also means market is in assessment\n  /// 2: not onlyReputable but in asseessment \n  /// 3: in assessment but canbeapproved \n  /// 4: post assessment(accepted or denied)\n  function getCurrentMarketPhase(uint256 marketId) public view returns(uint256){\n    if (onlyReputable(marketId)){\n      assert(!marketCondition(marketId) && !isMarketApproved(marketId) && duringMarketAssessment(marketId) ); \n      return 1; \n    }\n\n    else if (duringMarketAssessment(marketId) && !onlyReputable(marketId)){\n      assert(!isMarketApproved(marketId)); \n      if (marketCondition(marketId)) return 3; \n      return 2; \n    }\n\n    else if (isMarketApproved( marketId)){\n      assert (!duringMarketAssessment(marketId) && marketCondition(marketId)); \n      return 4; \n    }\n\n  }\n\n  function getDebtPosition(address trader, uint256 marketId) public view returns(uint256, uint256){\n    CDP storage cdp = debt_pools[marketId];\n    return (cdp.collateral_amount[trader], cdp.borrowed_amount[trader]);\n  }\n\n  /// @notice get trade budget = f(reputation), returns in collateral_dec\n  /// sqrt for now\n  function getTraderBudget(uint256 marketId, address trader) public view returns(uint256){\n    uint256 repscore = rep.getReputationScore(trader); \n    //uint256 collateral_dec =  BondingCurve(controller.getZCB_ad(marketId)).collateral_dec(); \n    uint256 collateral_dec = markets[marketId].long.collateral_dec();\n    if (repscore==0) return 0; \n\n    return restriction_data[marketId].base_budget + (repscore*config.WAD).sqrt();\n  }\n  \n  /// @notice computes the price for ZCB one needs to short at to completely\n  /// hedge for the case of maximal loss, function of principal and interest\n  function getHedgePrice(uint256 marketId) public view returns(uint256){\n    uint256 principal = controller.getVault(marketId).fetchInstrumentData(marketId).principal; \n    uint256 yield = controller.getVault(marketId).fetchInstrumentData(marketId).expectedYield; \n    uint256 den = principal.mulWadDown(config.WAD - parameters[marketId].alpha); \n    return config.WAD - yield.divWadDown(den); \n    // uint256 den = (principal * (PRICE_PRECISION - parameters[marketId].alpha))/PRICE_PRECISION; \n    // return PRICE_PRECISION -  (yield*PRICE_PRECISION)/den;\n\n  }\n\n  function getParameters(uint256 marketId) public view returns(MarketParameters memory){\n    return parameters[marketId]; \n  }\n\n  function getZCB(uint256 marketId) public view returns (BondingCurve) {\n    return markets[marketId].long;\n  }\n\n  function getShortZCB(uint256 marketId) public view returns (ShortBondingCurve) {\n    return markets[marketId].short;\n  }\n\n  /// @notice computes maximum amount of quantity that trader can short while being hedged\n  /// such that when he loses his loss will be offset by his gains  \n  function getHedgeQuantity(address trader, uint256 marketId) public view returns(uint256){\n    uint num = controller.getVault(marketId).fetchInstrumentData(marketId)\n              .principal.mulWadDown(config.WAD - parameters[marketId].alpha); \n    return num.mulDivDown(controller.getVault(marketId).balanceOf(trader), \n              controller.getVault(marketId).totalSupply()); \n  }\n  \n  /**\n   @notice performs checks for buy function\n   @param amount: collateral in vault tokens to buy ZCB.\n   */\n  function _canBuy(\n    address trader,\n    uint256 amount,\n    uint256 marketId\n  ) internal view {\n    //If after assessment there is a set buy threshold, people can't buy above this threshold\n    require(marketActive(marketId), \"Market Not Active\");\n\n    //If called from shortZCB contract should b \n    if (isShortZCB[marketId][msg.sender]){\n      return; \n    }\n\n    bool _duringMarketAssessment = duringMarketAssessment(marketId);\n    bool _onlyReputable =  onlyReputable(marketId);\n\n    if (_duringMarketAssessment){\n      if (!isVerified(trader)) revert(\"trader is not verified\");\n      if (!(getTraderBudget(marketId, trader)>= amount + rep.balances(marketId, trader))) revert(\"trader budget limit exceeded\");\n    }\n\n    //During the early risk assessment phase only reputable can buy \n    if (_onlyReputable){\n      require(_duringMarketAssessment, \"Market needs to be in assessment phase\"); \n      if (!isReputable(trader, marketId)){ \n        revert(\"trader lacks sufficient reputation\");\n      }\n    }\n  }\n\n\n  /// @notice amount is in zcb_amount_in\n  function _canSell(\n    address trader,\n    uint256 amount, \n    uint256 marketId\n  ) internal view returns(bool) {\n    require(marketActive(marketId), \"Market Not Active\");\n    //BondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\n    BondingCurve zcb = markets[marketId].long;\n\n    // For current onchain conditions, the estimated collateral \n    // trader would obtain should be less than budget  \n    if (!(getTraderBudget(marketId, trader) >= zcb.calculateSaleReturn(amount))) return false; \n    \n    return true; \n  }\n\n  \n  /// @notice During assessment phase, need to log the trader's \n  /// total collateral when he bought zcb. Trader can only redeem collateral in \n  /// when market is not approved \n  function _logAssessmentTrade(\n    uint256 marketId, \n    address trader, \n    uint256 collateralIn,\n    uint256 probability\n    )\n    internal \n  { \n    assessment_trader[marketId][trader] = true; \n    assessment_collaterals[marketId][trader] += collateralIn;\n    assessment_probs[marketId][trader] = probability; \n\n    // queuedRepUpdates[msg.sender] += 1; \n\n  }\n\n  /// @notice denies market from validator \n  function denyMarket(\n    uint256 marketId\n  ) external onlyController {\n    require(marketActive(marketId), \"Market Not Active\"); \n    require(restriction_data[marketId].duringAssessment, \"Not in assessment\"); \n    MarketPhaseData storage data = restriction_data[marketId]; \n    // data.resolved = true; \n    data.duringAssessment = false;\n  }\n\n\n  ///VALIDATOR FUNCTIONS \n\n  /// @notice called when market initialized, calculates the average price and quantities of zcb\n  /// validators will buy at a discount when approving\n  /// valcap => sigma * princpal.\n  // \n  function setValidatorCap(\n    uint256 marketId,\n    uint256 principal,\n    uint256 interest\n  ) internal {\n    //BondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\n    BondingCurve zcb = markets[marketId].long;\n    assert(config.isInWad(parameters[marketId].sigma) && config.isInWad(principal));\n\n    uint256 valColCap = (parameters[marketId].sigma.mulWadDown(principal)); \n\n    // Get how much ZCB validators need to buy in total, which needs to be filled \n    // for the market to be approved \n    uint256 disCap = zcb.get_discount_cap();\n    uint256 avgPrice = valColCap.divWadDown(disCap);\n\n    validator_data[marketId].val_cap = disCap;\n    validator_data[marketId].avg_price = avgPrice; \n  }\n\n  function isValidator(uint256 marketId, address user) view public returns(bool){\n    address[] storage _validators = validator_data[marketId].validators;\n    for (uint i = 0; i < _validators.length; i++) {\n      if (_validators[i] == user) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n  function _removeValidator(uint256 marketId, address user) internal {\n    address[] storage arr = validator_data[marketId].validators;\n    uint256 length = arr.length;\n    \n    for (uint i = 0; i < length; i++) {\n      if (user == arr[i]) {\n        arr[i] = arr[length - 1];\n        arr.pop();\n        return;\n      }\n    }\n  }\n\n  /**\n   @notice randomly choose validators for market approval, async operation => fulfillRandomness is the callback function.\n   @dev called when phase changes onlyRep => false\n   */\n  function _getValidators(uint256 marketId) internal {\n\n    validator_data[marketId].requested = true;\n\n    //TODO N is currently upper bound on number of validators.\n    if (validator_data[marketId].candidates.length <= parameters[marketId].N) {\n      validator_data[marketId].validators = validator_data[marketId].candidates;\n      return;\n    }\n\n    uint256 _requestId = COORDINATOR.requestRandomWords(\n      keyHash,\n      subscriptionId,\n      requestConfirmations,\n      callbackGasLimit,\n      parameters[marketId].N\n    );\n\n    requestToMarketId[_requestId] = marketId;\n  }\n\n  /**\n   @notice chainlink callback function, sets validators.\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) \n  internal \n  //override \n  {\n    uint256 marketId = requestToMarketId[requestId];\n    assert(randomWords.length == parameters[marketId].N);\n\n    address[] memory temp = validator_data[marketId].candidates;\n    uint256 _N = parameters[marketId].N;\n    uint256 length = _N;\n\n    for (uint8 i = 0; i < _N; i++) {\n      uint j = randomWords[i] % length;\n      address selected = temp[j];\n      validator_data[marketId].validators.push(selected);\n      temp[j] = temp[length - 1];\n      length--;\n    }\n  }\n\n  function getValidatorRequiredCollateral(uint256 marketId) public view returns(uint256){\n\n    uint256 val_cap =  validator_data[marketId].val_cap; \n    uint256 zcb_for_sale = val_cap/parameters[marketId].N; \n    return zcb_for_sale.mulWadDown(validator_data[marketId].avg_price); \n  } \n\n  function numValidatorLeftToApproval(uint256 marketId) public view returns(uint256){\n    return parameters[marketId].N - validator_data[marketId].numApprovedValidators; \n  }\n\n  /// @notice allows validators to buy at a discount \n  /// They can only buy a fixed amount of ZCB, usually a at lot larger amount \n  /// @dev get val_cap, the total amount of zcb for sale and each validators should buy \n  /// val_cap/num validators zcb \n  /// They also need to hold the corresponding vault, so they are incentivized to assess at a systemic level and avoid highly \n  /// correlated instruments \n  /// TODO change this to staking system \n  function validatorBuy(\n    uint256 marketId\n  ) external  {\n    require(marketCondition(marketId), \"Market can't be approved\"); \n    BondingCurve zcb = markets[marketId].long;\n\n    uint256 val_cap =  validator_data[marketId].val_cap; \n    uint256 zcb_for_sale = val_cap/parameters[marketId].N; \n    uint256 collateral_required = zcb_for_sale.mulWadDown(validator_data[marketId].avg_price); \n\n    require(validator_data[marketId].sales[msg.sender] <= zcb_for_sale, \"already approved\");\n   // require(controller.getVault().balanceInUnderlying(msg.sender) >= collateral_required, \"Not enough vault exposure\"); \n\n    validator_data[marketId].sales[msg.sender] += zcb_for_sale;\n    validator_data[marketId].totalSales += (zcb_for_sale +1);  //since division rounds down \n    validator_data[marketId].numApprovedValidators += 1; \n\n    WrappedCollateral wCollateral = WrappedCollateral(zcb.getCollateral()); \n    wCollateral.mint(msg.sender, address(this), collateral_required); \n    wCollateral.transfer(address(zcb), collateral_required);\n\n    zcb.trustedDiscountedMint(msg.sender, zcb_for_sale);\n    zcb.incrementDiscountedReserves(collateral_required); \n\n    // Last validator pays more gas, is fair because earlier validators are more uncertain \n    if (validatorApprovalCondition(marketId)) controller.approveMarket(marketId);\n  }\n\n  function validatorApprovalCondition(uint256 marketId ) public view returns(bool){\n    //return(total_validator_bought >= validator_data[marketId].val_cap);\n    return (validator_data[marketId].totalSales >= validator_data[marketId].val_cap); \n  }\n\n  mapping(uint256=> mapping(address=>uint256)) longTrades; \n  mapping(uint256=> mapping(address=>uint256)) shortTrades;\n\n  /// @notice log how much collateral trader has at stake, \n  /// to be used for redeeming later \n  function _logTrades(\n    uint256 marketId,\n    address trader, \n    uint256 collateral, \n    bool isBuy, \n    bool isLong\n    ) internal {\n\n    if (isLong){\n      if (isBuy) longTrades[marketId][trader] += collateral; \n      else longTrades[marketId][trader] -= collateral; \n    }\n\n    else{\n      if (isBuy) shortTrades[marketId][trader] += collateral; \n      else shortTrades[marketId][trader] -= collateral; \n    }\n  }\n\n  /// @notice main entry point for longZCB buys\n  /// @param _collateralIn: amount of collateral tokens in WAD\n  /// @param _min_amount_out is min quantity of ZCB returned\n  function buy(\n      uint256 _marketId,\n      uint256 _collateralIn,\n      uint256 _min_amount_out\n    ) external _lock_ returns (uint256 amountOut) {\n    require(!restriction_data[_marketId].resolved, \"must not be resolved\");\n    _canBuy(msg.sender, _collateralIn, _marketId);\n\n    // BondingCurve zcb = BondingCurve(controller.getZCB_ad(_marketId)); // SOMEHOW GET ZCB\n    BondingCurve zcb = markets[_marketId].long;\n    WrappedCollateral wCollateral = WrappedCollateral(zcb.getCollateral()); \n\n    // Mint wCollateral to this address\n    wCollateral.mint(msg.sender, address(this), _collateralIn); \n    wCollateral.approve(address(zcb), _collateralIn); \n\n    // reentrant locked and trusted contract with no hooks, so ok \n    // need to set reuputation phase after the trade \n    amountOut = zcb.trustedBuy(address(this), _collateralIn, _min_amount_out);\n\n    //Need to log assessment trades for updating reputation scores or returning collateral\n    //when market denied \n    _logTrades(_marketId, msg.sender, _collateralIn, true, true); \n\n    if (duringMarketAssessment(_marketId)){\n\n      // rep.incrementBalance(_marketId, msg.sender, _collateralIn);\n\n      // keep track of amount bought during reputation phase\n      // and make transitions from onlyReputation true->false\n      if(onlyReputable(_marketId)){\n        uint256 principal = controller.getVault(_marketId).fetchInstrumentData(_marketId).principal;\n        uint256 total_bought = zcb.getTotalCollateral();\n\n        // first time rep user buying.\n        if (!assessment_trader[_marketId][msg.sender]) {\n          validator_data[_marketId].candidates.push(msg.sender);\n        }\n\n        if (total_bought >= parameters[_marketId].omega.mulWadDown(principal)) {\n          setReputationPhase(_marketId, false);\n          _getValidators(_marketId);\n        }\n      }\n      \n      assessment_probs[_marketId][msg.sender] =  zcb.calcImpliedProbability(\n          _collateralIn, \n          getTraderBudget(_marketId, msg.sender) \n      ); \n  \n      }\n\n    zcb.transfer(msg.sender, amountOut); \n\n\n  }\n\n\n  function sell(\n      uint256 _marketId,\n      uint256 _zcb_amount_in, \n      uint256 _min_collateral_out\n    ) external _lock_ returns (uint256 amountOut){\n    require(!restriction_data[_marketId].resolved, \"must not be resolved\");\n    require(_canSell(msg.sender, \n      _zcb_amount_in, \n      _marketId),\"Trade Restricted\");\n\n    //BondingCurve zcb = BondingCurve(controller.getZCB_ad(_marketId)); // SOMEHOW GET ZCB\n    BondingCurve zcb = markets[_marketId].long;\n\n    zcb.transferFrom(msg.sender, address(this), _zcb_amount_in); \n\n    // wCollateral to this address\n    amountOut = zcb.trustedSell(address(this), _zcb_amount_in, _min_collateral_out);\n\n    _logTrades(_marketId, msg.sender, amountOut, false, true); \n\n    //Send collateral to trader \n    WrappedCollateral(zcb.getCollateral()).redeem(address(this), msg.sender, amountOut); \n\n    if (!duringMarketAssessment(_marketId)) deduct_selling_fee(); \n\n    // queuedRepUpdates[msg.sender] -= 1; \n\n  }\n\n  function deduct_selling_fee() internal {}\n\n  // function add_short_zcb(\n  //   uint256 marketId\n  // ) external onlyController{\n  //   isShortZCB[marketId][markets[marketId].short] = true;\n  //   shortZCBs[marketId] = shortZCB_address;\n  //   BondingCurve(markets[marketId].long).setShortZCB(shortZCB_address); \n\n  // }\n\n  /**\n   @param collateralIn: amount of collateral (vt)\n   */\n  function openShort(\n    uint256 marketId,\n    uint256 collateralIn, \n    uint256 min_amount_out\n  ) external _lock_ {\n\n    if (duringMarketAssessment(marketId)){\n      _logAssessmentShorts(marketId, msg.sender, collateralIn); \n      // queuedRepUpdates[msg.sender] += 1; \n\n    }\n    //ShortBondingCurve shortZCB = ShortBondingCurve(shortZCBs[marketId]); \n    ShortBondingCurve shortZCB = markets[marketId].short;\n    WrappedCollateral wCollateral = WrappedCollateral(shortZCB.getCollateral()); \n\n    // Mint wCollateral to this address\n    wCollateral.mint(msg.sender, address(this), collateralIn); \n    wCollateral.approve(address(shortZCB), collateralIn); \n\n    // lendAmount: amount of zcb to borrow w/ shortZCB pricing\n    (uint lendAmount, uint c) = shortZCB.calculateAmountGivenSell(collateralIn);\n    _logTrades(marketId, msg.sender, collateralIn, true, false); \n\n    // zcb minted to shortzcb contract\n    _lendForShort(msg.sender, marketId, lendAmount);\n\n    if (duringMarketAssessment(marketId)) deduct_selling_fee(); \n\n    shortZCB.trustedShort(address(this), collateralIn, min_amount_out); \n\n    shortZCB.transfer(msg.sender, lendAmount); \n\n\n  }\n\n  /// @notice called when short is being opened, it allows shortZCB contract to \n  /// \"borrow\" by minting new ZCB to the shortZCB contract. \n  /// @dev although minting new zcb is different from borrowing from existing zcb holders, \n  /// in the context of our bonding curve prediction \n  /// market this is alllowed since we just dont allow longZCB holders \n  /// to sell when liquidity dries up   \n  function _lendForShort(\n    address trader, \n    uint256 marketId, \n    uint256 requested_zcb\n    ) internal {\n    // BondingCurve zcb = BondingCurve(controller.getZCB_ad(marketId));\n    BondingCurve zcb = markets[marketId].long;\n\n    // Log debt data \n    CDP storage cdp = debt_pools[marketId];\n    cdp.collateral_amount[trader] += requested_zcb; \n    cdp.borrowed_amount[trader] += requested_zcb;  \n    cdp.total_debt += requested_zcb; \n    cdp.total_collateral += requested_zcb; //only ds \n    collateral_pot[marketId] += requested_zcb; //Total ds collateral \n\n    zcb.trustedDiscountedMint(address(markets[marketId].short), requested_zcb); \n  }\n\n   function _repayForShort(\n    address trader, \n    uint256 marketId, \n    uint256 repaying_zcb\n    ) internal {\n    // BondingCurve zcb = BondingCurve(controller.getZCB_ad(marketId));\n    BondingCurve zcb = markets[marketId].long;\n\n    CDP storage cdp = debt_pools[marketId];\n    cdp.collateral_amount[trader] -= repaying_zcb; \n    cdp.borrowed_amount[trader] -= repaying_zcb; \n    cdp.total_debt -= repaying_zcb; \n    cdp.total_collateral -= repaying_zcb; \n    collateral_pot[marketId] -= repaying_zcb;\n  }\n\n  /// @notice called by user to repay shorts\n  /// @param close_amount is in of shortZCB, 18dec \n  function closeShort(\n    uint256 marketId, \n    uint256 close_amount, \n    uint256 min_collateral_out\n    ) external _lock_ {\n\n\n    \n    ShortBondingCurve shortZCB = markets[marketId].short; //ShortBondingCurve(shortZCBs[marketId]);\n\n    _repayForShort(msg.sender, marketId, close_amount);\n\n    shortZCB.transferFrom(msg.sender, address(this), close_amount);\n\n    // This will buy close_amount worth of longZCB to the shortZCB contract \n    (uint256 returned_collateral, uint256 tokenToBeBurned) = shortZCB.trustedClose(address(this), close_amount, min_collateral_out);  \n     _logTrades(marketId, msg.sender, returned_collateral, false, false); \n\n    if(duringMarketAssessment(marketId)){\n      assessment_shorts[marketId][msg.sender] -= returned_collateral;  \n    }\n\n    // Now burn the contract's bought longZCB imediately  \n    markets[marketId].long.trustedDiscountedBurn(address(shortZCB), tokenToBeBurned);\n\n    // Return collateral to trader \n    WrappedCollateral(shortZCB.getCollateral()).redeem(address(this), msg.sender, returned_collateral); \n\n\n  }\n\n  function _logAssessmentShorts(uint256 marketId, address trader, uint256 collateralIn) internal {\n    assessment_shorts[marketId][trader] += collateralIn; \n  }\n\n\n  /// @notice called by traders when market is resolved  \n  function redeemShortZCB(\n    uint256 marketId \n    ) external _lock_ returns(uint256){\n    require(!marketActive(marketId), \"Market Active\"); \n    // LinearShortZCB shortZCB = LinearShortZCB(shortZCBs[marketId]);\n    ShortBondingCurve shortZCB = markets[marketId].short;\n    uint256 shortZCB_redeem_amount = shortZCB.balanceOf(msg.sender); \n    shortZCB.trustedBurn(msg.sender, shortZCB_redeem_amount); \n    assert(controller.getVault(marketId).balanceOf(address(shortZCB))==0);\n\n    uint256 long_redemption_price = get_redemption_price(marketId);\n    uint256 redemption_price = long_redemption_price >= config.WAD ? 0 : config.WAD - long_redemption_price; \n    uint256 collateral_redeem_amount = redemption_price.mulWadDown(shortZCB_redeem_amount); \n\n    controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \n    return collateral_redeem_amount; \n  }\n\n  /// @notice called by traders when market is denied or resolve before maturity \n  function redeemDeniedMarket(\n    uint256 marketId, \n    bool isLong\n  ) external _lock_ {\n    require(!restriction_data[marketId].alive, \"Market Still During Assessment\"); // TODO\n\n    uint256 collateral_amount;\n\n    // Get collateral at stake in shorts, which will be directly given back to traders\n    if(!isLong){\n      ShortBondingCurve shortZCB = markets[marketId].short;\n      require(shortZCB.balanceOf(msg.sender) >= 0, \"Empty Balance\");\n\n      collateral_amount = shortTrades[marketId][msg.sender]; \n      delete shortTrades[marketId][msg.sender]; \n\n      //Burn all their balance\n      shortZCB.trustedBurn( msg.sender,  shortZCB.balanceOf(msg.sender));\n    } \n\n    // Get collateral at stake in longs, which will be directly given back to traders\n    else {\n      // BondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\n      BondingCurve zcb = markets[marketId].long;\n\n      require(zcb.balanceOf(msg.sender) >= 0, \"Empty Balance\");\n\n      if (isValidator(marketId, msg.sender)) {\n\n        collateral_amount = validator_data[marketId].sales[msg.sender].mulWadDown(validator_data[marketId].avg_price);\n        delete validator_data[marketId].sales[msg.sender];\n      }\n      else{\n        collateral_amount = longTrades[marketId][msg.sender]; \n        delete longTrades[marketId][msg.sender]; \n      }\n\n      // Burn all their balance \n      zcb.trustedBurn(msg.sender, zcb.balanceOf(msg.sender)); \n    }\n\n    // Before redeem_transfer is called all funds for this instrument should be back in the vault\n    // including dust from wCollateral \n    controller.redeem_transfer(collateral_amount, msg.sender, marketId);\n\n    // queuedRepUpdates[msg.sender] -= 1; \n\n    //TODO need to check if last redeemer, so can kill market.\n\n  }\n\n\n\n  function get_redemption_price(uint256 marketId) public view returns(uint256){\n    return redemption_prices[marketId]; \n  }\n\n  /**\n  @dev Redemption price, as calculated (only once) at maturity,\n  depends on total_repayed/(principal + predetermined yield)\n  If total_repayed = 0, redemption price is 0\n  @param atLoss: defines circumstances where expected returns are higher than actual\n  @param loss: facevalue - returned amount => non-negative always?\n  @param extra_gain: any extra yield not factored during assessment. Is 0 yield is as expected\n   */\n  function update_redemption_price(\n    uint256 marketId,\n    bool atLoss, \n    uint256 extra_gain, \n    uint256 loss, \n    bool premature\n  ) external  onlyController {  \n    if (atLoss) assert(extra_gain == 0); \n    assert(debt_pools[marketId].total_debt == markets[marketId].short.totalSupply());\n\n    // BondingCurve zcb = BondingCurve(address(controller.getZCB(marketId))); // SOMEHOW GET ZCB\n    BondingCurve zcb = markets[marketId].long;\n\n    uint256 total_supply = zcb.getTotalZCB(); \n    uint256 total_shorts = (extra_gain >0) ? debt_pools[marketId].total_debt :0; \n\n    if(!atLoss){\n      redemption_prices[marketId] = config.WAD + extra_gain.divWadDown(total_supply + total_shorts); \n      console.log('redemtionprice', redemption_prices[marketId]); \n    } \n    else {\n      if (config.WAD <= loss.divWadDown(total_supply)){\n        redemption_prices[marketId] = 0; \n      }\n      else {\n        redemption_prices[marketId] = config.WAD - loss.divWadDown(total_supply);\n      }\n    }\n\n    deactivateMarket(marketId, atLoss, !premature); \n  }\n\n  mapping(address=> uint8) queuedRepUpdates; \n\n  /// @notice trader will redeem entire balance of ZCB\n  /// Needs to be called at maturity, market needs to be resolved first(from controller)\n  function redeem(\n    uint256 marketId\n  ) public _lock_ returns(uint256){\n    require(!marketActive(marketId), \"Market Active\"); \n    require(restriction_data[marketId].resolved, \"Market not resolved\"); \n    require(!redeemed[marketId][msg.sender], \"Already Redeemed\");\n    redeemed[marketId][msg.sender] = true; \n\n    if (isValidator(marketId, msg.sender)) delete validator_data[marketId].sales[msg.sender]; \n\n    //BondingCurve zcb = BondingCurve(address(controller.getZCB(marketId)));\n    BondingCurve zcb = markets[marketId].long;\n\n    assert(controller.getVault(marketId).balanceOf(address(zcb))==0);\n\n    uint256 zcb_redeem_amount = zcb.balanceOf(msg.sender); \n    zcb.trustedBurn(msg.sender, zcb_redeem_amount); \n\n    uint256 redemption_price = get_redemption_price(marketId); \n    uint256 collateral_redeem_amount = redemption_price.mulWadDown(zcb_redeem_amount); \n\n    if (!isValidator(marketId, msg.sender)) {\n      bool increment = redemption_price >= config.WAD? true: false;\n      controller.updateReputation(marketId, msg.sender, increment);\n      // queuedRepUpdates[msg.sender] -=1; \n    }\n\n    // Give out rewards only if reputation update debt is 0\n    if (queuedRepUpdates[msg.sender] == 0) controller.redeem_transfer(collateral_redeem_amount, msg.sender, marketId); \n\n    return collateral_redeem_amount; \n\n  }\n}\n\n\n"
    },
    "contracts/protocol/reputationtoken.sol": {
      "content": "pragma solidity ^0.8.4; \n//https://github.com/poap-xyz/poap-contracts/tree/master/contracts\nimport {ERC721} from \"solmate/src/tokens/ERC721.sol\";\nimport {Controller} from \"./controller.sol\";\nimport {BondingCurve} from \"../bonds/bondingcurve.sol\";\nimport \"hardhat/console.sol\";\n\n\n\ncontract ReputationNFT is ERC721 {\n  mapping(uint256 => ReputationData) internal _reputation; // id to reputation\n  mapping(address => uint256) internal _ownerToId;\n  mapping(uint256 => TraderData[]) internal _marketData; // **MarketId to Market's data needed for calculating brier score.\n\n  uint256 private nonce = 1;\n  Controller controller;\n  uint256 SCALE = 1e18;\n\n\n  struct ReputationData {\n    uint256 n; // number of markets participated in => regular uint256\n    uint256 score; // averaged reputation score => 60.18\n  }\n\n  struct TraderData { // for each market\n    address trader;\n    uint256 tokensBought;\n  }\n\n    struct TopReputation{\n    address trader; \n    uint256 score; \n  }\n\n  uint256 private constant topRep = 100; \n  TopReputation[topRep] topReputations; \n\n  mapping(uint256=>mapping(address=>bool)) canTrade; //marketID-> address-> cantrade\n  mapping(uint256=>bool) allowAll; \n  mapping(address=>bool) isUnique; \n  address[] unique_traders; \n  mapping(uint256=>mapping(address=>uint256)) public balances; // marketId => market manager address => how much collateral already bought.\n\n  modifier onlyController() {\n    require(msg.sender == address(controller));\n    _;\n  }\n\n  constructor (\n    address _controller\n  ) ERC721(\"Debita Reputation Token\", \"DRT\") {\n    controller = Controller(_controller);\n  }\n\n  /**\n   @notice incrementBalance\n   */\n  function incrementBalance(uint256 marketId, address trader, uint256 amount) external onlyController {\n    balances[marketId][trader] += amount;\n  }\n\n  /**\n   @notice called post reputation update\n   */\n  function removeBalance(uint256 marketId, address trader) external onlyController {\n    delete balances[marketId][trader];\n  }\n\n  function _baseURI() internal pure returns (string memory baseURI) {\n    baseURI = \"\";\n  }\n\n  function tokenURI(uint256 id) public view override returns (string memory) {\n    require(_ownerOf[id] != address(0), \"Invalid Identifier\");\n\n    string memory baseURI = _baseURI();\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id)) : \"\";\n  }\n\n  function mint(address to) external {\n    require(_ownerToId[to] == uint256(0), \"can only mint one reputation token\");\n    super._mint(to, nonce);\n    _ownerToId[to] = nonce;\n\n    // Set default score, if this goes to 0 cannot trade\n    _reputation[_ownerToId[to]].score = 1e18; \n\n    nonce++;\n  }\n\n  function getReputationScore(address owner) view external returns (uint256){\n    require(_ownerToId[owner] != uint256(0), \"No Id found\");\n    return _reputation[_ownerToId[owner]].score;\n  }\n\n  /**\n   @notice add scores and stores topX \n   @param score: 60.18 format\n   */\n  function addScore(address to, uint256 score) external onlyController\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    data.score = data.score + score; \n\n    storeTopX(data.score, to); \n  }\n\n  function decrementScore(address to, uint256 score) external onlyController\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    if (data.score <= score) data.score = 0; \n    else data.score = data.score - score; \n\n    storeTopX(data.score, to); \n  }\n\n  /**\n   @notice calculates average of scores added.\n   @param score: 60.18 format\n   */\n  function addAverageScore(address to, uint256 score) external onlyController\n\n   {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n\n    ReputationData storage data = _reputation[_ownerToId[to]];\n    \n    if (data.n == 0) {\n      data.score = score;\n    } else {\n      data.score = (data.score / data.n + score) / (data.n + 1);\n    }\n\n    data.n++;\n  }\n\n  /**\n   @notice reset scores\n   */\n  function resetScore(address to) external {\n    require(_ownerToId[to] != uint256(0), \"No Id found\");\n    delete _reputation[_ownerToId[to]];\n  }\n\n  /// @notice called by controller when initiating market,\n  function storeTopReputation(uint256 topX, uint256 marketId) external onlyController{\n    if (getAvailableTopX() < topX) {\n      allowAll[marketId] =true; \n      return; \n    }\n\n    for (uint256 i; i<topX; i++){\n      canTrade[marketId][topReputations[i].trader] = true;\n    }\n\n  }\n\n  /// @notice gets the x's ranked score from all reputation scores \n  /// @dev returns 0 if topX is greater then avaiable nonzero rep scores-> everyone is allowed\n  /// during reputation constraint periods \n  function getMinRepScore(uint256 topX, uint256 marketId) public view returns(uint256){\n    if (getAvailableTopX() < topX) {\n      return 0; \n    }\n    return topReputations[topX].score; \n\n  }\n\n  function getAvailableTopX() public view returns(uint256){\n    return unique_traders.length; \n  }\n\n  function getAvailableTraderNum() public view returns(uint256){\n    return nonce -1; \n  }\n\n  /// @notice whether trader is above reputation threshold \n  function traderCanTrade(uint256 marketId, address trader) external returns(bool){\n    return allowAll[marketId]? true : canTrade[marketId][trader]; \n  }\n\n  /// @notice called whenever a score is incremented   \n  function storeTopX(uint256 score, address trader) internal {\n    uint256 i = 0;\n\n    for(i; i < topReputations.length; i++) {\n        if(topReputations[i].score < score) {\n            break;\n        }\n    }\n    // shifting the array of position (getting rid of the last element) \n    for(uint j = topReputations.length - 1; j > i; j--) {\n        topReputations[j].score = topReputations[j - 1].score;\n        topReputations[j].trader = topReputations[j - 1].trader;\n    }\n    // update the new max element \n    topReputations[i].score = score;\n    topReputations[i].trader = trader;\n\n    if (isUnique[trader]) return; \n    isUnique[trader] = true; \n    unique_traders.push(trader);\n\n  }\n\n\n \n\n  function testStore() public view {\n    for (uint i=0; i<10; i++){\n      console.log('score', topReputations[i].score); \n    }\n  }\n\n  \n}"
    },
    "contracts/bonds/LinearBondingCurve.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {BondingCurve} from \"./bondingcurve.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport \"hardhat/console.sol\";\nimport {config} from \"../protocol/helpers.sol\"; \n\n/// @notice y = a * x + b\n/// @dev all computations are done in WAD space, any conversion if needed should be made in the parent contract  \n\ncontract LinearBondingCurve is BondingCurve {\n  // ASSUMES 18 TRAILING DECIMALS IN UINT256\n  using FixedPointMathLib for uint256;\n  uint256  a;\n  uint256  b;\n  uint256  discount_cap; // maximum number of tokens for \n  uint256  b_initial; // b without discount cap \n\n  modifier _WAD_(uint256 amount) {\n      require(config.isInWad(amount), \"Not in wad or below minimum amount\"); \n      _;\n  }\n\n  /// @param sigma is the proportion of P that is going to be bought at a discount\n  /// param p,i,sigma all should be in WAD   \n  constructor (\n      string memory name,\n      string memory symbol,\n      address owner,\n      address collateral, \n      uint256 P, \n      uint256 I,\n      uint256 sigma\n  ) BondingCurve(name, symbol, owner, collateral)_WAD_(P)  {\n    _calculateInitCurveParams(P, I, sigma); \n  }\n\n  /// @notice need to calculate initial curve params that takes into account\n  /// validator rewards(from discounted zcb). Just skew up the initial price. \n  /// @param sigma is the proportion of P that is going to be bought at a discount  \n  function _calculateInitCurveParams(uint256 P, uint256 I, uint256 sigma) internal virtual _WAD_(P) returns(uint256) {\n\n    b = (2*P).divWadDown(P+I) - math_precision; \n    a = (math_precision-b).divWadDown(P+I); \n\n    // Calculate and store maximum tokens for discounts, \n    discount_cap = _calculatePurchaseReturn(P.mulWadDown(sigma));\n\n    //get new initial price after saving for discounts \n    b = a.mulWadDown(discount_cap) + b;\n\n    b_initial = (2*P).divWadDown(P+I) - math_precision; \n\n  }\n  /**\n   @dev tokens returned = [((a*s + b)^2 + 2*a*p)^(1/2) - (a*s + b)] / a\n   @param amount: amount collateral in => needs to be converted to WAD before \n   tokens returned in WAD\n   */\n  function _calculatePurchaseReturn(uint256 amount)  internal view override virtual _WAD_(amount) returns(uint256) {\n    uint256 s = totalSupplyAdjusted() ;\n\n    uint256 x = ((a.mulWadDown(s) + b) ** 2)/math_precision; \n    uint256 y = 2*( a.mulWadDown(amount)); \n    uint256 x_y_sqrt = ((x+y)*math_precision).sqrt();\n    uint256 z = (a.mulWadDown(s) + b); \n    uint256 result = (x_y_sqrt-z).divWadDown(a);\n\n    return result;\n  }\n\n\n  /**\n   @notice calculates area under curve from s-amount to s, is c(as-ac/2+b) where c is amount \n   @dev collateral tokens returned\n   @param amount: amount of tokens burnt => WAD amount needs to be in 18 decimal \n   @dev returns amount of collateral tokens in WAD\n   */\n  function _calculateSaleReturn(uint256 amount) internal view override virtual _WAD_(amount) returns (uint256) {\n\n    uint s = totalSupplyAdjusted();\n    uint256 x = a.mulWadDown(s); \n    uint256 y = a.mulWadDown(amount)/2; \n    uint256 z = b + x - y; \n    uint256 result = amount.mulWadDown(z); \n\n    return result;\n  }\n\n\n\n  /// @notice calculates area under the curve from current supply to s+amount\n  /// result = a * amount / 2  * (2* supply + amount) + b * amount\n  /// @dev amount is in 60.18.\n  /// returned in collateral decimals\n  function _calcAreaUnderCurve(uint256 amount) internal view override virtual _WAD_(amount) returns(uint256){\n\n    uint256 s = totalSupplyAdjusted(); \n    uint256 result = ( a.mulWadDown(amount) / 2 ).mulWadDown(2 * s + amount) + b.mulWadDown(amount); \n    \n    return result; \n  }\n\n\n  /**\n   @param amount: amount added in 60.18\n   @dev returns price in 60.18\n   */\n  function _calculateExpectedPrice(uint256 amount) internal view  override virtual returns (uint256 result) {\n\n    uint256 s = totalSupplyAdjusted();\n\n    result = (s + amount).mulWadDown(a) + b;\n  }\n\n  function _calculateDecreasedPrice(uint256 amount) view internal override virtual _WAD_(amount) returns (uint256 result) {\n    result = (totalSupplyAdjusted() - amount).mulWadDown(a) + b;\n  }\n\n\n  /// @notice computes from arbitrary supply, from initial b\n  function _calculateArbitraryPurchaseReturn(uint256 amount, uint256 supply)  internal view override virtual _WAD_(amount) returns(uint256) {\n    uint256 s = supply; \n\n    uint256 x = ((a.mulWadDown(s) + b_initial) ** 2)/math_precision; \n    uint256 y = 2*( a.mulWadDown(amount)); \n    uint256 x_y_sqrt = ((x+y)*math_precision).sqrt();\n    uint256 z = (a.mulWadDown(s) + b_initial); \n    uint256 result = (x_y_sqrt-z).divWadDown(a);\n\n    return result;\n  }\n\n\n  function _calculateScore(uint256 priceOut, bool atLoss)view internal override virtual returns (uint256 score) {\n    if (atLoss) {\n      score = ((priceOut - math_precision) ** 2) / math_precision;\n    } else {\n      score = (priceOut ** 2) / math_precision;\n    }\n  }\n\n  function _get_discount_cap() internal view virtual override returns(uint){\n    return discount_cap; \n  }\n\n  function _getParams() public view override returns(uint,uint){\n    return (a,b); \n  }\n\n\n\n\n\n\n}"
    },
    "contracts/bonds/LinearBondingCurveFactory.sol": {
      "content": "pragma solidity ^0.8.4;\nimport {OwnedERC20} from \"../turbo/OwnedShareToken.sol\";\nimport {LinearBondingCurve} from \"./LinearBondingCurve.sol\"; \nimport {LinearShortZCB, ShortBondingCurve} from \"./LinearShortZCB.sol\"; \nimport {BondingCurve} from \"./bondingcurve.sol\";\n\n/// @notice need to separate factories because of contract size error \ncontract LinearBondingCurveFactory{\n\n  address controller; \n  constructor(){\n    controller = msg.sender; \n  }\n\n  function newLongZCB(\n    string memory name, \n    string memory symbol,\n    address marketmanager_address,\n    address vault_address, \n    uint256 P, \n    uint256 I, \n    uint256 sigma\n    ) external returns(BondingCurve){\n\n    BondingCurve zcb = new LinearBondingCurve(\n      name,\n      symbol,\n      marketmanager_address, // owner\n      vault_address,  \n      P,\n      I,\n      sigma\n    );\n    return zcb;\n  }\n\n  function newShortZCB(\n    string memory name,\n    string memory symbol, \n    address marketmanager_address, \n    address vault_address, \n    address longZCBaddress, \n    uint256 marketId\n    ) external returns (ShortBondingCurve){\n\n    ShortBondingCurve shortZCB = new LinearShortZCB(\n      name, symbol, marketmanager_address, vault_address, longZCBaddress, marketId\n    ); \n    return shortZCB;\n  }\n\n\n\n\n\n}"
    },
    "contracts/vaults/vault.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {Auth} from \"./auth/Auth.sol\";\nimport {ERC4626} from \"./mixins/ERC4626.sol\";\n\nimport {SafeCastLib} from \"./utils/SafeCastLib.sol\";\nimport {SafeTransferLib} from \"./utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\n\nimport {ERC20} from \"./tokens/ERC20.sol\";\nimport {Instrument} from \"./instrument.sol\";\nimport {Controller} from \"../protocol/controller.sol\";\nimport {MarketManager} from \"../protocol/marketmanager.sol\"; \nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"hardhat/console.sol\";\n\n\ncontract Vault is ERC4626, Auth{\n    using SafeCastLib for uint256; \n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n\n    event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n    event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\n    event InstrumentTrusted(address indexed user, Instrument indexed instrument);\n    event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\n    event InstrumentHarvest(address indexed instrument, uint256 instrument_balance, uint256 mag, bool sign); //sign is direction of mag, + or -.\n\n    /*///////////////////////////////////////////////////////////////\n                                 CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal BASE_UNIT;\n    uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments collateral\n    ERC20 public immutable UNDERLYING;\n    Controller private controller;\n    MarketManager.MarketParameters default_params; \n\n    ///// For Factory\n    bool public onlyVerified; \n    uint256 public r; //reputation ranking  \n    uint256 public asset_limit; \n    uint256 public total_asset_limit; \n\n    mapping(Instrument => InstrumentData) public instrument_data;\n    mapping(address => uint256) public  num_proposals;\n    mapping(uint256=> Instrument) public Instruments; //marketID-> Instrument\n    mapping(uint256 => bool) resolveBeforeMaturity;\n    mapping(uint256=>ResolveVar) prepareResolveBlock; \n\n    enum InstrumentType {\n        CreditLine,\n        Other\n    }\n\n    /// @param trusted Whether the Instrument is trusted.\n    /// @param balance The amount of underlying tokens held in the Instrument.\n    struct InstrumentData {\n        // Used to determine if the Vault will operate on a Instrument.\n        bool trusted;\n        // Balance of the contract denominated in Underlying, \n        // used to determine profit and loss during harvests of the Instrument.  \n        // represents the amount of debt the Instrument has incurred from this vault   \n        uint256 balance; // in underlying\n        uint256 faceValue; // in underlying\n        uint256 marketId;\n        uint256 principal; //this is total available allowance in underlying\n        uint256 expectedYield; // total interest paid over duration in underlying\n        uint256 duration;\n        string description;\n        address Instrument_address;\n        InstrumentType instrument_type;\n        uint256 maturityDate;\n    }\n\n    struct ResolveVar{\n        uint256 endBlock; \n        bool isPrepared; \n    }\n\n    constructor(\n        address _UNDERLYING,\n        address _controller, \n        address owner, \n\n        bool _onlyVerified, //\n        uint256 _r, //reputation ranking\n        uint256 _asset_limit, \n        uint256 _total_asset_limit,\n\n        MarketManager.MarketParameters memory _default_params\n\n    )\n        ERC4626(\n            ERC20(_UNDERLYING),\n            string(abi.encodePacked(\"debita \", ERC20(_UNDERLYING).name(), \" Vault\")),\n            string(abi.encodePacked(\"db\", ERC20(_UNDERLYING).symbol()))\n        )  Auth(owner)\n\n    {\n        UNDERLYING = ERC20(_UNDERLYING);\n        //BASE_UNIT = 10**ERC20(_UNDERLYING).decimals();\n        BASE_UNIT = 10**18; \n        controller = Controller(_controller);\n        set_minting_conditions( _onlyVerified,  _r, _asset_limit, _total_asset_limit); \n        default_params = _default_params; \n        //totalSupply = type(uint256).max;\n    }\n\n    function getInstrumentData(Instrument _instrument) public view returns (InstrumentData memory) {\n        return instrument_data[_instrument];\n    }\n    \n    modifier onlyController(){\n        require(address(controller) == msg.sender || msg.sender == owner || address(this) == msg.sender ,  \"is not controller\"); \n        _;\n    }\n\n    /// @notice called by controller at maturity \n    function controller_burn(uint256 amount, address bc_address) external onlyController {\n        _burn(bc_address,amount); \n    }\n    /// @notice called by controller at maturity, since redeem amount > balance in bc\n    function controller_mint(uint256 amount, address to) external onlyController {\n        _mint(to , amount); \n    }\n    /// @notice amount is always in WAD, so need to convert if decimals mismatch\n    function trusted_transfer(uint256 amount, address to) external onlyController{\n        if (decimal_mismatch) amount = decSharesToAssets(amount); \n        UNDERLYING.transfer(to, amount); \n    }\n\n    function balanceInUnderlying(address ad) external view returns(uint256){\n        return previewRedeem(balanceOf[ad]); \n    }\n\n    /// @notice burns all balance of address \n    function burnAll(address to) private{\n      _burn(to, balanceOf[to]); \n    }\n\n    /// @notice Harvest a trusted Instrument, records profit/loss \n    function harvest(address instrument) public {\n        require(instrument_data[Instrument(instrument)].trusted, \"UNTRUSTED_Instrument\");\n        InstrumentData storage data = instrument_data[Instrument(instrument)]; \n\n        uint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \n        \n        uint256 balanceLastHarvest = data.balance;\n        \n        uint256 balanceThisHarvest = Instrument(instrument).balanceOfUnderlying(address(instrument));\n        \n        if (balanceLastHarvest == balanceThisHarvest) {\n            return;\n        }\n        \n        data.balance = balanceThisHarvest;\n\n        uint256 delta;\n       \n        bool net_positive = balanceThisHarvest >= balanceLastHarvest;\n        \n        delta = net_positive ? balanceThisHarvest - balanceLastHarvest : balanceLastHarvest - balanceThisHarvest;\n\n        totalInstrumentHoldings = net_positive ? oldTotalInstrumentHoldings + delta : oldTotalInstrumentHoldings - delta;\n\n        emit InstrumentHarvest(instrument, balanceThisHarvest, delta, net_positive);\n    }\n\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\n    /// Called when market is approved. \n    /// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \n    function depositIntoInstrument(uint256 marketId, uint256 underlyingAmount) internal{\n      Instrument instrument = fetchInstrument(marketId); \n      require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n\n      if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \n      console.log('deposit amount and current balance', underlyingAmount, UNDERLYING.balanceOf(address(this)));\n\n      totalInstrumentHoldings += underlyingAmount; \n\n      instrument_data[instrument].balance += underlyingAmount;\n\n      require(UNDERLYING.transfer(address(instrument), underlyingAmount), \"DEPOSIT_FAILED\");\n\n      emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\n    }\n\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\n    function withdrawFromInstrument(Instrument instrument, uint256 underlyingAmount) internal {\n      require(instrument_data[instrument].trusted, \"UNTRUSTED Instrument\");\n      \n      if (decimal_mismatch) underlyingAmount = decSharesToAssets(underlyingAmount); \n\n      instrument_data[instrument].balance -= underlyingAmount;\n      \n      totalInstrumentHoldings -= underlyingAmount;\n      \n      require(instrument.redeemUnderlying(underlyingAmount), \"REDEEM_FAILED\");\n      \n      emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\n\n    }\n\n    /// @notice Stores a Instrument as trusted when its approved\n    function trustInstrument(uint256 marketId, Controller.ApprovalData memory data) external onlyController{\n      instrument_data[fetchInstrument(marketId)].trusted = true;\n\n      //Write to storage \n      instrument_data[Instruments[marketId]].principal = data.approved_principal; \n      instrument_data[Instruments[marketId]].expectedYield = data.approved_yield;\n      instrument_data[Instruments[marketId]].faceValue = data.approved_principal + data.approved_yield; \n\n      depositIntoInstrument(marketId, data.approved_principal);\n    \n      setMaturityDate(marketId);\n\n      fetchInstrument(marketId).onMarketApproval(data.approved_principal, data.approved_yield); \n    }\n\n    /// @notice Stores a Instrument as untrusted\n    function distrustInstrument(Instrument instrument) external onlyController {\n      instrument_data[instrument].trusted = false; \n    }\n\n\n    /// @notice returns true if Instrument is approved\n    function isTrusted(Instrument instrument) public view returns(bool){\n      return instrument_data[instrument].trusted; \n    }\n\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \n    function totalAssets() public view override returns(uint256){\n      return totalInstrumentHoldings + totalFloat();\n    }\n\n    function utilizationRate() public view returns(uint256){\n\n        if (totalInstrumentHoldings==0) return 0;  \n        return totalInstrumentHoldings.divWadDown(totalAssets()); \n\n    }\n    function totalFloat() public view returns (uint256) {\n        return UNDERLYING.balanceOf(address(this));\n    }\n\n    function fetchInstrument(uint256 marketId) public view returns(Instrument){\n      return Instruments[marketId]; \n    }\n\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\n        return instrument_data[Instruments[marketId]];\n    }\n    /**\n     called on market denial + removal, maybe no chekcs?\n     */\n    function removeInstrument(uint256 marketId) internal {\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\n        require(data.marketId > 0, \"instrument doesn't exist\");\n        delete instrument_data[Instruments[marketId]];\n        delete Instruments[marketId];\n        // emit event here;\n    }\n\n\n\n    /// @notice add instrument proposal created by the Utilizer \n    /// @dev Instrument instance should be created before this is called\n    /// need to add authorization\n    function addProposal(\n        InstrumentData memory data\n    ) external onlyController {\n        require(data.principal > 0, \"principal must be greater than 0\");\n        require(data.duration > 0, \"duration must be greater than 0\");\n        require(data.faceValue > 0, \"faceValue must be greater than 0\");\n        require(data.principal >= BASE_UNIT, \"Needs to be in decimal format\"); \n        require(data.marketId > 0, \"must be valid instrument\");\n\n        num_proposals[msg.sender] ++; \n        instrument_data[Instrument(data.Instrument_address)] = (\n          InstrumentData(\n            false, \n                0, \n                data.faceValue, \n                data.marketId, \n                data.principal, \n                data.expectedYield, \n                data.duration, \n                data.description, \n                data.Instrument_address,\n                data.instrument_type,\n                0\n            )\n        ); \n\n        Instruments[data.marketId] = Instrument(data.Instrument_address);\n        assert(data.marketId !=0); \n    }\n\n    /**\n     @notice called by controller on approveMarket.\n     */\n    function setMaturityDate(uint256 marketId) internal {\n\n        instrument_data[fetchInstrument(marketId)].maturityDate = instrument_data[fetchInstrument(marketId)].duration + block.timestamp;\n    }\n\n    /// @notice function called when instrument resolves from within\n    function pingMaturity(address instrument, bool premature) external {\n        require(msg.sender == instrument || isTrusted(Instrument(instrument))); \n        uint256 marketId = instrument_data[Instrument(instrument)].marketId; \n        beforeResolve(marketId); \n        resolveBeforeMaturity[marketId] = premature; \n    }\n\n\n    /// @notice RESOLVE FUNCTION #1\n    /// Checks if instrument is ready to be resolved and locks capital.\n    /// records blocknumber such that resolveInstrument is called after this function \n    /// records balances+PnL of instrument\n    /// @dev need to store internal balance that is used to calculate the redemption price \n    function beforeResolve(uint256 marketId) public {\n\n        Instrument _instrument = Instruments[marketId]; \n\n        require(msg.sender == address(_instrument) || msg.sender == address(controller), \"Not allowed\"); \n        require(isTrusted( _instrument), \"Not trusted\"); \n\n        _instrument.prepareWithdraw(); \n\n        // Record profit/loss used for calculation of redemption price \n        harvest(address(_instrument));\n\n        _instrument.store_internal_balance(); \n        console.log('maturitybal', _instrument.getMaturityBalance()); \n        prepareResolveBlock[marketId] = ResolveVar(block.number,true) ;  \n      }\n\n    /// @notice RESOLVE FUNCTION #2\n    /// @dev In cases of default, needs to be called AFTER the principal recouperation attempts \n    /// like liquidations, auctions, etc such that the redemption price takes into account the maturity balance\n    function resolveInstrument(\n        uint256 marketId\n    ) external onlyController\n    returns(bool, uint256, uint256, bool) {\n        Instrument _instrument = Instruments[marketId];\n        require(_instrument.isLocked(), \"Not Locked\");\n        // require( prepareResolveBlock[marketId].isPrepared && prepareResolveBlock[marketId].endBlock < block.number,\n        //  \"Wait before resolve\"); \n\n        uint256 bal = UNDERLYING.balanceOf(address(this)); \n        uint256 instrument_balance = _instrument.getMaturityBalance(); \n\n        InstrumentData storage data = instrument_data[_instrument];\n\n        bool prematureResolve = resolveBeforeMaturity[marketId]; \n        bool atLoss; \n        uint256 total_loss; \n        uint256 extra_gain; \n\n        // If resolved at predetermined maturity date, loss is defined by\n        // the event the instrument has paid out all its yield + principal \n        if (!prematureResolve){\n            atLoss = instrument_balance < data.faceValue;\n\n            total_loss = atLoss ? data.faceValue - instrument_balance : 0;\n            extra_gain = !atLoss ? instrument_balance - data.faceValue : 0;\n        }\n\n        // If resolved before predetermined maturity date, loss is defined by \n        // the event the instrument has balance less then principal \n        else {\n            atLoss = instrument_balance < data.principal; \n\n            total_loss = atLoss? data.principal - instrument_balance :0; \n            extra_gain = 0; \n        }\n\n        withdrawFromInstrument(_instrument, instrument_balance);\n\n        console.log('balance increase', bal, UNDERLYING.balanceOf(address(this))); \n        console.log('balance increase', data.balance, data.principal); \n        removeInstrument(data.marketId);\n\n        return(atLoss, extra_gain, total_loss, prematureResolve); \n    }\n\n    /// @notice when market resolves, send back pulled collateral from managers \n    function repayDebt(address to, uint256 amount) external onlyController{\n        UNDERLYING.transfer(to, amount); \n    }\n\n    /**\n     called on market denial by controller.\n     */\n    function denyInstrument(uint256 marketId) external onlyController {\n        InstrumentData storage data = instrument_data[Instruments[marketId]];\n\n        require(marketId > 0 && data.Instrument_address != address(0), \"invalid instrument\");\n\n        require(!data.trusted, \"can't deny approved instrument\");\n        \n        removeInstrument(marketId);\n    }\n\n\n    function instrumentApprovalCondition(uint256 marketId) external view returns(bool){\n      return Instruments[marketId].instrumentApprovalCondition(); \n    }\n\n\n    /// TODO \n    function deduct_withdrawal_fees(uint256 amount) internal returns(uint256){\n      return amount; \n    }\n\n\n    /// @notice types of restrictions are: \n    /// a) verified address b) reputation scores \n    function receiver_conditions(address receiver) public view returns(bool){\n        return true; \n    }\n\n    /// @notice called when constructed, params set by the creater of the vault \n    function set_minting_conditions(\n      bool _onlyVerified, \n      uint256 _r, \n      uint256 _asset_limit,\n      uint256 _total_asset_limit) internal{\n        onlyVerified = _onlyVerified; \n        r = _r; \n        asset_limit = _asset_limit; \n        total_asset_limit = _total_asset_limit; \n    } \n\n\n    function get_vault_params() public view returns(MarketManager.MarketParameters memory){\n      return default_params; \n    }\n\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual override {\n      require(enoughLiqudity(assets), \"Not enough liqudity in vault\"); \n\n    }\n\n    /// @notice returns true if the vault has enough balance to withdraw or supply to new instrument\n    /// (excluding those supplied to existing instruments)\n    /// @dev for now this implies that the vault allows full utilization ratio, but the utilization ratio\n    /// should be (soft)maxed and tunable by a parameter \n    function enoughLiqudity(uint256 amounts) public view returns(bool){\n        return (UNDERLYING.balanceOf(address(this)) >= amounts); \n    }\n\n\n    /// @notice function that closes instrument prematurely \n    function closeInstrument(uint256 marketId) external onlyController{\n      Instrument instrument = fetchInstrument( marketId); \n\n      // If instrument has non-underlying tokens, liquidate them first. \n      instrument.liquidateAllPositions(); \n\n    }\n\n    function viewPrincipalAndYield(uint256 marketId) public view returns(uint256,uint256){\n        InstrumentData memory data = instrument_data[Instruments[marketId]];\n        return (data.principal, data.expectedYield); \n    }\n\n    /// @notice a minting restrictor is set for different vaults \n    function mint(uint256 shares, address receiver) public virtual override returns (uint256 assets) {\n        if (!receiver_conditions(receiver)) revert(\"Minting Restricted\"); \n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n   \n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n\n    /// @notice apply fee before withdrawing to prevent just minting before maturities and withdrawing after \n     function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        assets = deduct_withdrawal_fees(assets); \n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n\n\n//deprecated\n    /// @notice RESOLVE FUNCTION #1\n    /// checks if instrument is ready to be resolved\n    /// and locks capital inside the instrument \n    /// @dev resolving is separated into three tx \n    /// prepareResolve->beforeResolve->resolveinstrument\n    function prepareResolve(uint256 marketId) public {\n        Instrument _instrument = Instruments[marketId]; \n\n        require(msg.sender == address(_instrument) || msg.sender == address(controller), \"Not allowed\"); \n        require(isTrusted( _instrument), \"Not trusted\"); \n\n        // This will check if instrument is ready to be resolved (i.e all debts payed, investments liquidated, etc)\n        // and lock further drawdowns or usage of capital \n        _instrument.prepareWithdraw(); \n    }\n\n}"
    },
    "contracts/vaults/instrument.sol": {
      "content": "\n// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.4;\n\nimport \"./vault.sol\";\nimport {ERC20} from \"./tokens/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {FixedPointMathLib} from \"./utils/FixedPointMathLib.sol\";\nimport \"hardhat/console.sol\";\n\n\n/// @notice Minimal interface for Vault compatible strategies.\nabstract contract Instrument {\n\n    modifier onlyUtilizer() {\n        require(msg.sender == Utilizer, \"!Utilizer\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        require(msg.sender == vault.owner() || isValidator[msg.sender], \"!authorized\");\n        _;\n    }\n\n    modifier onlyVault() {\n        require(msg.sender == address(vault), \"caller must be vault\");\n        _;\n    }\n\n    modifier notLocked() {\n        require(!locked); \n        _; \n    }\n\n    constructor (\n        address _vault,\n        address _Utilizer\n    ) {\n        vault = Vault(_vault);\n        underlying = ERC20(vault.UNDERLYING());\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \n        Utilizer = _Utilizer;\n    }\n\n\n    ERC20 public underlying;\n    Vault public vault; \n    bool locked; \n    uint256 private constant MAX_UINT = 2**256 - 1;\n    uint256 private maturity_balance; \n\n    /// @notice address of user who submits the liquidity proposal \n    address public Utilizer; \n    address[] public validators; //set when deployed, but can't be ch\n    mapping(address=>bool) isValidator; \n\n    /**\n     @notice hooks for approval logic that are specific to each instrument type, called by controller for approval/default logic\n     */\n    function onMarketApproval(uint256 principal, uint256 yield) virtual external {}\n\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\n        require(_Utilizer != address(0));\n        Utilizer = _Utilizer;\n    }\n\n    function setValidator(address _validator) external {\n        require(msg.sender == vault.owner(), \"Not owner\"); \n        validators.push(_validator); \n        isValidator[_validator] = true;     \n    }\n\n\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\n    /// @param amount The amount of underlying tokens to withdraw.\n    /// @return An error code, or 0 if the withdrawal was successful.\n    function redeemUnderlying(uint256 amount) external onlyVault returns (bool){\n        return underlying.transfer(address(vault), amount); \n    }\n\n    /// @notice Returns a user's Instrument balance in underlying tokens.\n    /// @param user The user to get the underlying balance of.\n    /// @return The user's Instrument balance in underlying tokens.\n    /// @dev May mutate the state of the Instrument by accruing interest.\n    function balanceOfUnderlying(address user) public view returns (uint256){\n        return underlying.balanceOf(user); \n        }\n\n\n    /**\n     * @notice\n     *  Provide an accurate estimate for the total amount of assets\n     *  (principle + return) that this Instrument is currently managing,\n     *  denominated in terms of Underlying tokens.\n     *\n     *  This total should be \"realizable\" e.g. the total value that could\n     *  *actually* be obtained from this Instrument if it were to divest its\n     *  entire position based on current on-chain conditions.\n     * @dev\n     *  Care must be taken in using this function, since it relies on external\n     *  systems, which could be manipulated by the attacker to give an inflated\n     *  (or reduced) value produced by this function, based on current on-chain\n     *  conditions (e.g. this function is possible to influence through\n     *  flashloan attacks, oracle manipulations, or other DeFi attack\n     *  mechanisms).\n     *\n     *  It is up to governance to use this function to correctly order this\n     *  Instrument relative to its peers in the withdrawal queue to minimize\n     *  losses for the Vault based on sudden withdrawals. This value should be\n     *  higher than the total debt of the Instrument and higher than its expected\n     *  value to be \"safe\".\n     *  Estimated Total assets should be \n\n     * @return The estimated total assets in this Strategy.\n     */\n    function estimatedTotalAssets() public view virtual returns (uint256){}\n\n    /**\n     * Free up returns for vault to pull\n     * Perform any Instrument divesting + unwinding or other calls necessary to capture the\n     * \"free return\" this Instrument has generated since the last time its core\n     * position(s) were adjusted. Examples include unwrapping extra rewards.\n     * This call is only used during \"normal operation\" of a Instrument, and\n     * should be optimized to minimize losses as much as possible.\n     *\n     * This method returns any realized profits and/or realized losses\n     * incurred, and should return the total amounts of profits/losses/debt\n     * payments (in `underlying` tokens) for the Vault's accounting (e.g.\n     * `underlying.balanceOf(this) >= principal + profit`).\n     *\n     * param _debtPayment is the total amount expected to be returned to the vault\n     */\n\n    /// @notice checks if the instrument is ready to be withdrawed, i.e all \n    /// loans have been paid, all non-underlying have been liquidated, etc\n    function readyForWithdrawal() public view virtual returns(bool){\n        return true; \n    }\n\n    /// @notice checks whether the vault can withdraw and record profit from this instrument \n    /// for this instrument to resolve \n    /// For creditlines, all debts should be repaid\n    /// for strategies, all assets should be divested + converted to Underlying\n    /// this function is important in preventing manipulations, \n    /// @dev prepareWithdraw->vault.beforeResolve->vault.resolveInstrument in separate txs\n    function prepareWithdraw()\n        external \n        onlyVault \n        virtual\n        returns (\n            uint256 _profit,\n            uint256 _loss,\n            uint256 _debtPayment\n        ){\n            require(readyForWithdrawal()); \n\n            // Lock additional drawdowns or usage of instrument balance \n            lockLiquidityFlow();    \n\n        }\n\n    /**\n     * Liquidate up to `_amountNeeded` of `underlying` of this strategy's positions,\n     * irregardless of slippage. Any excess will be re-invested with `adjustPosition()`.\n     * This function should return the amount of `underlying` tokens made available by the\n     * liquidation. If there is a difference between them, `_loss` indicates whether the\n     * difference is due to a realized loss, or if there is some other sitution at play\n     * (e.g. locked funds) where the amount made available is less than what is needed.\n     *\n     * NOTE: The invariant `_liquidatedAmount + _loss <= _amountNeeded` should always be maintained\n     */\n    function liquidatePosition(uint256 _amountNeeded) public  virtual returns (uint256 _liquidatedAmount, uint256 _loss){}\n\n    /**\n     * Liquidate everything and returns the amount that got freed.\n     * This function is used during emergency exit instead of `prepareReturn()` to\n     * liquidate all of the instrument's positions back to the Vault.\n     */\n    function liquidateAllPositions() public  virtual returns (uint256 _amountFreed){}\n\n    function lockLiquidityFlow() internal{\n        locked = true; \n    }\n\n    function isLocked() public view returns(bool){\n        return locked; \n    }\n\n\n    function transfer_liq(address to, uint256 amount) internal notLocked {\n        if (vault.decimal_mismatch()) amount = vault.decSharesToAssets(amount); \n        underlying.transfer(to, amount);\n    }\n\n    function transfer_liq_from(address from, address to, uint256 amount) internal notLocked {\n        if (vault.decimal_mismatch()) amount = vault.decSharesToAssets(amount); \n        underlying.transferFrom(from, to, amount);\n\n    }\n\n    /// @notice called before resolve, to avoid calculating redemption price based on manipulations \n    function store_internal_balance() external onlyVault{\n\n        maturity_balance = balanceOfUnderlying(address(this)); \n        if (vault.decimal_mismatch()) maturity_balance = vault.decAssetsToShares(maturity_balance); \n\n    }\n\n    function getMaturityBalance() public view returns(uint256){\n        return maturity_balance; \n    }\n\n\n    /// @notice Before supplying liquidity from the vault to this instrument,\n    /// which is done automatically when instrument is trusted, \n    /// need to check if certain conditions that are required to this specific \n    /// instrument is met. For example, for a creditline with a collateral \n    /// requirement need to check if this address has the specific amount of collateral\n    /// @dev called to be checked at the approve phase from controller  \n    function instrumentApprovalCondition() public virtual view returns(bool); \n\n\n\n}\n\n\n// contract RevenueToken is ERC20{\n\n// }\n\n \n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\n/// approved borrowers will interact with this contract to borrow, repay. \n/// and vault will supply principal and harvest principal/interest \ncontract CreditLine is Instrument {\n    using FixedPointMathLib for uint256;\n    address public immutable borrower; \n\n    //  variables initiated at creation\n    uint256 principal;\n    uint256 notionalInterest; \n    uint256 faceValue; //total amount due, i.e principal+interest\n    uint256 duration; // normalized to a year 1 means 1 year, 0.5 means 6 month \n    uint256 interestAPR; \n\n    // Modify-able Global Variables during repayments, borrow\n    uint256 totalOwed; \n    uint256 principalOwed; \n    uint256 interestOwed;\n    uint256 accumulated_interest; \n    uint256 principalRepayed;\n    uint256 interestRepayed; \n\n    // Collateral Info \n    enum CollateralType{\n        liquidateAble, \n        nonLiquid, \n        ownership \n    }\n    address public collateral; \n    address public oracle; \n    uint256 public collateral_balance; \n    CollateralType public collateral_type; \n\n    uint256 drawdown_block; \n    bool didDrawdown; \n\n    uint256 gracePeriod; \n    uint256 resolveBlock; \n    uint256 constant DUST = 1e18; //1usd\n\n    enum LoanStatus{\n        notApproved,\n        approvedNotDrawdowned,\n        drawdowned, \n        partially_repayed,\n\n        prepayment_fulfilled, \n        matured, \n        grace_period, \n        isDefault\n    }\n\n    LoanStatus public loanStatus; \n\n    uint256 lastRepaymentTime; \n    uint256 gracePeriodStart; \n    Proxy proxy; \n\n    /// @notice both _collateral and _oracle could be 0\n    /// address if fully uncollateralized or does not have a price oracle \n    /// param _notionalInterest and _principal is initialized as desired variables\n    constructor(\n        address vault,\n        address _borrower, \n        uint256 _principal,\n        uint256 _notionalInterest, \n        uint256 _duration,\n        uint256 _faceValue,\n        address _collateral, //collateral for the dao, could be their own native token or some tokenized revenue \n        address _oracle, // oracle for price of collateral \n        uint256 _collateral_balance, //promised collateral balance\n        uint256 _collateral_type\n    )  Instrument(vault, _borrower) {\n        borrower = _borrower; \n        principal = _principal; \n        notionalInterest = _notionalInterest; \n        duration = _duration;   \n        faceValue = _faceValue;\n\n        collateral = _collateral; \n        oracle = _oracle; \n        collateral_balance = _collateral_balance; \n        collateral_type = CollateralType(_collateral_type); \n\n        loanStatus = LoanStatus.notApproved; \n\n        proxy = new Proxy(address(this), _borrower); \n    }\n\n    function getCurrentTime() internal view returns(uint256){\n        return block.timestamp + 31536000/2; \n    }\n    function getProxy() public view returns(address){\n        return address(proxy); \n    }\n\n    /// @notice checks if the creditline is ready to be withdrawed, i.e all \n    /// loans have been paid, all non-underlying have been liquidated, etc\n    function readyForWithdrawal() public view override returns(bool){\n        if (loanStatus == LoanStatus.matured || loanStatus == LoanStatus.isDefault\n            || loanStatus == LoanStatus.prepayment_fulfilled) return true; \n        return true; \n        //return false  \n    }\n\n    function getApprovedBorrowConditions() public view returns(uint256, uint256){\n        if (vault.isTrusted(this)) return(principal, notionalInterest) ;\n\n        return (0,0); \n    }\n\n    /// @notice if possible, and borrower defaults, liquidates given collateral to underlying\n    /// and push back to vault. If not possible, push the collateral back to\n    function liquidateAndPushToVault() internal  {}\n\n    function auctionAndPushToVault() internal {} \n\n    /// @notice After grace period auction off ownership to some other party and transfer the funds back to vault \n    /// @dev assumes collateral has already been transferred to vault, needs to be checked by the caller \n    function liquidateOwnership(address buyer) public virtual onlyAuthorized{\n        // TODO implement auction \n        proxy.changeOwnership(buyer);\n    }\n\n    /// @notice transfers collateral back to vault when default \n    function pushCollateralToVault(uint256 amount, address to) public virtual onlyAuthorized{\n        require(loanStatus == LoanStatus.isDefault); \n        ERC20(collateral).transfer(to, amount); \n    }\n\n    function isLiquidatable(address collateral) public view returns(bool){}\n\n    /// @notice if collateral is liquidateable and has oracle, fetch value of collateral \n    /// and return ratio to principal \n    function getCollateralRatio() public view returns(uint256){\n\n    }\n\n    /// @notice validators have to check these conditions at a human level too before approving \n    function instrumentApprovalCondition() public override view returns(bool){\n        // check if borrower has correct identity \n\n        // check if enough collateral has been added as agreed   \n        if (collateral_type == CollateralType.liquidateAble || collateral_type == CollateralType.nonLiquid){\n            require(ERC20(collateral).balanceOf(address(this)) >= collateral_balance, \"Insufficient collateral\"); \n        }\n\n        // check if validator(s) are set \n        if (validators.length == 0) {revert(\"No validators\"); }\n\n        // Check if proxy has been given ownership\n        if (collateral_type == CollateralType.ownership && proxy.numContracts() == 0) revert(\"Ownership \"); \n\n        return true; \n    } \n\n    /// @notice borrower deposit promised collateral  \n    function depositCollateral(uint256 amount) external onlyUtilizer {\n        require(collateral!= address(0)); \n        ERC20(collateral).transferFrom(msg.sender, address(this), amount); \n    }\n\n    /// @notice can only redeem collateral when debt is fully paid \n    function releaseAllCollateral() internal {\n        require(loanStatus == LoanStatus.matured || loanStatus == LoanStatus.prepayment_fulfilled, \"Loan status err\"); \n\n        ERC20(collateral).transfer(msg.sender,collateral_balance); \n    }\n\n\n\n    /// @notice should only be called when (portion of) principal is repayed\n    function adjustInterestOwed() internal {\n\n        uint256 remainingDuration = (drawdown_block + toSeconds(duration)) - getCurrentTime();\n        console.log('remainingDuration', remainingDuration);\n        interestOwed = interestAPR.mulWadDown(toYear(remainingDuration).mulWadDown(principalOwed)); \n        console.log('interestOwed should be same', interestOwed); \n    }\n\n    /// @param quoted_yield is in notional amount denominated in underlying, which is the area between curve and 1 at the x-axis point \n    /// where area under curve is max_principal \n    function onMarketApproval(uint256 max_principal, uint256 quoted_yield)  external override onlyVault {\n        principal = max_principal; \n        notionalInterest = quoted_yield; //this accounts for duration as well\n        interestAPR = quoted_yield.divWadDown(duration.mulWadDown(principal)); \n\n        loanStatus = LoanStatus.approvedNotDrawdowned;\n    }\n\n    function onMaturity() external onlyUtilizer {\n        require(loanStatus == LoanStatus.prepayment_fulfilled || loanStatus == LoanStatus.matured,\"Not matured\"); \n        require(block.number > resolveBlock, \"Block equal\"); \n\n        if (collateral_type == CollateralType.liquidateAble || collateral_type == CollateralType.nonLiquid ){\n            releaseAllCollateral(); \n        }\n\n        else proxy.changeOwnership(borrower);\n        \n        bool isPrepaid = loanStatus == LoanStatus.prepayment_fulfilled? true:false;\n        console.log('isprepaid', isPrepaid); \n        // Write to storage resolve details (principal+interest repaid, is prepaid, etc) \n        vault.pingMaturity(address(this), isPrepaid); \n\n    }\n\n    /// @notice borrower can see how much to repay now starting from last repayment time, also used to calculated\n    /// how much interest to repay for the current principalOwed, which can be changed \n    function interestToRepay() public view returns(uint256){\n\n        // Normalized to year\n        uint256 elapsedTime = toYear(getCurrentTime() - lastRepaymentTime);\n        console.log('elapsedTime', elapsedTime); \n        // Owed interest from last timestamp till now  + any unpaid interest that has accumulated\n        return elapsedTime.mulWadDown(interestAPR.mulWadDown(principalOwed)) + accumulated_interest ; \n    }\n     \n    /// @notice Allows a borrower to borrow on their creditline.\n    /// This creditline allows only lump sum drawdowns, all approved principal needs to be borrowed\n    /// which would start the interest timer \n    function drawdown() external onlyUtilizer{\n        require(vault.isTrusted(this), \"Not approved\");\n        require(loanStatus == LoanStatus.approvedNotDrawdowned, \"Already borrowed\"); \n        loanStatus = LoanStatus.drawdowned; \n\n        drawdown_block = block.timestamp; \n        lastRepaymentTime = block.timestamp;//-31536000/2; \n\n        totalOwed = principal + notionalInterest; \n        principalOwed = principal; \n        interestOwed = notionalInterest;\n\n        transfer_liq(msg.sender, principal); \n    }\n\n    /// @notice allows a borrower to repay their loan\n    /// Standard repayment structure is repaying interest for the owed principal periodically and\n    /// whenever principal is repayed interest owed is decreased proportionally \n    function repay( uint256 _repay_amount) external onlyUtilizer{\n        require(vault.isTrusted(this), \"Not approved\");\n\n        uint256 owedInterest = interestToRepay(); \n        uint256 repay_principal; \n        uint256 repay_interest = _repay_amount; \n        console.log('owedinterest', owedInterest, accumulated_interest);\n        // Push remaineder to repaying principal \n        if (_repay_amount >= owedInterest){\n            repay_principal += (_repay_amount - owedInterest);  \n            repay_interest = owedInterest; \n            accumulated_interest = 0; \n        }\n\n        //else repay_amount is less than owed interest, accumulate the debt \n        else accumulated_interest = owedInterest - repay_interest;\n\n        if(handleRepay(repay_principal, repay_interest)){\n\n            // Save resolve block, so that onMaturity can be called later\n            resolveBlock = block.number; \n\n            // Prepayment //TODO cases where repayed a significant portion at the start but paid rest at maturity date\n            if (isPaymentPremature()) loanStatus = LoanStatus.prepayment_fulfilled; \n\n            // Repayed at full maturity \n            else loanStatus = LoanStatus.matured; \n\n        }\n\n        lastRepaymentTime = getCurrentTime();  \n\n        transfer_liq_from(msg.sender, address(this), _repay_amount);\n\n    }   \n\n    /// @notice updates balances after repayment\n    /// need to remove min.\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal returns(bool){\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \n        principalOwed -= Math.min(repay_principal, principalOwed);\n        interestOwed -= Math.min(repay_interest, interestOwed);\n        console.log('repayment', repay_principal, repay_interest); \n        console.log('interestOwed should be same here', interestOwed, principalOwed); \n        principalRepayed += repay_principal;\n        interestRepayed += repay_interest; \n        if (repay_principal > 0) adjustInterestOwed(); \n\n        bool fullyRepayed = (principalOwed == 0 && interestOwed == 0)? true : false; \n        return fullyRepayed; \n    }\n\n\n\n\n    function setGracePeriod() external {}\n\n    /// @notice callable by anyone \n    function beginGracePeriod() external {\n       // require(block.timestamp >= drawdown_block + toSeconds(duration), \"time err\"); \n        require(principalOwed > 0 && interestOwed > 0, \"repaid\"); \n        gracePeriodStart = block.timestamp; \n        loanStatus = LoanStatus.grace_period; \n    }\n\n    function declareDefault() external onlyAuthorized {\n       // require(gracePeriodStart + gracePeriod >= block.timestamp);\n        require(loanStatus == LoanStatus.grace_period); \n\n        loanStatus = LoanStatus.isDefault; \n    }\n\n    /// @notice should be called  at default by validators\n    /// calling this function will go thorugh the necessary process\n    /// to recoup bad debt, and will push the remaining funds to vault\n    function onDefault() external onlyAuthorized{\n        require(loanStatus == LoanStatus.isDefault); \n\n        // If collateral is liquidateable, liquidate at dex and push to vault\n        if (isLiquidatable(collateral)) {\n            liquidateAndPushToVault(); //TODO get pool \n        }\n\n        // Else for non liquid governance tokens or ownership, should auction off \n        else {\n            auctionAndPushToVault(); \n        }\n\n        //Testing purposes only \n        underlying.transferFrom(msg.sender, address(this), principal/2); \n\n    }\n\n    /// @notice when principal/interest owed becomes 0, need to find out if this is prepaid\n    function isPaymentPremature() internal returns(bool){\n        // bool timeCondition = getCurrentTime() <= drawdown_block + toSeconds(duration); \n        bool amountCondition = (principal+notionalInterest) > (principalRepayed + interestRepayed) + DUST; \n\n        // timeCondition implies amountCondition, but not the other way around \n        return amountCondition; \n    }\n\n\n    function toYear(uint256 sec) internal pure returns(uint256){\n        return (sec*1e18)/uint256(31536000); \n    }\n\n    function toSeconds(uint256 y) internal pure returns(uint256){\n        return uint256(31536000).mulWadDown(y); \n    }\n\n    function getRemainingOwed() public view returns(uint256, uint256){\n        return(principalOwed, interestOwed); \n    }\n\n    function getCurrentLoanStatus() public view returns(uint256){}\n\n\n\n\n\n}\n\n\ncontract Proxy{\n    address owner; \n    address delegator; \n\n    address[] public ownedContracts;\n    mapping(address=>bytes4) public ownerTransferFunctions; \n    mapping(address=>bool) public isValidContract; \n\n    /// @notice owner is first set to be the instrument contract\n    /// and is meant to be changed back to the borrower or whoever is\n    /// buying the ownership \n    constructor(address _owner, address _delegator){\n        owner = _owner; \n        delegator = _delegator; \n\n    }\n\n    function changeOwnership(address newOwner) external {\n        require(msg.sender == owner, \"Not owner\"); \n        owner = newOwner; \n    }\n\n    function numContracts() public view returns(uint256){\n        return ownedContracts.length; \n    }\n\n    /// @notice temporarily delegate ownership of relevant contract \n    /// to this address, and stores the ownership transfering function\n    /// called when initialized\n    /// @param ownershipFunction is selector of the functions that transfers\n    /// ownership \n    /// @dev called by the borrower during assessment, after they had given ownership \n    /// of the contract to this address first, \n    /// but ownerTransferfunction/contract needs to be checked before approval by the validators\n    /// Validators are responsible for checking if there isn't any other ownership transferring functions \n    /// and check that the contract is legit, and think ways that the borrower can game the system. \n    function delegateOwnership(\n        address _contract, \n        bytes4 ownershipFunction) external \n    {\n        ownedContracts.push(_contract); \n        isValidContract[_contract] = true; \n        ownerTransferFunctions[_contract] = ownershipFunction; \n\n    }\n\n    /// @notice transfers ownership to borrower or any other party if necessary\n    function grantOwnership(\n        address _contract, \n        address newOwner,\n        bytes calldata data, \n        bool isSingleArgument) external{   \n        require(msg.sender == owner);\n        require(isValidContract[_contract]);\n        if(newOwner != address(this)) isValidContract[_contract] = false; \n\n        if(isSingleArgument){\n            (bool success, ) = _contract.call(\n                abi.encodeWithSelector(\n                    ownerTransferFunctions[_contract], \n                    newOwner\n                )\n            );  \n            require(success, \"!success\"); \n        }\n\n        else{\n            require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \"func not allowed\"); \n            (bool success, ) = _contract.call(data);\n            require(success, \"!success\"); \n\n        }\n    }\n\n    /// @notice function that ownership delegators use to call functions \n    /// in their contract other than the transferFunction contract \n    function proxyFunc(address _contract, bytes calldata data) external{\n        require(msg.sender == delegator); \n        require(convertBytesToBytes4(data) != ownerTransferFunctions[_contract], \"func not allowed\"); \n\n        (bool success, ) = _contract.call(data); \n        require(success, \"!success\"); \n\n    }\n\n    function convertBytesToBytes4(bytes memory inBytes) internal pure returns (bytes4 outBytes4) {\n        if (inBytes.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            outBytes4 := mload(add(inBytes, 4))\n        }\n    }\n\n    function getOwner() public view returns(address){\n        return owner; \n    }\n}\n\n\ncontract MockBorrowerContract{\n\n    address public owner; \n    constructor(){\n        owner = msg.sender;  \n    }\n\n    function changeOwner(address newOwner) public {\n        require(msg.sender == owner, \"notowner\"); \n        owner = newOwner; \n    } \n\n    function onlyOwnerFunction(uint256 a) public {\n        console.log('msgsender', msg.sender, owner); \n        require(msg.sender == owner, \"notowner\"); \n        console.log('hello', a); \n    }\n\n    function autoDelegate(address proxyad) public{\n        Proxy(proxyad).delegateOwnership(address(this), this.changeOwner.selector); \n    }\n    fallback () external {\n        console.log('hi?'); \n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/protocol/factories.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {Vault} from \"../vaults/vault.sol\";\nimport {MarketManager} from \"./marketmanager.sol\";\nimport {Controller} from \"./controller.sol\";\n\n\n/// @notice Anyone can create a vault. These can be users who  \n/// a) want exposure to specific instrument types(vault that focuses on uncollateralized RWA loans)\n/// b) are DAOs that want risk assessment/structuring for their treasuries that need management.(i.e almost all stablecoin issuers)\n/// c) a vault for any long-tailed assets \n/// d) managers who wants leverage for yield opportunities on a specific asset \n/// e) uncollateralized lending platforms that wants to delegate the risk underwriting \n/// etc\n/// They need to specify \n/// 1. Vault mint conditions-> such as verified LPs(managers) only, \n/// 2. default parameters of the market(like alpha, which determines level of risk&profit separation between vault/managers)\n/// 3. Vault underlying \n/// @dev only need a vault factory since marketId can be global, and all marketId will have a vaultId as it's parent\n\ncontract VaultFactory{\n\n  address owner; \n  mapping(address=>bool) private _isVault; \n\n  uint256 public numVaults; \n  Controller controller; \n\n  constructor(address _controller){\n    owner = msg.sender; \n    controller = Controller(_controller);\n  }\n\n  function isVault(address v) external view returns(bool){\n    return _isVault[v]; \n  }\n\n  modifier onlyController(){\n      require(address(controller) == msg.sender || msg.sender == owner || msg.sender == address(this), \"is not controller\"); \n      _;\n  }\n\n  /**\n   @notice creates vault\n   @param underlying: underlying asset for vault\n   @param _controller: protocol controller\n   @param _onlyVerified: only verified users can mint shares\n   @param _r: minimum reputation score to mint shares\n   @param _asset_limit: max number of shares for a single address\n   @param _total_asset_limit: max number of shares for entire vault\n   @param default_params: default params for markets created by vault\n   */\n  function newVault(\n    address underlying, \n    address _controller,\n    bool _onlyVerified, \n    uint256 _r, \n    uint256 _asset_limit,\n    uint256 _total_asset_limit,\n    MarketManager.MarketParameters memory default_params\n  ) external onlyController returns(Vault, uint256) {\n    require(default_params.alpha >= 1e16, \"Alpha too small\"); \n    \n    Vault vault = new Vault(\n      underlying,\n       _controller, \n       owner, \n       //Params \n       _onlyVerified,  _r, _asset_limit, _total_asset_limit,\n       default_params \n\n       ); \n    _isVault[address(vault)] = true; \n    numVaults++; \n\n    return (vault, numVaults); \n    // vaultId is numVaults after new creation of the vault.\n\n  }\n}"
    },
    "@interep/contracts/IInterep.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title Interep interface.\n/// @dev Interface of a Interep contract.\ninterface IInterep {\n    struct Verifier {\n        address contractAddress;\n        uint8 merkleTreeDepth;\n    }\n\n    struct Group {\n        bytes32 provider;\n        bytes32 name;\n        uint256 root;\n        uint8 depth;\n    }\n\n    /// @dev Emitted when a Semaphore proof is verified.\n    /// @param groupId: Id of the group.\n    /// @param signal: Semaphore signal.\n    event ProofVerified(uint256 indexed groupId, bytes32 signal);\n\n    /// @dev Emitted when an Interep group is updated.\n    /// @param groupId: Id of the group.\n    /// @param provider: Provider of the group.\n    /// @param name: Name of the group.\n    /// @param root: Root hash of the tree.\n    /// @param depth: Depth of the tree.\n    event GroupUpdated(\n        uint256 groupId,\n        bytes32 indexed provider,\n        bytes32 indexed name,\n        uint256 root,\n        uint8 indexed depth\n    );\n\n    /// @dev Updates the Interep groups.\n    /// @param groups: List of Interep groups.\n    function updateGroups(Group[] calldata groups) external;\n\n    /// @dev Saves the nullifier hash to avoid double signaling and emits an event\n    /// if the zero-knowledge proof is valid.\n    /// @param groupId: Id of the group.\n    /// @param signal: Semaphore signal.\n    /// @param nullifierHash: Nullifier hash.\n    /// @param externalNullifier: External nullifier.\n    /// @param proof: Zero-knowledge proof.\n    function verifyProof(\n        uint256 groupId,\n        bytes32 signal,\n        uint256 nullifierHash,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) external;\n\n    /// @dev Returns the root hash of an Interep group.\n    /// @param groupId: Id of the group.\n    /// @return Root hash of the group.\n    function getRoot(uint256 groupId) external view returns (uint256);\n\n    /// @dev Returns the tree depth of an Interep group.\n    /// @param groupId: Id of the group.\n    /// @return Tree depth of the group.\n    function getDepth(uint256 groupId) external view returns (uint8);\n}\n"
    },
    "contracts/bonds/LinearShortZCB.sol": {
      "content": "pragma solidity ^0.8.4;\nimport {OwnedERC20} from \"../turbo/OwnedShareToken.sol\";\nimport \"hardhat/console.sol\";\n//import \"../prb/PRBMathUD60x18.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {LinearBondingCurve} from \"./LinearBondingCurve.sol\"; \nimport {MarketManager} from \"../protocol/marketmanager.sol\"; \nimport {BondingCurve} from \"./bondingcurve.sol\"; \nimport {config} from \"../protocol/helpers.sol\"; \n\n/// @notice this contract allows tokenized short positions at a price 1-zcb\nabstract contract ShortBondingCurve is OwnedERC20{\n  using FixedPointMathLib for uint256;\n  using SafeERC20 for ERC20;\n\n  ERC20 private collateral;\n  BondingCurve private LongZCB;\n\n  uint256 math_precision; \n  uint256 collateral_dec; \n  uint256 marketId; \n  uint256 reserves;  \n\n  constructor (\n    string memory name,\n    string memory symbol,\n    address owner, // market manager.\n    address _collateral, //vault tokens\n    address LongZCB_address, \n    uint256 _marketId\n)  OwnedERC20(name, symbol, owner) {\n    collateral = ERC20(_collateral); \n    \n    math_precision = config.WAD;  \n    collateral_dec = collateral.decimals();    \n    collateral.approve(owner, 10*(10**8)* collateral_dec);     \n    LongZCB = BondingCurve(LongZCB_address);    \n    marketId = _marketId; \n\n  }\n\n  function getPair() public view returns(BondingCurve){\n    return LongZCB; \n  }\n\n  function getCollateral() public view returns(address){\n    return address(collateral);\n  }\n\n  /// @notice maximum possible short amount given current reserves, denominated in collateral \n  /// should be instead maximum possible borrow amount \n  /// @dev area between the curve and 1 at current supply, c - ( 2/a*(c**2) + b*c) \n  function getMaxShortAmount() public view returns(uint256){\n    uint256 c = LongZCB.totalSupplyAdjusted(); \n    (uint256 a, uint256 b) = LongZCB.getParams(); \n\n    return c - (a/2).mulWadDown(c.mulWadDown(c)) - b.mulWadDown(c); \n  }\n\n\n\n  /// @notice called from the marketmanager \n  /// 1 shortZCB token is tokenization of borrowing+ selling 1 longZCB  \n  /// so when longZCB price is 0.9, shortZCB is 0.1\n  /// when price is 0.1, trader transfer collateral_amount to buy 0.1 per shortZCB to this contract \n  /// this contract then borrows longZCB +sell it from marketmanager, collateral from sell sent back here\n  /// @dev at maturity funds here will be burned and redeemed amount will be minted just like longZCB \n  /// Function needs to follow the following\n  /// @param collateral_amount: amount (vt) used to mint shortzc\n  /// @dev trader is always market manager\n  function trustedShort(\n    address trader, \n    uint256 collateral_amount,\n    uint256 min_amount_out\n  ) external onlyOwner returns (uint256 shortTokensToMint, uint256 supply_after_sell) {\n\n    uint256 balance_before = collateral.balanceOf(address(this)); \n\n    (shortTokensToMint,\n     supply_after_sell) = calculateAmountGivenSell(collateral_amount);\n    collateral.safeTransferFrom(trader, address(this), collateral_amount); \n\n    // min_amount_out will automatically take care of slippage\n    uint256 amountOut = LongZCB.trustedSell(address(this), shortTokensToMint, 0);\n    reserves += (collateral_amount + amountOut); \n\n    console.log('amountout', amountOut, collateral_amount);\n    console.log('supply_after_sell', supply_after_sell, shortTokensToMint);\n\n    // Invariant #1: Value in to this contract after this trade \n    // should equal collateral_amount+amountOut = shortTokensToMint\n    assert(collateral.balanceOf(address(this)) - balance_before \n          >= shortTokensToMint-config.roundLimit);  \n    assert(amountOut + collateral_amount \n          >= shortTokensToMint-config.roundLimit); \n    require(min_amount_out <= shortTokensToMint, \"Slippage Err\"); \n\n    _mint(trader, shortTokensToMint); \n  }\n\n\n  /// @notice called from marketmanager, function for buying back and repaying debt \n  /// @dev selling one shortZCB is buying back and repaying one longZCB \n  /// 1. burn shortZCB  \n  /// 2. buy longZCB \n  /// 3. repay longZCB \n  function trustedClose(\n    address trader, \n    uint256 shortZCB_amount, \n    uint256 min_collateral_out\n  ) public onlyOwner returns(uint256 returned_collateral, uint256 amountOut){\n\n    uint256 balance_before = collateral.balanceOf(address(this)); \n\n    /// burn first, should revert if not enough balance \n    _burn(trader, shortZCB_amount); \n\n    // Area under the curve is the amount of collateral required to pay back debt\n    uint256 needed_collateral = LongZCB.calcAreaUnderCurve(shortZCB_amount); \n\n    // Returned collateral is the area between the curve and 1\n    returned_collateral = shortZCB_amount - needed_collateral; \n    reserves -= (needed_collateral + returned_collateral); \n\n    // Buy from the funds in this contract \n    collateral.approve(address(LongZCB), needed_collateral); \n    amountOut = LongZCB.trustedBuy(address(this), needed_collateral, 0); \n\n    console.log('needed_collateral', needed_collateral, returned_collateral); \n    console.log('shortZcbamount', shortZCB_amount); \n    \n    // Invariant #2: Value out from this contract after this trade \n    // should equal needed_collateral+returned_collateral = shortZCB_amount\n    assert(balance_before - collateral.balanceOf(address(this)) \n          <= shortZCB_amount+config.roundLimit); \n    assert(shortZCB_amount <= amountOut + config.roundLimit); \n    require(returned_collateral >= min_collateral_out, \"Slippage Err\"); \n\n    collateral.safeTransfer(trader, returned_collateral);\n\n  }\n\n\n\n\n\n  function calculateAmountGivenSell(uint256 amount) public view  returns (uint256,uint256) {\n    return _calculateAmountGivenSell(amount);\n   }\n\n  /// @notice returns estimated collateral required to repay debt, used for approvals \n  function getEstimatedCollateralNeeded(uint256 debt) public view returns(uint256){\n    return  LongZCB.calcAreaUnderCurve(debt); \n  }\n\n  /// @notice reserves should rougly equal the supply of shortZCB\n  function getReserves() public view returns(uint256){\n    return reserves; \n  }\n\n\n  /// @notice amount is in collateral, calculate the average price\n  /// of shortZCB when buying with amount \n  function calculateAveragePrice(uint256 amount) public view returns(uint256, uint256){\n    (uint256 shortTokenAmount, uint256 k) = calculateAmountGivenSell(amount);\n    return (amount.divWadDown(shortTokenAmount), shortTokenAmount); \n  }\n\n\n  function _calculateAmountGivenSell(uint256 amount) view public virtual returns(uint256 ,uint256);\n\n\n\n}\n\n\n\ncontract LinearShortZCB is ShortBondingCurve{\n\n  using FixedPointMathLib for uint256;\n  using SafeERC20 for ERC20;\n\n\n  constructor (\n      string memory name,\n      string memory symbol,\n      address owner,\n      address collateral, \n      address longZCBaddress, \n      uint256 marketId \n \n  ) ShortBondingCurve( name, symbol, owner, collateral, longZCBaddress, marketId) {\n\n  }\n\n\n  /// @notice calculates amount of ZCB to sell given collateral for shorts\n  /// which is finding, given the area between 1 and curve, the change in supply \n  /// @param amount in collateral dec\n  /// returns shortZCB amount from collateral and new supply after selling \n  function _calculateAmountGivenSell(uint256 amount) public override view returns(uint256,uint256){\n    \n    // Get current supply and params, shares the same parameters as longZCB because it is just trading opposite dir\n    uint256 c = getPair().totalSupplyAdjusted(); \n    (uint256 a, uint256 b) = getPair().getParams(); \n\n    // Compute \n    uint256 x = (math_precision-b).mulWadDown(math_precision-b); \n    uint256 q = 2*a.mulWadDown(c);\n    uint256 w = (a.mulWadDown(a)).mulWadDown(c.mulWadDown(c)); \n    uint256 e = q.mulWadDown(b);    \n    uint256 t = 2*a.mulWadDown(amount);\n    uint256 f = x+e+w+t;\n    uint256 h = f - q; \n    uint256 rhs = (h*math_precision).sqrt(); \n    console.log('rhs',rhs); \n\n    // If rhs larger then means not enough total supply to sell \n    uint256 numerator; \n    require(rhs < (math_precision-b), \"Not enough liquidity\"); \n    unchecked{numerator = (math_precision-b) - rhs;}\n\n    // New supply after sell, so c - cprime is the amount sold in ZCB  \n    uint256 cprime = numerator.divWadDown(a);\n    \n    console.log('cprime', cprime, c); \n\n    return ((c - cprime), cprime); \n  }\n\n\n\n\n}\n\n\n\n\n  // /// @notice called from marketmanager, function for buying back and repaying debt \n  // /// @dev selling one shortZCB is buying back and repaying one longZCB \n  // /// 1. burn shortZCB  \n  // /// 2. buy longZCB \n  // /// 3. repay longZCB \n  // function trustedClose(\n  //   address trader, \n  //   uint256 shortZCB_amount, \n  //   uint256 min_collateral_out\n  //   ) public onlyOwner returns(uint256 returned_collateral){\n\n  //   /// burn first, should revert if not enough balance \n  //   _burn(trader, shortZCB_amount); \n\n  //   // Area under the curve is the amount of collateral required to pay back debt\n  //   uint256 needed_collateral = LongZCB.calcAreaUnderCurve(shortZCB_amount); \n\n  //   // Returned collateral is the area between the curve and 1\n  //   returned_collateral = (shortZCB_amount/(10**(18-collateral_dec)) - needed_collateral);\n  //   require(returned_collateral >= min_collateral_out, \"Slippage Err\"); \n  //   console.log('needed_collateral', needed_collateral, returned_collateral); \n\n  //   MarketManager marketmanager = MarketManager(owner); \n  //   collateral.approve(address(LongZCB), needed_collateral); \n  //   uint256 amountOut = marketmanager.buy(marketId, needed_collateral, 0); \n  //   console.log('amountout', amountOut, shortZCB_amount); \n\n  //   marketmanager.repay_for_shortZCB(marketId, amountOut, trader);\n\n  //   collateral.safeTransfer(trader, returned_collateral); \n\n\n\n  // }\n  // /// @notice called from the marketmanager \n  // /// 1 shortZCB token is tokenization of borrowing+ selling 1 longZCB  \n  // /// so when longZCB price is 0.9, shortZCB is 0.1\n  // /// when price is 0.1, trader transfer collateral_amount to buy 0.1 per shortZCB to this contract \n  // /// this contract then borrows longZCB +sell it from marketmanager, collateral from sell sent back here\n  // /// @dev at maturity funds here will be burned and redeemed amount will be minted just like longZCB \n  // function trustedShort(\n  //   address trader, \n  //   uint256 collateral_amount,\n  //   uint256 min_amount_out\n  // ) public onlyOwner returns (uint256 shortTokensToMint, uint256 supply_after_sell) {\n\n  //   (shortTokensToMint,\n  //    supply_after_sell) = calculateAmountGivenSell(collateral_amount); \n  //   collateral.safeTransferFrom(trader, address(this), collateral_amount); \n\n  //   MarketManager marketmanager = MarketManager(owner); \n\n  //   // mints shortTokensToMint amount of longZCB.\n  //   marketmanager.borrow_for_shortZCB(marketId, shortTokensToMint); \n\n  //   // min_amount_out will automatically take care of slippage\n  //   uint256 amountOut = marketmanager.sell(marketId, shortTokensToMint, 0);  \n\n  //   //amountOut + collateral_amount should equal shortTokensToMint, TODO write invariant assertion with rounding\n  //   console.log('amountout', amountOut, collateral_amount);\n  //   console.log('supply_after_sell', supply_after_sell, shortTokensToMint); \n  //   require(min_amount_out <= shortTokensToMint, \"Slippage Err\"); \n\n  //   reserves += (collateral_amount + amountOut); \n\n  //   _mint(trader, shortTokensToMint); \n\n  // }\n\n  // /// @notice called from the marketmanager \n  // function trustedShort(\n  //  address trader, \n  //  uint256 collateral_amount\n  // ) public onlyOwner returns (uint256) {\n\n  //  (uint256 shortTokensToMint, uint256 supply_after_sell)  = calculateAmountGivenSell(collateral_amount); \n  //  collateral.safeTransferFrom(trader, address(this), collateral_amount); \n\n  //  MarketManager marketmanager = MarketManager(owner); \n  //  marketmanager.borrow_for_shortZCB(marketId, shortTokensToMint); // mints shortTokensToMint amount of longZCB.\n  //  uint256 amountOut = marketmanager.sell(marketId, shortTokensToMint); \n  //  console.log('amountout', amountOut, collateral_amount);\n  //  console.log('supply_after_sell', supply_after_sell, shortTokensToMint); \n\n  //  //amountOut + collateral_amount should equal shortTokensToMint \n  //  _mint(trader, shortTokensToMint); \n\n  //  reserves += (collateral_amount + amountOut); \n  //  return shortTokensToMint;\n  // }\n\n\n  // /// @notice called from marketmanager, function for buying back and repaying debt \n  // /// @dev one shortZCB is tokenized debt+sell of one longZCB \n  // /// 1. burn shortZCB  \n  // /// 2. buy longZCB \n  // /// 3. repay longZCB \n  // function trustedClose(\n  //  address trader, \n  //  uint256 shortZCB_amount \n  //  ) public onlyOwner returns(uint256){\n\n  //  ///burn first\n  //  _burn(trader, shortZCB_amount); \n\n  //  uint256 needed_collateral = LongZCB._calcAreaUnderCurve(shortZCB_amount); \n  //  uint256 returned_collateral = (shortZCB_amount/(10**(18-collateral_dec)) - needed_collateral);\n  //  console.log('needed_collateral', needed_collateral, returned_collateral); \n  //  // collateral.safeTransferFrom(trader, address(this), needed_collateral); \n  //  MarketManager marketmanager = MarketManager(owner); \n  //  collateral.approve(address(LongZCB), needed_collateral); \n  //  uint256 amountOut = marketmanager.buy( marketId, needed_collateral); \n //     console.log('amountout', amountOut, shortZCB_amount); \n\n  //  marketmanager.repay_for_shortZCB(marketId, amountOut, trader);\n\n  //  collateral.safeTransfer(trader, returned_collateral); \n\n  //  return returned_collateral; \n  // }\n  //  uint256 numerator; \n\n    // unchecked {numerator = (math_precision - b) - (((x - q+w+e+t)*math_precision).sqrt()) ;} \n    \n    // if (numerator >= 2**255 ) revert('Not enough liquidity'); \n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/protocol/owned.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.4;\n\n// https://docs.synthetix.io/contracts/Owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor (address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}"
    },
    "contracts/chainlink/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}"
    },
    "contracts/chainlink/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}"
    },
    "solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*//////////////////////////////////////////////////////////////\n                         METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) internal _ownerOf;\n\n    mapping(address => uint256) internal _balanceOf;\n\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\n        require((owner = _ownerOf[id]) != address(0), \"NOT_MINTED\");\n    }\n\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        require(owner != address(0), \"ZERO_ADDRESS\");\n\n        return _balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = _ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == _ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            _balanceOf[from]--;\n\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes calldata data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(_ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            _balanceOf[to]++;\n        }\n\n        _ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = _ownerOf[id];\n\n        require(owner != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            _balanceOf[owner]--;\n        }\n\n        delete _ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\nabstract contract ERC721TokenReceiver {\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        return ERC721TokenReceiver.onERC721Received.selector;\n    }\n}\n"
    },
    "contracts/vaults/auth/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\nabstract contract Auth {\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\n\n    address public owner;\n\n    Authority public authority;\n    mapping(address=>bool) Authorized; \n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(msg.sender, _owner);\n    }\n\n    modifier requiresAuth() virtual {\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\n\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\n        return(user == owner || Authorized[user]);\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\n    }\n\n    function setNewAuthority(address newAuthority) public {\n        require(msg.sender == owner );\n        Authorized[newAuthority] = true; \n\n    }\n\n    function setAuthority(Authority newAuthority) public virtual {\n        // We check if the caller is the owner first because we want to ensure they can\n        // always swap out the authority even if it's reverting or using up a lot of gas.\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\n\n        authority = newAuthority;\n\n        emit AuthorityUpdated(msg.sender, newAuthority);\n    }\n\n    function setOwner(address newOwner) public virtual requiresAuth {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\ninterface Authority {\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) external view returns (bool);\n}\n"
    },
    "contracts/vaults/mixins/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n// import {ERC20} from \"../../ERC20/ERC20.sol\";\nimport \"hardhat/console.sol\";\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"../utils/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\nabstract contract ERC4626 is ERC20 {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                               IMMUTABLES\n    //////////////////////////////////////////////////////////////*/\n\n    ERC20 public immutable asset;\n\n    uint immutable underlying_decimals; \n    uint8 constant default_decimals = 18; \n    bool public decimal_mismatch; \n\n    constructor(\n        ERC20 _asset,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol, default_decimals) {\n        asset = _asset;\n\n        underlying_decimals = _asset.decimals(); \n        decimal_mismatch = (_asset.decimals() != default_decimals);\n        if(decimal_mismatch) assert(_asset.decimals() < default_decimals);  \n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        DEPOSIT/WITHDRAWAL LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit.\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\n\n        // Need to transfer before minting or ERC777s could reenter.\n        asset.safeTransferFrom(msg.sender, address(this), assets);\n   \n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n\n        afterDeposit(assets, shares);\n    }\n\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 shares) {\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\n\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual returns (uint256 assets) {\n        if (msg.sender != owner) {\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\n\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\n        }\n\n        // Check for rounding error since we round down in previewRedeem.\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\n\n        beforeWithdraw(assets, shares);\n\n        _burn(owner, shares);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        asset.safeTransfer(receiver, assets);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ACCOUNTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function totalAssets() public view virtual returns (uint256);\n\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \n                : assets.mulDivDown(supply, totalAssets());\n    }\n\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if(decimal_mismatch) shares = decSharesToAssets(shares); \n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \n                : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return convertToShares(assets);\n    }\n\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n\n        return supply == 0 ? decimal_mismatch? decSharesToAssets(shares) : shares \n                : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\n        // if (decimal_mismatch) assets = decAssetsToShares(assets); \n\n        return supply == 0 ? decimal_mismatch? decAssetsToShares(assets) : assets \n                : assets.mulDivUp(supply, totalAssets());\n    }\n\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return convertToAssets(shares);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }\n\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return convertToAssets(balanceOf[owner]);\n    }\n\n    function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf[owner];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                          INTERNAL HOOKS LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\n\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\n\n    function decAssetsToShares(uint256 assets) public view virtual returns(uint256) {\n        return assets * (10 ** (default_decimals - underlying_decimals)); \n    }\n\n    function decSharesToAssets(uint256 shares) public view virtual returns(uint256){\n        return shares / (10**(default_decimals - underlying_decimals)); \n    }\n}\n"
    },
    "contracts/vaults/utils/SafeCastLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Safe unsigned integer casting library that reverts on overflow.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\nlibrary SafeCastLib {\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\n        require(x < 1 << 248);\n\n        y = uint248(x);\n    }\n\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\n        require(x < 1 << 224);\n\n        y = uint224(x);\n    }\n\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\n        require(x < 1 << 192);\n\n        y = uint192(x);\n    }\n\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\n        require(x < 1 << 160);\n\n        y = uint160(x);\n    }\n\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\n        require(x < 1 << 128);\n\n        y = uint128(x);\n    }\n\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\n        require(x < 1 << 96);\n\n        y = uint96(x);\n    }\n\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\n        require(x < 1 << 64);\n\n        y = uint64(x);\n    }\n\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\n        require(x < 1 << 32);\n\n        y = uint32(x);\n    }\n\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\n        require(x < 1 << 24);\n\n        y = uint24(x);\n    }\n\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\n        require(x < 1 << 8);\n\n        y = uint8(x);\n    }\n}\n"
    },
    "contracts/vaults/utils/SafeTransferLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"
    },
    "contracts/vaults/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z) // Like multiplying by 2 ** 64.\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z) // Like multiplying by 2 ** 32.\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z) // Like multiplying by 2 ** 16.\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z) // Like multiplying by 2 ** 8.\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z) // Like multiplying by 2 ** 4.\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z) // Like multiplying by 2 ** 2.\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n"
    },
    "contracts/vaults/tokens/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/turbo/newFetcher.sol": {
      "content": "pragma solidity ^0.8.4;\n\nimport {MarketManager} from \"../protocol/marketmanager.sol\";\nimport {Vault} from \"../vaults/vault.sol\";\nimport {VaultFactory} from \"../protocol/factories.sol\";\nimport {Controller} from \"../protocol/controller.sol\";\nimport {ERC20} from \"../vaults/tokens/ERC20.sol\";\n\ncontract Fetcher {\n    /**\n        static => only called on creation of vault or market.\n        dynamic => called continuously.\n     */\n    struct CollateralBundle {\n        address addr;\n        string symbol;\n        uint256 decimals;\n    }\n\n    struct StaticVaultBundle {\n        uint256 vaultId;\n        uint256[] marketIds;\n        MarketManager.MarketParameters default_params;\n        bool onlyVerified; \n        uint256 r; //reputation ranking  \n        uint256 asset_limit; \n        uint256 total_asset_limit;\n        CollateralBundle collateral;\n    }\n\n    struct StaticMarketBundle {\n        uint256 marketId;\n        uint256 creationTimestamp;\n        address long;\n        address short;\n        MarketManager.MarketParameters parameters;\n    }\n\n    struct DynamicVaultBundle {\n        uint256 vaultId;\n        uint256 totalSupply;\n    }\n\n    struct DynamicMarketBundle {\n        uint256 marketId;\n        MarketManager.MarketPhaseData phase;\n        uint256 longZCB; //net longs\n        uint256 shortZCB; // shorts bought\n        Vault.InstrumentData instrument;\n        uint256 approved_principal;\n        uint256 approved_yield;\n    }\n\n    string public marketType;\n    string public version;\n\n    constructor(string memory _type, string memory _version) {\n        marketType = _type;\n        version = _version;\n    }\n\n    function buildCollateralBundle(ERC20 _collateral) internal view returns (CollateralBundle memory _bundle) {\n        _bundle.addr = address(_collateral);\n        _bundle.symbol = _collateral.symbol();\n        _bundle.decimals = _collateral.decimals();\n    }\n\n    /**\n     @dev vaultId retrieved from vaultIds public array in controller.\n     @notice retrieves all the static data associated with a vaultId.\n     */\n    function fetchInitial(\n        Controller _controller,\n        MarketManager _marketManager,\n        uint256 _vaultId,\n        uint256 _offset // how many markets to skip from the top.\n    ) \n    public \n    view \n    returns (\n        StaticVaultBundle memory,\n        StaticMarketBundle[] memory,\n        uint256\n    )\n    {\n        StaticVaultBundle memory _vaultBundle;\n        StaticMarketBundle[] memory _staticMarketBundle;\n        uint256 _timestamp = block.timestamp;\n\n        // vault bundle\n        _vaultBundle.marketIds = _controller.getMarketIds(_vaultId);\n\n        Vault _vault = _controller.vaults(_vaultId);\n\n        if (address(_vault) == address(0)) {\n            return (makeEmptyStaticVaultBundle(), new StaticMarketBundle[](0), _timestamp);\n        }\n\n        _vaultBundle.collateral = buildCollateralBundle(_vault.asset());\n\n        _vaultBundle.default_params = _vault.get_vault_params();\n\n        _vaultBundle.onlyVerified = _vault.onlyVerified();\n        _vaultBundle.r = _vault.r();\n        _vaultBundle.asset_limit = _vault.asset_limit();\n        _vaultBundle.total_asset_limit = _vault.total_asset_limit();\n\n        if (_vaultBundle.marketIds.length == 0) {\n            return (_vaultBundle, new StaticMarketBundle[](0), _timestamp);\n        }\n\n        // market bundles\n        (uint256[] memory _marketIds) = listOfInterestingMarkets(_vaultId, _controller, _marketManager, _offset);\n        uint256 total = _marketIds.length;\n\n        _staticMarketBundle = new StaticMarketBundle[](total);\n\n        for (uint256 i = 0; i < total; i++) {\n            _staticMarketBundle[i] = buildStaticMarketBundle(_marketIds[i], _marketManager);\n        }\n\n        return (_vaultBundle, _staticMarketBundle, _timestamp);\n    }\n\n    function makeEmptyStaticVaultBundle() pure internal returns (StaticVaultBundle memory) {\n        return StaticVaultBundle(\n            0,\n            new uint256[](0),\n            MarketManager.MarketParameters(0,0,0,0,0,0,0),\n            false,\n            0,\n            0,\n            0,\n            CollateralBundle(address(0), \"\", 0)\n        );\n    }\n\n    function buildStaticMarketBundle(\n        uint256 _marketId,\n        MarketManager _marketManager\n    ) internal view returns (StaticMarketBundle memory bundle) {\n        MarketManager.CoreMarketData memory m_data = _marketManager.getMarket(_marketId);\n        bundle.creationTimestamp = m_data.creationTimestamp;\n        bundle.long = address(m_data.long);\n        bundle.short = address(m_data.short);\n        bundle.parameters = _marketManager.getParameters(_marketId);\n        bundle.marketId = _marketId;\n    }\n\n    /**\n     @param _offset: number of markets to skip from the top of the list of marketIds.\n     */\n    function listOfInterestingMarkets(\n        uint256 _vaultId, \n        Controller _controller, \n        MarketManager _marketManager,\n        uint256 _offset\n    ) internal view returns (uint256[] memory _interestingMarkets) {\n        uint256[] memory markets = _controller.getMarketIds(_vaultId);\n        uint256 _total = markets.length;\n        \n        if (_offset >= _total || _total == 0) {\n            return (new uint256[](0));\n        }\n\n        uint256 collectedMarkets = 0;\n        uint256[] memory tmp = new uint256[](_total);\n\n        for (uint256 i = (_total - _offset - 1);;) {\n            if (collectedMarkets >= _total) {\n                break;\n            }\n            \n            if (isUnresolvedMarket(markets[i], _marketManager)) {\n                tmp[collectedMarkets] = markets[i];      \n                collectedMarkets++;\n            }\n\n            if (i == 0) {\n                break;\n            }\n            i--;\n        }\n\n        _interestingMarkets = new uint256[](collectedMarkets);\n        for (uint256 i=0; i<collectedMarkets; i++) {\n            _interestingMarkets[i] = tmp[i];\n        }\n    }\n\n    function isUnresolvedMarket(uint256 marketId, MarketManager _marketManager) public view returns (bool) {\n        return true; // TODO\n    }\n\n    function fetchDynamic(\n        Controller _controller,\n        MarketManager _marketManager,\n        uint256 _vaultId,\n        uint256 _offset\n    ) public view returns (\n        DynamicVaultBundle memory,\n        DynamicMarketBundle[] memory,\n        uint256\n    ) {\n        DynamicVaultBundle memory _vaultBundle;\n        DynamicMarketBundle[] memory _dynamicMarketBundles;\n        uint256 _timestamp = block.timestamp;\n        \n        _vaultBundle.vaultId = _vaultId;\n        if (address(_controller.vaults(_vaultId)) == address(0)) {\n            return (makeEmptyDynamicVaultBundle(), new DynamicMarketBundle[](0), _timestamp);\n        }\n        _vaultBundle.totalSupply = _controller.vaults(_vaultId).totalSupply();\n\n        if (_controller.getMarketIds(_vaultId).length == 0) {\n            return (_vaultBundle, new DynamicMarketBundle[](0), _timestamp);\n        }\n        \n        uint256[] memory _marketIds = listOfInterestingMarkets(_vaultId, _controller, _marketManager, _offset);\n        uint256 total = _marketIds.length;\n        _dynamicMarketBundles = new DynamicMarketBundle[](total);\n        \n        for (uint256 i = 0; i < total; i++) {\n            _dynamicMarketBundles[i] = buildDynamicMarketBundle(_marketIds[i], _vaultId, _controller, _marketManager);\n        }\n        return (_vaultBundle, _dynamicMarketBundles, _timestamp);\n    }\n\n    function makeEmptyDynamicVaultBundle() internal pure returns (DynamicVaultBundle memory) {\n        return DynamicVaultBundle(0,0);\n    }\n\n    function buildDynamicMarketBundle(\n        uint256 _marketId,\n        uint256 _vaultId,\n        Controller _controller,\n        MarketManager _marketManager\n    ) internal view returns (DynamicMarketBundle memory bundle) {\n        Vault _vault = _controller.vaults(_vaultId);\n        bundle.marketId = _marketId;\n        bundle.phase = _marketManager.getPhaseData(_marketId);\n        bundle.longZCB = _marketManager.getZCB(_marketId).totalSupply();\n        bundle.shortZCB = _marketManager.getShortZCB(_marketId).totalSupply();\n        bundle.instrument = _vault.getInstrumentData(_vault.Instruments(_marketId));\n        Controller.ApprovalData memory approvalData = _controller.getApprovalData(_marketId);\n        bundle.approved_principal = approvalData.approved_principal;\n        bundle.approved_yield = approvalData.approved_yield;\n    }\n}"
    },
    "contracts/vaults/tokens/WETH.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"
    },
    "contracts/libraries/Cash.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Cash\n * @dev Test contract for collateral\n */\ncontract Cash is ERC20 {\n    uint8 private _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function decimals() public view virtual override(ERC20) returns (uint8) {\n        return _decimals;\n    }\n\n    function faucet(uint256 _amount) public returns (bool) {\n        _mint(msg.sender, _amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interep/Interep.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// only used for testing purposes.\n\nimport \"@interep/contracts/IInterep.sol\";\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@appliedzkp/semaphore-contracts/interfaces/IVerifier.sol\";\nimport \"@appliedzkp/semaphore-contracts/base/Verifier.sol\";\nimport \"@appliedzkp/semaphore-contracts/base/SemaphoreCore.sol\";\nimport \"@appliedzkp/semaphore-contracts/base/SemaphoreConstants.sol\";\n\n/// @title Interep\n/// @dev Interep is a collection of reputation Semaphore groups in which members\n/// can prove their Web2 reputation (or their membership in a group) without revealing their identity.\n/// Each Interep group is actually a Merkle tree, whose leaves represent the members of the group.\n/// Interep groups are saved off-chain but the Merkle tree roots of those groups are saved on-chain\n/// at regular intervals, so that users can verify their Semaphore ZK proof on-chain with this contract.\ncontract Interep is IInterep, Ownable, SemaphoreCore {\n    /// @dev Gets a tree depth and returns its verifier address.\n    mapping(uint8 => IVerifier) public verifiers;\n\n    /// @dev Gets a group id and returns the group data.\n    mapping(uint256 => Group) public groups;\n\n    /// @dev Checks if there is a verifier for the given tree depth.\n    /// @param depth: Depth of the tree.\n    modifier onlySupportedDepth(uint8 depth) {\n        require(address(verifiers[depth]) != address(0), \"Interep: tree depth is not supported\");\n        _;\n    }\n\n    /// @dev Initializes the Semaphore verifiers used to verify the user's ZK proofs.\n    /// @param _verifiers: List of Semaphore verifiers (address and related Merkle tree depth).\n    constructor(Verifier[] memory _verifiers) {\n        for (uint8 i = 0; i < _verifiers.length; i++) {\n            verifiers[_verifiers[i].merkleTreeDepth] = IVerifier(_verifiers[i].contractAddress);\n        }\n    }\n\n    /// @dev See {IInterep-updateGroups}.\n    function updateGroups(Group[] calldata _groups) external override onlyOwner {\n        for (uint8 i = 0; i < _groups.length; i++) {\n            uint256 groupId = uint256(keccak256(abi.encodePacked(_groups[i].provider, _groups[i].name))) %\n                SNARK_SCALAR_FIELD;\n\n            _updateGroup(groupId, _groups[i]);\n        }\n    }\n\n    /// @dev See {IInterep-verifyProof}.\n    function verifyProof(\n        uint256 groupId,\n        bytes32 signal,\n        uint256 nullifierHash,\n        uint256 externalNullifier,\n        uint256[8] calldata proof\n    ) external override {\n        uint256 root = getRoot(groupId);\n        uint8 depth = getDepth(groupId);\n\n        require(depth != 0, \"Interep: group does not exist\");\n\n        IVerifier verifier = verifiers[depth];\n\n        _verifyProof(signal, root, nullifierHash, externalNullifier, proof, verifier);\n\n        _saveNullifierHash(nullifierHash);\n\n        emit ProofVerified(groupId, signal);\n    }\n\n    /// @dev See {IInterep-getRoot}.\n    function getRoot(uint256 groupId) public view override returns (uint256) {\n        return groups[groupId].root;\n    }\n\n    /// @dev See {IInterep-getDepth}.\n    function getDepth(uint256 groupId) public view override returns (uint8) {\n        return groups[groupId].depth;\n    }\n\n    /// @dev Updates an Interep group.\n    /// @param groupId: Id of the group.\n    /// @param group: Group data.\n    function _updateGroup(uint256 groupId, Group calldata group) private onlySupportedDepth(group.depth) {\n        groups[groupId] = group;\n\n        emit GroupUpdated(groupId, group.provider, group.name, group.root, group.depth);\n    }\n}"
    },
    "@appliedzkp/semaphore-contracts/interfaces/IVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title Verifier interface.\n/// @dev Interface of Verifier contract.\ninterface IVerifier {\n  function verifyProof(\n    uint256[2] memory a,\n    uint256[2][2] memory b,\n    uint256[2] memory c,\n    uint256[4] memory input\n  ) external view;\n}\n"
    },
    "@appliedzkp/semaphore-contracts/base/Verifier.sol": {
      "content": "//\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n// 2019 OKIMS\n//      ported to solidity 0.6\n//      fixed linter warnings\n//      added requiere error messages\n//\n// 2021 Remco Bloemen\n//       cleaned up code\n//       added InvalidProve() error\n//       always revert with InvalidProof() on invalid proof\n//       make Pairing strict\n//\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\nlibrary Pairing {\n  error InvalidProof();\n\n  // The prime q in the base field F_q for G1\n  uint256 constant BASE_MODULUS = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n  // The prime moludus of the scalar field of G1.\n  uint256 constant SCALAR_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n  struct G1Point {\n    uint256 X;\n    uint256 Y;\n  }\n\n  // Encoding of field elements is: X[0] * z + X[1]\n  struct G2Point {\n    uint256[2] X;\n    uint256[2] Y;\n  }\n\n  /// @return the generator of G1\n  function P1() internal pure returns (G1Point memory) {\n    return G1Point(1, 2);\n  }\n\n  /// @return the generator of G2\n  function P2() internal pure returns (G2Point memory) {\n    return\n      G2Point(\n        [\n          11559732032986387107991004021392285783925812861821192530917403151452391805634,\n          10857046999023057135944570762232829481370756359578518086990519993285655852781\n        ],\n        [\n          4082367875863433681332203403145435568316851327593401208105741076214120093531,\n          8495653923123431417604973247489272438418190587263600148770280649306958101930\n        ]\n      );\n  }\n\n  /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.\n  function negate(G1Point memory p) internal pure returns (G1Point memory r) {\n    if (p.X == 0 && p.Y == 0) return G1Point(0, 0);\n    // Validate input or revert\n    if (p.X >= BASE_MODULUS || p.Y >= BASE_MODULUS) revert InvalidProof();\n    // We know p.Y > 0 and p.Y < BASE_MODULUS.\n    return G1Point(p.X, BASE_MODULUS - p.Y);\n  }\n\n  /// @return r the sum of two points of G1\n  function addition(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n    // By EIP-196 all input is validated to be less than the BASE_MODULUS and form points\n    // on the curve.\n    uint256[4] memory input;\n    input[0] = p1.X;\n    input[1] = p1.Y;\n    input[2] = p2.X;\n    input[3] = p2.Y;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// @return r the product of a point on G1 and a scalar, i.e.\n  /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\n  function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n    // By EIP-196 the values p.X and p.Y are verified to less than the BASE_MODULUS and\n    // form a valid point on the curve. But the scalar is not verified, so we do that explicitelly.\n    if (s >= SCALAR_MODULUS) revert InvalidProof();\n    uint256[3] memory input;\n    input[0] = p.X;\n    input[1] = p.Y;\n    input[2] = s;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n    }\n    if (!success) revert InvalidProof();\n  }\n\n  /// Asserts the pairing check\n  /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n  /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should succeed\n  function pairingCheck(G1Point[] memory p1, G2Point[] memory p2) internal view {\n    // By EIP-197 all input is verified to be less than the BASE_MODULUS and form elements in their\n    // respective groups of the right order.\n    if (p1.length != p2.length) revert InvalidProof();\n    uint256 elements = p1.length;\n    uint256 inputSize = elements * 6;\n    uint256[] memory input = new uint256[](inputSize);\n    for (uint256 i = 0; i < elements; i++) {\n      input[i * 6 + 0] = p1[i].X;\n      input[i * 6 + 1] = p1[i].Y;\n      input[i * 6 + 2] = p2[i].X[0];\n      input[i * 6 + 3] = p2[i].X[1];\n      input[i * 6 + 4] = p2[i].Y[0];\n      input[i * 6 + 5] = p2[i].Y[1];\n    }\n    uint256[1] memory out;\n    bool success;\n    // solium-disable-next-line security/no-inline-assembly\n    assembly {\n      success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n    }\n    if (!success || out[0] != 1) revert InvalidProof();\n  }\n}\n\ncontract Verifier {\n  using Pairing for *;\n\n  struct VerifyingKey {\n    Pairing.G1Point alfa1;\n    Pairing.G2Point beta2;\n    Pairing.G2Point gamma2;\n    Pairing.G2Point delta2;\n    Pairing.G1Point[] IC;\n  }\n\n  struct Proof {\n    Pairing.G1Point A;\n    Pairing.G2Point B;\n    Pairing.G1Point C;\n  }\n\n  function verifyingKey() internal pure returns (VerifyingKey memory vk) {\n    vk.alfa1 = Pairing.G1Point(\n      20491192805390485299153009773594534940189261866228447918068658471970481763042,\n      9383485363053290200918347156157836566562967994039712273449902621266178545958\n    );\n\n    vk.beta2 = Pairing.G2Point(\n      [\n        4252822878758300859123897981450591353533073413197771768651442665752259397132,\n        6375614351688725206403948262868962793625744043794305715222011528459656738731\n      ],\n      [\n        21847035105528745403288232691147584728191162732299865338377159692350059136679,\n        10505242626370262277552901082094356697409835680220590971873171140371331206856\n      ]\n    );\n    vk.gamma2 = Pairing.G2Point(\n      [\n        11559732032986387107991004021392285783925812861821192530917403151452391805634,\n        10857046999023057135944570762232829481370756359578518086990519993285655852781\n      ],\n      [\n        4082367875863433681332203403145435568316851327593401208105741076214120093531,\n        8495653923123431417604973247489272438418190587263600148770280649306958101930\n      ]\n    );\n    vk.delta2 = Pairing.G2Point(\n      [\n        12599857379517512478445603412764121041984228075771497593287716170335433683702,\n        7912208710313447447762395792098481825752520616755888860068004689933335666613\n      ],\n      [\n        11502426145685875357967720478366491326865907869902181704031346886834786027007,\n        21679208693936337484429571887537508926366191105267550375038502782696042114705\n      ]\n    );\n    vk.IC = new Pairing.G1Point[](5);\n\n    vk.IC[0] = Pairing.G1Point(\n      19918517214839406678907482305035208173510172567546071380302965459737278553528,\n      7151186077716310064777520690144511885696297127165278362082219441732663131220\n    );\n\n    vk.IC[1] = Pairing.G1Point(\n      690581125971423619528508316402701520070153774868732534279095503611995849608,\n      21271996888576045810415843612869789314680408477068973024786458305950370465558\n    );\n\n    vk.IC[2] = Pairing.G1Point(\n      16461282535702132833442937829027913110152135149151199860671943445720775371319,\n      2814052162479976678403678512565563275428791320557060777323643795017729081887\n    );\n\n    vk.IC[3] = Pairing.G1Point(\n      4319780315499060392574138782191013129592543766464046592208884866569377437627,\n      13920930439395002698339449999482247728129484070642079851312682993555105218086\n    );\n\n    vk.IC[4] = Pairing.G1Point(\n      3554830803181375418665292545416227334138838284686406179598687755626325482686,\n      5951609174746846070367113593675211691311013364421437923470787371738135276998\n    );\n  }\n\n  /// @dev Verifies a Semaphore proof. Reverts with InvalidProof if the proof is invalid.\n  function verifyProof(\n    uint256[2] memory a,\n    uint256[2][2] memory b,\n    uint256[2] memory c,\n    uint256[4] memory input\n  ) public view {\n    // If the values are not in the correct range, the Pairing contract will revert.\n    Proof memory proof;\n    proof.A = Pairing.G1Point(a[0], a[1]);\n    proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\n    proof.C = Pairing.G1Point(c[0], c[1]);\n\n    VerifyingKey memory vk = verifyingKey();\n\n    // Compute the linear combination vk_x of inputs times IC\n    if (input.length + 1 != vk.IC.length) revert Pairing.InvalidProof();\n    Pairing.G1Point memory vk_x = vk.IC[0];\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[1], input[0]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[2], input[1]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[3], input[2]));\n    vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[4], input[3]));\n\n    // Check pairing\n    Pairing.G1Point[] memory p1 = new Pairing.G1Point[](4);\n    Pairing.G2Point[] memory p2 = new Pairing.G2Point[](4);\n    p1[0] = Pairing.negate(proof.A);\n    p2[0] = proof.B;\n    p1[1] = vk.alfa1;\n    p2[1] = vk.beta2;\n    p1[2] = vk_x;\n    p2[2] = vk.gamma2;\n    p1[3] = proof.C;\n    p2[3] = vk.delta2;\n    Pairing.pairingCheck(p1, p2);\n  }\n}\n"
    },
    "@appliedzkp/semaphore-contracts/base/SemaphoreCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ISemaphoreCore.sol\";\nimport \"../interfaces/IVerifier.sol\";\n\n/// @title Semaphore core contract.\n/// @notice Minimal code to allow users to signal their endorsement of an arbitrary string.\n/// @dev The following code verifies that the proof is correct and saves the hash of the\n/// nullifier to prevent double-signaling. External nullifier and Merkle trees (i.e. groups) must be\n/// managed externally.\ncontract SemaphoreCore is ISemaphoreCore {\n  /// @dev Gets a nullifier hash and returns true or false.\n  /// It is used to prevent double-signaling.\n  mapping(uint256 => bool) internal nullifierHashes;\n\n  /// @dev Asserts that no nullifier already exists and if the zero-knowledge proof is valid.\n  /// Otherwise it reverts.\n  /// @param signal: Semaphore signal.\n  /// @param root: Root of the Merkle tree.\n  /// @param nullifierHash: Nullifier hash.\n  /// @param externalNullifier: External nullifier.\n  /// @param proof: Zero-knowledge proof.\n  /// @param verifier: Verifier address.\n  function _verifyProof(\n    bytes32 signal,\n    uint256 root,\n    uint256 nullifierHash,\n    uint256 externalNullifier,\n    uint256[8] calldata proof,\n    IVerifier verifier\n  ) internal view {\n    require(!nullifierHashes[nullifierHash], \"SemaphoreCore: you cannot use the same nullifier twice\");\n\n    uint256 signalHash = _hashSignal(signal);\n\n    verifier.verifyProof(\n      [proof[0], proof[1]],\n      [[proof[2], proof[3]], [proof[4], proof[5]]],\n      [proof[6], proof[7]],\n      [root, nullifierHash, signalHash, externalNullifier]\n    );\n  }\n\n  /// @dev Stores the nullifier hash to prevent double-signaling.\n  /// Attention! Remember to call it when you verify a proof if you\n  /// need to prevent double-signaling.\n  /// @param nullifierHash: Semaphore nullifier hash.\n  function _saveNullifierHash(uint256 nullifierHash) internal {\n    nullifierHashes[nullifierHash] = true;\n  }\n\n  /// @dev Creates a keccak256 hash of the signal.\n  /// @param signal: Semaphore signal.\n  /// @return Hash of the signal.\n  function _hashSignal(bytes32 signal) private pure returns (uint256) {\n    return uint256(keccak256(abi.encodePacked(signal))) >> 8;\n  }\n}\n"
    },
    "@appliedzkp/semaphore-contracts/base/SemaphoreConstants.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nuint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n"
    },
    "@appliedzkp/semaphore-contracts/interfaces/ISemaphoreCore.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @title SemaphoreCore interface.\n/// @dev Interface of SemaphoreCore contract.\ninterface ISemaphoreCore {\n  /// @notice Emitted when a proof is verified correctly and a new nullifier hash is added.\n  /// @param nullifierHash: Hash of external and identity nullifiers.\n  event NullifierHashAdded(uint256 nullifierHash);\n}\n"
    },
    "contracts/protocol/VRFConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {VRFConsumerBaseV2} from \"../chainlink/VRFConsumerBaseV2.sol\";\nimport {VRFCoordinatorV2Interface} from \"../chainlink/VRFCoordinatorV2Interface.sol\";\n\ncontract ChainlinkClient is VRFConsumerBaseV2 {\n    VRFCoordinatorV2Interface COORDINATOR;\n\n    // Your subscription ID.\n    uint64 private immutable s_subscriptionId;\n\n    // Goerli coordinator. For other networks,\n    // see https://docs.chain.link/docs/vrf-contracts/#configurations\n\n\n    // The gas lane to use, which specifies the maximum gas price to bump to.\n    // For a list of available gas lanes on each network,\n    // see https://docs.chain.link/docs/vrf-contracts/#configurations\n    bytes32 private keyHash;\n\n    // Depends on the number of requested values that you want sent to the\n    // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\n    // so 100,000 is a safe default for this example contract. Test and adjust\n    // this limit based on the network that you select, the size of the request,\n    // and the processing of the callback request in the fulfillRandomWords()\n    // function.\n    uint32 private callbackGasLimit = 100000;\n\n    // The default is 3, but you can set this higher.\n    uint16 private requestConfirmations = 3;\n\n    uint256[] public s_randomWords;\n    uint256 public s_requestId;\n    address s_owner;\n\n    mapping(uint256 => bool) used; // marketId => whether vrf has been called for a specific market\n    mapping(uint256 => address[]) candidates; // marketId => possible validators.\n\n    constructor(\n        bytes32 _keyHash,\n        address _vrfCoordinator,\n        uint64 subscriptionId\n    ) VRFConsumerBaseV2(_vrfCoordinator) {\n        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\n        s_owner = msg.sender;\n        s_subscriptionId = subscriptionId;\n        keyHash = _keyHash;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == s_owner);\n        _;\n    }\n\n    /**\n     @notice called by oracle on completion\n     */\n    function fulfillRandomWords(\n        uint256, /* requestId */\n        uint256[] memory randomWords\n    ) internal override {\n        s_randomWords = randomWords;\n    }\n\n    function requestRandomWords(\n        uint32 numWords,\n        uint256 marketId,\n        address[] memory _candidates\n    ) external onlyOwner {\n        require(!used[marketId], \"random words already requested for this marketId\");\n        used[marketId] = true;\n        candidates[marketId] = _candidates;\n\n        // Will revert if subscription is not set and funded.\n        s_requestId = COORDINATOR.requestRandomWords(\n            keyHash,\n            s_subscriptionId,\n            requestConfirmations,\n            callbackGasLimit,\n            numWords\n        );\n    }\n\n    /**\n     @dev should only be called by marketManager.\n     */\n    function deleteWords() external {\n        delete s_randomWords;\n    }\n\n    function wordLength() external returns (uint256) {\n        return s_randomWords.length;\n    }\n\n    function getNums() external returns (uint256[] memory) {\n        return s_randomWords;\n    }\n}\n"
    },
    "contracts/vaults/auth/authorities/RolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/RolesAuthority.sol)\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-roles/blob/master/src/roles.sol)\ncontract RolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, address indexed target, bytes4 indexed functionSig, bool enabled);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(address => mapping(bytes4 => bool)) public isCapabilityPublic;\n\n    mapping(address => mapping(bytes4 => bytes32)) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig\n    ) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[target][functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        return\n            isCapabilityPublic[target][functionSig] ||\n            bytes32(0) != getUserRoles[user] & getRolesWithCapability[target][functionSig];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        isCapabilityPublic[target][functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(target, functionSig, enabled);\n    }\n\n    function setRoleCapability(\n        uint8 role,\n        address target,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[target][functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[target][functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, target, functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n}\n"
    },
    "contracts/vaults/auth/authorities/MultiRolesAuthority.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {Auth, Authority} from \"../Auth.sol\";\n\n/// @notice Flexible and target agnostic role based Authority that supports up to 256 roles.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/authorities/MultiRolesAuthority.sol)\ncontract MultiRolesAuthority is Auth, Authority {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event UserRoleUpdated(address indexed user, uint8 indexed role, bool enabled);\n\n    event PublicCapabilityUpdated(bytes4 indexed functionSig, bool enabled);\n\n    event RoleCapabilityUpdated(uint8 indexed role, bytes4 indexed functionSig, bool enabled);\n\n    event TargetCustomAuthorityUpdated(address indexed target, Authority indexed authority);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner, Authority _authority) Auth(_owner) {}\n\n    /*//////////////////////////////////////////////////////////////\n                     CUSTOM TARGET AUTHORITY STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => Authority) public getTargetCustomAuthority;\n\n    /*//////////////////////////////////////////////////////////////\n                            ROLE/USER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => bytes32) public getUserRoles;\n\n    mapping(bytes4 => bool) public isCapabilityPublic;\n\n    mapping(bytes4 => bytes32) public getRolesWithCapability;\n\n    function doesUserHaveRole(address user, uint8 role) public view virtual returns (bool) {\n        return (uint256(getUserRoles[user]) >> role) & 1 != 0;\n    }\n\n    function doesRoleHaveCapability(uint8 role, bytes4 functionSig) public view virtual returns (bool) {\n        return (uint256(getRolesWithCapability[functionSig]) >> role) & 1 != 0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                           AUTHORIZATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function canCall(\n        address user,\n        address target,\n        bytes4 functionSig\n    ) public view virtual override returns (bool) {\n        Authority customAuthority = getTargetCustomAuthority[target];\n\n        if (address(customAuthority) != address(0)) return customAuthority.canCall(user, target, functionSig);\n\n        return\n            isCapabilityPublic[functionSig] || bytes32(0) != getUserRoles[user] & getRolesWithCapability[functionSig];\n    }\n\n    /*///////////////////////////////////////////////////////////////\n               CUSTOM TARGET AUTHORITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setTargetCustomAuthority(address target, Authority customAuthority) public virtual requiresAuth {\n        getTargetCustomAuthority[target] = customAuthority;\n\n        emit TargetCustomAuthorityUpdated(target, customAuthority);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                  PUBLIC CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setPublicCapability(bytes4 functionSig, bool enabled) public virtual requiresAuth {\n        isCapabilityPublic[functionSig] = enabled;\n\n        emit PublicCapabilityUpdated(functionSig, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                       USER ROLE ASSIGNMENT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setUserRole(\n        address user,\n        uint8 role,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getUserRoles[user] |= bytes32(1 << role);\n        } else {\n            getUserRoles[user] &= ~bytes32(1 << role);\n        }\n\n        emit UserRoleUpdated(user, role, enabled);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                   ROLE CAPABILITY CONFIGURATION LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setRoleCapability(\n        uint8 role,\n        bytes4 functionSig,\n        bool enabled\n    ) public virtual requiresAuth {\n        if (enabled) {\n            getRolesWithCapability[functionSig] |= bytes32(1 << role);\n        } else {\n            getRolesWithCapability[functionSig] &= ~bytes32(1 << role);\n        }\n\n        emit RoleCapabilityUpdated(role, functionSig, enabled);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}