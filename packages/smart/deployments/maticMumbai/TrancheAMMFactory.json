{
  "address": "0xa94Ab06f65A3D75dc183abBA737E9BF4f630BD91",
  "abi": [
    {
      "inputs": [],
      "name": "newPool",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x29562e1274249c0111719391dd6212d1fbaaf8a526ab8084e81b4feb116db7a7",
  "receipt": {
    "to": null,
    "from": "0xFD84b7AC1E646580db8c77f1f05F47977fAda692",
    "contractAddress": "0xa94Ab06f65A3D75dc183abBA737E9BF4f630BD91",
    "transactionIndex": 11,
    "gasUsed": "1618673",
    "logsBloom": "0x00000000000000020000000000080000000000000000800000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000020000000000000000001000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000020000000000000000000000100000",
    "blockHash": "0xb085059f1891b84695483be439055e4705fb72818fd657a187e4d42e24f4d607",
    "transactionHash": "0x29562e1274249c0111719391dd6212d1fbaaf8a526ab8084e81b4feb116db7a7",
    "logs": [
      {
        "transactionIndex": 11,
        "blockNumber": 27668556,
        "transactionHash": "0x29562e1274249c0111719391dd6212d1fbaaf8a526ab8084e81b4feb116db7a7",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000fd84b7ac1e646580db8c77f1f05f47977fada692",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x000000000000000000000000000000000000000000000000002e016568519fa5000000000000000000000000000000000000000000000002901dacfcab3cbcca0000000000000000000000000000000000000000000014107e5055f7bc5e39df0000000000000000000000000000000000000000000000028fefab9742eb1d250000000000000000000000000000000000000000000014107e7e575d24afd984",
        "logIndex": 29,
        "blockHash": "0xb085059f1891b84695483be439055e4705fb72818fd657a187e4d42e24f4d607"
      }
    ],
    "blockNumber": 27668556,
    "cumulativeGasUsed": "3613554",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "29a83bf9ac7eb91e37e2651095822cf1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"newPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"have to separate factories because of code size limit \",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/vaults/vault_tranche/tranchemaster.sol\":\"TrancheAMMFactory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xd15c3e400531f00203839159b2b8e7209c5158b35618f570c695b7e47f12e9f0\",\"license\":\"MIT\"},\"contracts/prb/PRBMath.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\\n\\n/// @notice Emitted when the result overflows uint256.\\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\\n\\n/// @notice Emitted when one of the inputs is type(int256).min.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows int256.\\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is MIN_SD59x18.\\nerror PRBMathSD59x18__AbsInputTooSmall();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\\n\\n/// @notice Emitted when the product of the inputs is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\\n\\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\\n\\n/// @notice Emitted when the input is less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\\n\\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\\n\\n/// @notice Emitted when the input is negative.\\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\\n\\n/// @notice Emitted when addition overflows UD60x18.\\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when ceiling a number overflows UD60x18.\\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 133.084258667509499441.\\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\\n\\n/// @notice Emitted when the input is greater than 192.\\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\\n\\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the input is less than 1.\\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\\n\\n/// @notice Emitted when the calculating the square root overflows UD60x18.\\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\\n\\n/// @notice Emitted when subtraction underflows UD60x18.\\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\\n\\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\\nlibrary PRBMath {\\n    /// STRUCTS ///\\n\\n    struct SD59x18 {\\n        int256 value;\\n    }\\n\\n    struct UD60x18 {\\n        uint256 value;\\n    }\\n\\n    /// STORAGE ///\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @dev Largest power of two divisor of SCALE.\\n    uint256 internal constant SCALE_LPOTD = 262144;\\n\\n    /// @dev SCALE inverted mod 2^256.\\n    uint256 internal constant SCALE_INVERSE =\\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n    /// FUNCTIONS ///\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    /// @dev Has to use 192.64-bit fixed-point numbers.\\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // Start from 0.5 in the 192.64-bit fixed-point format.\\n            result = 0x800000000000000000000000000000000000000000000000;\\n\\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n\\n            // We're doing two things at the same time:\\n            //\\n            //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n            //      rather than 192.\\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n            //\\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n            result *= SCALE;\\n            result >>= (191 - (x >> 64));\\n        }\\n    }\\n\\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\\n    /// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n    /// @param x The uint256 number for which to find the index of the most significant bit.\\n    /// @return msb The index of the most significant bit as an uint256.\\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\\n        if (x >= 2**128) {\\n            x >>= 128;\\n            msb += 128;\\n        }\\n        if (x >= 2**64) {\\n            x >>= 64;\\n            msb += 64;\\n        }\\n        if (x >= 2**32) {\\n            x >>= 32;\\n            msb += 32;\\n        }\\n        if (x >= 2**16) {\\n            x >>= 16;\\n            msb += 16;\\n        }\\n        if (x >= 2**8) {\\n            x >>= 8;\\n            msb += 8;\\n        }\\n        if (x >= 2**4) {\\n            x >>= 4;\\n            msb += 4;\\n        }\\n        if (x >= 2**2) {\\n            x >>= 2;\\n            msb += 2;\\n        }\\n        if (x >= 2**1) {\\n            // No need to shift x any more.\\n            msb += 1;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The multiplicand as an uint256.\\n    /// @param y The multiplier as an uint256.\\n    /// @param denominator The divisor as an uint256.\\n    /// @return result The result as an uint256.\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2^256 + prod0.\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        // Handle non-overflow cases, 256 by 256 division.\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = prod0 / denominator;\\n            }\\n            return result;\\n        }\\n\\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n        if (prod1 >= denominator) {\\n            revert PRBMath__MulDivOverflow(prod1, denominator);\\n        }\\n\\n        ///////////////////////////////////////////////\\n        // 512 by 256 division.\\n        ///////////////////////////////////////////////\\n\\n        // Make division exact by subtracting the remainder from [prod1 prod0].\\n        uint256 remainder;\\n        assembly {\\n            // Compute remainder using mulmod.\\n            remainder := mulmod(x, y, denominator)\\n\\n            // Subtract 256 bit number from 512 bit number.\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n        // See https://cs.stackexchange.com/q/138556/92363.\\n        unchecked {\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 lpotdod = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by lpotdod.\\n                denominator := div(denominator, lpotdod)\\n\\n                // Divide [prod1 prod0] by lpotdod.\\n                prod0 := div(prod0, lpotdod)\\n\\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * lpotdod;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f71e18) with full precision.\\n    ///\\n    /// @dev Variant of \\\"mulDiv\\\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\\n    /// being rounded to 1e-18.  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within uint256.\\n    ///\\n    /// Caveats:\\n    /// - The body is purposely left uncommented; see the NatSpec comments in \\\"PRBMath.mulDiv\\\" to understand how this works.\\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\\n    ///     1. x * y = type(uint256).max * SCALE\\n    ///     2. (x * y) % SCALE >= SCALE / 2\\n    ///\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(x, y, not(0))\\n            prod0 := mul(x, y)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 >= SCALE) {\\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\\n        }\\n\\n        uint256 remainder;\\n        uint256 roundUpUnit;\\n        assembly {\\n            remainder := mulmod(x, y, SCALE)\\n            roundUpUnit := gt(remainder, 499999999999999999)\\n        }\\n\\n        if (prod1 == 0) {\\n            unchecked {\\n                result = (prod0 / SCALE) + roundUpUnit;\\n                return result;\\n            }\\n        }\\n\\n        assembly {\\n            result := add(\\n                mul(\\n                    or(\\n                        div(sub(prod0, remainder), SCALE_LPOTD),\\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\\n                    ),\\n                    SCALE_INVERSE\\n                ),\\n                roundUpUnit\\n            )\\n        }\\n    }\\n\\n    /// @notice Calculates floor(x*y\\u00f7denominator) with full precision.\\n    ///\\n    /// @dev An extension of \\\"mulDiv\\\" for signed numbers. Works by computing the signs and the absolute values separately.\\n    ///\\n    /// Requirements:\\n    /// - None of the inputs can be type(int256).min.\\n    /// - The result must fit within int256.\\n    ///\\n    /// @param x The multiplicand as an int256.\\n    /// @param y The multiplier as an int256.\\n    /// @param denominator The divisor as an int256.\\n    /// @return result The result as an int256.\\n    function mulDivSigned(\\n        int256 x,\\n        int256 y,\\n        int256 denominator\\n    ) internal pure returns (int256 result) {\\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n            revert PRBMath__MulDivSignedInputTooSmall();\\n        }\\n\\n        // Get hold of the absolute values of x, y and the denominator.\\n        uint256 ax;\\n        uint256 ay;\\n        uint256 ad;\\n        unchecked {\\n            ax = x < 0 ? uint256(-x) : uint256(x);\\n            ay = y < 0 ? uint256(-y) : uint256(y);\\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n        }\\n\\n        // Compute the absolute value of (x*y)\\u00f7denominator. The result must fit within int256.\\n        uint256 rAbs = mulDiv(ax, ay, ad);\\n        if (rAbs > uint256(type(int256).max)) {\\n            revert PRBMath__MulDivSignedOverflow(rAbs);\\n        }\\n\\n        // Get the signs of x, y and the denominator.\\n        uint256 sx;\\n        uint256 sy;\\n        uint256 sd;\\n        assembly {\\n            sx := sgt(x, sub(0, 1))\\n            sy := sgt(y, sub(0, 1))\\n            sd := sgt(denominator, sub(0, 1))\\n        }\\n\\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\\n        // If yes, the result should be negative.\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Caveats:\\n    /// - This function does not work with fixed-point numbers.\\n    ///\\n    /// @param x The uint256 number for which to calculate the square root.\\n    /// @return result The result as an uint256.\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\\n        uint256 xAux = uint256(x);\\n        result = 1;\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n        if (xAux >= 0x4) {\\n            result <<= 1;\\n        }\\n\\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1; // Seven iterations should be enough\\n            uint256 roundedDownResult = x / result;\\n            return result >= roundedDownResult ? roundedDownResult : result;\\n        }\\n    }\\n}\",\"keccak256\":\"0xe7c890390f136477835cd5ca21aff681fdf36f1d79a3166b679afcc9d8c3122b\",\"license\":\"Unlicense\"},\"contracts/prb/PRBMathUD60x18.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.4;\\n\\nimport \\\"./PRBMath.sol\\\";\\n\\n/// @title PRBMathUD60x18\\n/// @author Paul Razvan Berg\\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\\n/// maximum values permitted by the Solidity type uint256.\\nlibrary PRBMathUD60x18 {\\n    /// @dev Half the SCALE number.\\n    uint256 internal constant HALF_SCALE = 5e17;\\n\\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\\n    uint256 internal constant LOG2_E = 1_442695040888963407;\\n\\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\\n\\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\\n    uint256 internal constant MAX_WHOLE_UD60x18 =\\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\\n\\n    /// @dev How many trailing decimals can be represented.\\n    uint256 internal constant SCALE = 1e18;\\n\\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // The operations can never overflow.\\n        unchecked {\\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\\n        }\\n    }\\n\\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\\n    ///\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function ceil(uint256 x) internal pure returns (uint256 result) {\\n        if (x > MAX_WHOLE_UD60x18) {\\n            revert PRBMathUD60x18__CeilOverflow(x);\\n        }\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"SCALE - remainder\\\" but faster.\\n            let delta := sub(SCALE, remainder)\\n\\n            // Equivalent to \\\"x + delta * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := add(x, mul(delta, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\\n    ///\\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\\n    ///\\n    /// Requirements:\\n    /// - The denominator cannot be zero.\\n    ///\\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDiv(x, SCALE, y);\\n    }\\n\\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\\n    function e() internal pure returns (uint256 result) {\\n        result = 2_718281828459045235;\\n    }\\n\\n    /// @notice Calculates the natural exponent of x.\\n    ///\\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    /// - x must be less than 133.084258667509499441.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp(uint256 x) internal pure returns (uint256 result) {\\n        // Without this check, the value passed to \\\"exp2\\\" would be greater than 192.\\n        if (x >= 133_084258667509499441) {\\n            revert PRBMathUD60x18__ExpInputTooBig(x);\\n        }\\n\\n        // Do the fixed-point multiplication inline to save gas.\\n        unchecked {\\n            uint256 doubleScaleProduct = x * LOG2_E;\\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\\n        }\\n    }\\n\\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\\n    ///\\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\\n    ///\\n    /// Requirements:\\n    /// - x must be 192 or less.\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function exp2(uint256 x) internal pure returns (uint256 result) {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (x >= 192e18) {\\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x192x64 = (x << 64) / SCALE;\\n\\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\\n            result = PRBMath.exp2(x192x64);\\n        }\\n    }\\n\\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\\n    function floor(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            // Equivalent to \\\"x % SCALE\\\" but faster.\\n            let remainder := mod(x, SCALE)\\n\\n            // Equivalent to \\\"x - remainder * (remainder > 0 ? 1 : 0)\\\" but faster.\\n            result := sub(x, mul(remainder, gt(remainder, 0)))\\n        }\\n    }\\n\\n    /// @notice Yields the excess beyond the floor of x.\\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\\n    function frac(uint256 x) internal pure returns (uint256 result) {\\n        assembly {\\n            result := mod(x, SCALE)\\n        }\\n    }\\n\\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\\n    ///\\n    /// @dev Requirements:\\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\\n    ///\\n    /// @param x The basic integer to convert.\\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__FromUintOverflow(x);\\n            }\\n            result = x * SCALE;\\n        }\\n    }\\n\\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n    ///\\n    /// @dev Requirements:\\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\\n    ///\\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            return 0;\\n        }\\n\\n        unchecked {\\n            // Checking for overflow this way is faster than letting Solidity do it.\\n            uint256 xy = x * y;\\n            if (xy / x != y) {\\n                revert PRBMathUD60x18__GmOverflow(x, y);\\n            }\\n\\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\\n            // during multiplication. See the comments within the \\\"sqrt\\\" function.\\n            result = PRBMath.sqrt(xy);\\n        }\\n    }\\n\\n    /// @notice Calculates 1 / x, rounding toward zero.\\n    ///\\n    /// @dev Requirements:\\n    /// - x cannot be zero.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\\n    function inv(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 1e36 is SCALE * SCALE.\\n            result = 1e36 / x;\\n        }\\n    }\\n\\n    /// @notice Calculates the natural logarithm of x.\\n    ///\\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function ln(uint256 x) internal pure returns (uint256 result) {\\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n        // can return is 196205294292027477728.\\n        unchecked {\\n            result = (log2(x) * SCALE) / LOG2_E;\\n        }\\n    }\\n\\n    /// @notice Calculates the common logarithm of x.\\n    ///\\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"log2\\\".\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log10(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n\\n        // Note that the \\\"mul\\\" in this block is the assembly multiplication operation, not the \\\"mul\\\" function defined\\n        // in this contract.\\n        // prettier-ignore\\n        assembly {\\n            switch x\\n            case 1 { result := mul(SCALE, sub(0, 18)) }\\n            case 10 { result := mul(SCALE, sub(1, 18)) }\\n            case 100 { result := mul(SCALE, sub(2, 18)) }\\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\\n            case 1000000000000000000 { result := 0 }\\n            case 10000000000000000000 { result := SCALE }\\n            case 100000000000000000000 { result := mul(SCALE, 2) }\\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\\n            default {\\n                result := MAX_UD60x18\\n            }\\n        }\\n\\n        if (result == MAX_UD60x18) {\\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\\n            unchecked {\\n                result = (log2(x) * SCALE) / 3_321928094887362347;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the binary logarithm of x.\\n    ///\\n    /// @dev Based on the iterative approximation algorithm.\\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n    ///\\n    /// Requirements:\\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\\n    ///\\n    /// Caveats:\\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\\n    function log2(uint256 x) internal pure returns (uint256 result) {\\n        if (x < SCALE) {\\n            revert PRBMathUD60x18__LogInputTooSmall(x);\\n        }\\n        unchecked {\\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\\n\\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\\n            // because n is maximum 255 and SCALE is 1e18.\\n            result = n * SCALE;\\n\\n            // This is y = x * 2^(-n).\\n            uint256 y = x >> n;\\n\\n            // If y = 1, the fractional part is zero.\\n            if (y == SCALE) {\\n                return result;\\n            }\\n\\n            // Calculate the fractional part via the iterative approximation.\\n            // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\\n                y = (y * y) / SCALE;\\n\\n                // Is y^2 > 2 and so in the range [2,4)?\\n                if (y >= 2 * SCALE) {\\n                    // Add the 2^(-m) factor to the logarithm.\\n                    result += delta;\\n\\n                    // Corresponds to z/2 on Wikipedia.\\n                    y >>= 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\\n    /// fixed-point number.\\n    /// @dev See the documentation for the \\\"PRBMath.mulDivFixedPoint\\\" function.\\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        result = PRBMath.mulDivFixedPoint(x, y);\\n    }\\n\\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\\n    function pi() internal pure returns (uint256 result) {\\n        result = 3_141592653589793238;\\n    }\\n\\n    /// @notice Raises x to the power of y.\\n    ///\\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\\n    ///\\n    /// Requirements:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"exp2\\\", \\\"log2\\\" and \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        if (x == 0) {\\n            result = y == 0 ? SCALE : uint256(0);\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n\\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\\n    /// famous algorithm \\\"exponentiation by squaring\\\".\\n    ///\\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n    ///\\n    /// Requirements:\\n    /// - The result must fit within MAX_UD60x18.\\n    ///\\n    /// Caveats:\\n    /// - All from \\\"mul\\\".\\n    /// - Assumes 0^0 is 1.\\n    ///\\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\\n    /// @param y The exponent as an uint256.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\\n        // Calculate the first iteration of the loop in advance.\\n        result = y & 1 > 0 ? x : SCALE;\\n\\n        // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n        for (y >>= 1; y > 0; y >>= 1) {\\n            x = PRBMath.mulDivFixedPoint(x, x);\\n\\n            // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n            if (y & 1 > 0) {\\n                result = PRBMath.mulDivFixedPoint(result, x);\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\\n    function scale() internal pure returns (uint256 result) {\\n        result = SCALE;\\n    }\\n\\n    /// @notice Calculates the square root of x, rounding down.\\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n    ///\\n    /// Requirements:\\n    /// - x must be less than MAX_UD60x18 / SCALE.\\n    ///\\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            if (x > MAX_UD60x18 / SCALE) {\\n                revert PRBMathUD60x18__SqrtOverflow(x);\\n            }\\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\\n            result = PRBMath.sqrt(x * SCALE);\\n        }\\n    }\\n\\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\\n    /// @return result The same number in basic integer form.\\n    function toUint(uint256 x) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = x / SCALE;\\n        }\\n    }\\n}\",\"keccak256\":\"0xf642499f1cbe1d382342af37d2850edc34d2348d4343e4abfd25148a34d03575\",\"license\":\"Unlicense\"},\"contracts/vaults/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n    mapping(address=>bool) Authorized; \\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n    }\\n\\n    modifier requiresAuth() virtual {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        //Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return(user == owner || Authorized[user]);\\n        //return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setNewAuthority(address newAuthority) public {\\n        require(msg.sender == owner );\\n        Authorized[newAuthority] = true; \\n\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x46c0e8d518396b50d7dc7f0050d716a5643afad9320b0cd27490fd8e00689dc7\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/instrument.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport \\\"./vault.sol\\\";\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../prb/PRBMathUD60x18.sol\\\";\\n\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\nabstract contract Instrument {\\n\\n    modifier onlyUtilizer() {\\n        require(msg.sender == Utilizer, \\\"!Utilizer\\\");\\n        _;\\n    }\\n\\n    modifier onlyAuthorized() {\\n        require(msg.sender == Utilizer || msg.sender == vault.owner(), \\\"!authorized\\\");\\n        _;\\n    }\\n\\n\\n    ERC20 public underlying;\\n    Vault public vault; \\n    uint256 private constant MAX_UINT = 2**256 - 1;\\n\\n    /// @notice address of user who submits the liquidity proposal \\n    address Utilizer; \\n\\n    /// @notice initializes a new Instrument \\n    function _initialize(\\n        address _vault,\\n        address _Utilizer\\n    ) internal {\\n        vault = Vault(_vault);\\n        underlying = ERC20(vault.UNDERLYING());\\n        underlying.approve(_vault, MAX_UINT); // Give Vault unlimited access \\n        Utilizer = _Utilizer;\\n\\n    }\\n\\n\\n    function setUtilizer(address _Utilizer) external onlyAuthorized {\\n        require(_Utilizer != address(0));\\n        Utilizer = _Utilizer;\\n    }\\n\\n\\n    /// @notice Withdraws a specific amount of underlying tokens from the Instrument.\\n    /// @param amount The amount of underlying tokens to withdraw.\\n    /// @return An error code, or 0 if the withdrawal was successful.\\n    function redeemUnderlying(uint256 amount) external  returns (bool){\\n        return underlying.transfer(address(vault), amount); \\n    }\\n\\n    /// @notice Returns a user's Instrument balance in underlying tokens.\\n    /// @param user The user to get the underlying balance of.\\n    /// @return The user's Instrument balance in underlying tokens.\\n    /// @dev May mutate the state of the Instrument by accruing interest.\\n    function balanceOfUnderlying(address user) external  returns (uint256){\\n        return underlying.balanceOf(user); \\n        }\\n}\\n\\n\\n\\n/// @notice Simple Instrument that provides USDC on stableswap 3pool \\ncontract Curve3pool_Instrument is Instrument{\\n\\n    /// @notice invests amount into Instrument \\n    function invest(uint256 amount ) external \\n    //onlyGuardian \\n    {   \\n        require(this.balanceOfUnderlying(address(this)) >= amount);\\n        _invest(amount);  \\n\\n    }\\n\\n    function _invest(uint256 _amount) internal {\\n\\n    }\\n\\n\\n\\n}\\n\\n\\n/// @notice Instrument that a) lends usdc fix rate at notional.finance and get zcb\\n/// b) use that zcb as collateral to borrow fiat from fiatdao, c) swap fiat dao to usdc\\n/// d) repeat\\ncontract LeveragedFixedRate_Instrument is Instrument{\\n\\n}\\n\\n/// @notice Instrument that lends to risky collateral in fuse pools\\ncontract RariLend_Instrument is Instrument{\\n\\n}\\n\\n\\n\\n \\n/// @notice Contract for unsecured loans, each instance will be associated to a borrower+marketId\\n/// approved borrowers will interact with this contract to borrow, repay. \\n/// and vault will supply principal and harvest principal/interest \\ncontract CreditLine is Instrument {\\n    using PRBMathUD60x18 for uint256;\\n\\n    //  variables initiated at creation\\n    uint256  principal;\\n    uint256  interestAPR; \\n    uint256  faceValue; //total amount due, i.e principal+interest\\n    uint256  duration; \\n\\n    // Modify-able Variables during repayments, borrow\\n    uint256 totalOwed; \\n    uint256 principalOwed; \\n    uint256 interestOwed; \\n    uint256 maturityDate;\\n\\n    constructor(\\n        address vault,\\n        address borrower, \\n        uint256 principal,\\n        uint256 interestAPR, \\n        uint256 duration,\\n        uint256 faceValue\\n    ) public {\\n        initialize(vault, borrower, principal, interestAPR, duration, faceValue);\\n    }\\n\\n    /// @notice CreditLine contract is initiated at proposal \\n    /// @dev include any Instrument specific initialization logic  \\n    /// @param _borrower stored as Utilizer \\n    function initialize(\\n        address _vault,\\n        address _borrower,         \\n        uint256 _principal,\\n        uint256 _interestAPR, \\n        uint256 _duration, \\n        uint256 _faceValue\\n    ) internal {\\n        _initialize(_vault, _borrower); \\n\\n        principal = _principal; \\n        interestAPR = _interestAPR; \\n        duration = _duration;   \\n        faceValue = _faceValue; \\n\\n        interestOwed = getOwedInterest(_interestAPR, _duration); \\n    }\\n\\n    /// @notice use APR and duration to get total owed interest \\n    function getOwedInterest(uint256 APR, uint256 duration) internal pure returns(uint256 owed){\\n        return APR; \\n    }\\n\\n    /// @notice Allows a borrower to borrow on their creditline.\\n    function drawdown(uint256 amount) external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n        require(underlying.balanceOf(address(this)) > amount, \\\"Exceeds Credit\\\");\\n        require(block.timestamp <= maturityDate, \\\"Instrument must not have matured\\\");\\n        totalOwed += amount; \\n        principalOwed += amount; \\n        underlying.transfer(msg.sender, amount);\\n    }\\n\\n    /// @notice sets the maturity date for the instrument, after which the user can no longer borrow any funds.\\n    function setTime() external onlyUtilizer {\\n        maturityDate = block.timestamp + duration;\\n    }\\n\\n\\n    /// @notice allows a borrower to repay their loan\\n    function repay(uint256 repay_principal, uint256 repay_interest) external onlyUtilizer{\\n        require(vault.isTrusted(this), \\\"Not approved\\\");\\n        underlying.transferFrom(msg.sender, address(this), repay_principal + repay_interest);\\n        handleRepay(repay_principal, repay_interest); \\n    }   \\n\\n    /// @notice updates balances after repayment\\n    function handleRepay(uint256 repay_principal, uint256 repay_interest) internal {\\n        totalOwed -= Math.min((repay_principal + repay_interest), totalOwed); \\n        principalOwed -= Math.min(repay_principal, principalOwed);\\n        interestOwed -= Math.min(repay_interest, interestOwed);\\n    }\\n\\n    function resolveLoan() external onlyUtilizer{\\n        \\n    }\\n}\\n\\n\\n\\n\\n\\n\",\"keccak256\":\"0x6201eaa09e7cd543f65b6219778166867702af22921ac042c31a31a5b8e40db8\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/mixins/ERC4626.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n// import {ERC20} from \\\"../../ERC20/ERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\n/// @notice Minimal ERC4626 tokenized Vault implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/mixins/ERC4626.sol)\\nabstract contract ERC4626 is ERC20 {\\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    ERC20 public immutable asset;\\n\\n    constructor(\\n        ERC20 _asset,\\n        string memory _name,\\n        string memory _symbol\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\\n        // Check for rounding error since we round down in previewDeposit.\\n        require((shares = previewDeposit(assets)) != 0, \\\"ZERO_SHARES\\\");\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n\\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n\\n        // Need to transfer before minting or ERC777s could reenter.\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n   \\n        _mint(receiver, shares);\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n\\n        afterDeposit(assets, shares);\\n    }\\n\\n    function withdraw(\\n        uint256 assets,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 shares) {\\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public virtual returns (uint256 assets) {\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n\\n        beforeWithdraw(assets, shares);\\n\\n        _burn(owner, shares);\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n\\n        asset.safeTransfer(receiver, assets);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function totalAssets() public view virtual returns (uint256);\\n\\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\\n    }\\n\\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\\n    }\\n\\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\\n        return convertToShares(assets);\\n    }\\n\\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\\n    }\\n\\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\\n\\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\\n    }\\n\\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\\n        return convertToAssets(shares);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function maxDeposit(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxMint(address) public view virtual returns (uint256) {\\n        return type(uint256).max;\\n    }\\n\\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\\n        return convertToAssets(balanceOf[owner]);\\n    }\\n\\n    function maxRedeem(address owner) public view virtual returns (uint256) {\\n        return balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INTERNAL HOOKS LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\\n\\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\\n}\\n\",\"keccak256\":\"0xe647a3196ee460c1f8f855c4c0982d2896ec8b3287367622716265ecfe5d4748\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0xcdfd8db76b2a3415620e4d18cc5545f3d50de792dbf2c3dd5adb40cbe6f94b10\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            // Start off with z at 1.\\n            z := 1\\n\\n            // Used below to help find a nearby power of 2.\\n            let y := x\\n\\n            // Find the lowest power of 2 that is at least sqrt(x).\\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\\n                y := shr(128, y) // Like dividing by 2 ** 128.\\n                z := shl(64, z) // Like multiplying by 2 ** 64.\\n            }\\n            if iszero(lt(y, 0x10000000000000000)) {\\n                y := shr(64, y) // Like dividing by 2 ** 64.\\n                z := shl(32, z) // Like multiplying by 2 ** 32.\\n            }\\n            if iszero(lt(y, 0x100000000)) {\\n                y := shr(32, y) // Like dividing by 2 ** 32.\\n                z := shl(16, z) // Like multiplying by 2 ** 16.\\n            }\\n            if iszero(lt(y, 0x10000)) {\\n                y := shr(16, y) // Like dividing by 2 ** 16.\\n                z := shl(8, z) // Like multiplying by 2 ** 8.\\n            }\\n            if iszero(lt(y, 0x100)) {\\n                y := shr(8, y) // Like dividing by 2 ** 8.\\n                z := shl(4, z) // Like multiplying by 2 ** 4.\\n            }\\n            if iszero(lt(y, 0x10)) {\\n                y := shr(4, y) // Like dividing by 2 ** 4.\\n                z := shl(2, z) // Like multiplying by 2 ** 2.\\n            }\\n            if iszero(lt(y, 0x8)) {\\n                // Equivalent to 2 ** z.\\n                z := shl(1, z)\\n            }\\n\\n            // Shifting right by 1 is like dividing by 2.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // Compute a rounded down version of z.\\n            let zRoundDown := div(x, z)\\n\\n            // If zRoundDown is smaller, use it.\\n            if lt(zRoundDown, z) {\\n                z := zRoundDown\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9faabac0803e077fb8d8950f5e2fec1984d3e6cd6ad5fc144609b5c9de83d169\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeCastLib.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x < 1 << 248);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo224(uint256 x) internal pure returns (uint224 y) {\\n        require(x < 1 << 224);\\n\\n        y = uint224(x);\\n    }\\n\\n    function safeCastTo192(uint256 x) internal pure returns (uint192 y) {\\n        require(x < 1 << 192);\\n\\n        y = uint192(x);\\n    }\\n\\n    function safeCastTo160(uint256 x) internal pure returns (uint160 y) {\\n        require(x < 1 << 160);\\n\\n        y = uint160(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x < 1 << 128);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x < 1 << 96);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x < 1 << 64);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x < 1 << 32);\\n\\n        y = uint32(x);\\n    }\\n\\n    function safeCastTo24(uint256 x) internal pure returns (uint24 y) {\\n        require(x < 1 << 24);\\n\\n        y = uint24(x);\\n    }\\n\\n    function safeCastTo8(uint256 x) internal pure returns (uint8 y) {\\n        require(x < 1 << 8);\\n\\n        y = uint8(x);\\n    }\\n}\\n\",\"keccak256\":\"0x636e0f18c1b287c9342e14660a914b37a927d9f64d6c29e27016784979ce8d59\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x333b56bef66ff71e3838910781df214acbeb6c2d6ace27a04ebb510f0e669300\",\"license\":\"AGPL-3.0-only\"},\"contracts/vaults/vault.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n\\nimport {Auth} from \\\"./auth/Auth.sol\\\";\\nimport {ERC4626} from \\\"./mixins/ERC4626.sol\\\";\\n\\nimport {SafeCastLib} from \\\"./utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"./utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./utils/FixedPointMathLib.sol\\\";\\n\\nimport {ERC20} from \\\"./tokens/ERC20.sol\\\";\\nimport {Instrument} from \\\"./instrument.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n\\ncontract Vault is ERC4626, Auth{\\n\\tusing SafeCastLib for uint256; \\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n\\n    event InstrumentDeposit(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\\n    event InstrumentWithdrawal(address indexed user, Instrument indexed instrument, uint256 underlyingAmount);\\n    event InstrumentTrusted(address indexed user, Instrument indexed instrument);\\n    event InstrumentDistrusted(address indexed user, Instrument indexed instrument);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                 CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal BASE_UNIT;\\n    uint256 totalInstrumentHoldings; //total holdings deposited into all Instruments \\n    ERC20 public immutable UNDERLYING;\\n\\n    mapping(Instrument => InstrumentData) public getInstrumentData;\\n    mapping(address => uint256) public  num_proposals;\\n    mapping(uint256=> Instrument) Instruments; //marketID-> Instrument\\n\\n    /// @param trusted Whether the Instrument is trusted.\\n    /// @param balance The amount of underlying tokens held in the Instrument.\\n    struct InstrumentData {\\n        // Used to determine if the Vault will operate on a Instrument.\\n        bool trusted;\\n        // Balance of the contract denominated in Underlying, \\n        // used to determine profit and loss during harvests of the Instrument.  \\n        // represents the amount of debt the Instrument has incurred from this vault   \\n        uint248 balance;\\n        uint256 faceValue;\\n        uint256 marketId;\\n    \\tuint256 principal; //this is total available allowance\\n        uint256 expectedYield; // total interest paid over duration\\n        uint256 duration;\\n        string description;\\n        address Instrument_address;    \\n    }\\n\\n    constructor(address _UNDERLYING)\\n        ERC4626(\\n            ERC20(_UNDERLYING),\\n            string(abi.encodePacked(\\\"debita \\\", ERC20(_UNDERLYING).name(), \\\" Vault\\\")),\\n            string(abi.encodePacked(\\\"db\\\", ERC20(_UNDERLYING).symbol()))\\n        )  Auth(msg.sender)\\n\\n    {\\n        UNDERLYING = ERC20(_UNDERLYING);\\n        BASE_UNIT = 10**ERC20(_UNDERLYING).decimals();\\n\\n        //totalSupply = type(uint256).max;\\n    }\\n\\n\\n    /// @notice Harvest a trusted Instrument, records profit/loss \\n    function harvest(Instrument instrument) external requiresAuth{\\n        require(getInstrumentData[instrument].trusted, \\\"UNTRUSTED_Instrument\\\");\\n    \\tuint256 oldTotalInstrumentHoldings = totalInstrumentHoldings; \\n        uint256 balanceLastHarvest = getInstrumentData[instrument].balance;\\n        uint256 balanceThisHarvest = instrument.balanceOfUnderlying(address(instrument));\\n        \\n        getInstrumentData[instrument].balance = balanceThisHarvest.safeCastTo248();\\n        uint256 profit = balanceThisHarvest - balanceLastHarvest; \\n\\n        totalInstrumentHoldings = oldTotalInstrumentHoldings + profit; \\n\\n    }\\n\\n    /// @notice Deposit a specific amount of float into a trusted Instrument.\\n   \\t/// Called when market is approved. \\n   \\t/// Also has the role of granting a credit line to a credit-based Instrument like uncol.loans \\n    function depositIntoInstrument(Instrument instrument, uint256 underlyingAmount) external requiresAuth{\\n    \\trequire(getInstrumentData[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n    \\ttotalInstrumentHoldings += underlyingAmount; \\n\\n        getInstrumentData[instrument].balance += underlyingAmount.safeCastTo248();\\n\\n        UNDERLYING.transfer(address(instrument), underlyingAmount);\\n        emit InstrumentDeposit(msg.sender, instrument, underlyingAmount);\\n\\n    }\\n\\n    /// @notice Withdraw a specific amount of underlying tokens from a Instrument.\\n    function withdrawFromInstrument(Instrument instrument, uint256 underlyingAmount) external requiresAuth{\\n    \\trequire(getInstrumentData[instrument].trusted, \\\"UNTRUSTED Instrument\\\");\\n        getInstrumentData[instrument].balance -= underlyingAmount.safeCastTo248();\\n        totalInstrumentHoldings -= underlyingAmount;\\n        require(instrument.redeemUnderlying(underlyingAmount), \\\"REDEEM_FAILED\\\");\\n        emit InstrumentWithdrawal(msg.sender, instrument, underlyingAmount);\\n\\n    }\\n\\n\\n    /// @notice Withdraws all underyling balance from the Instrument to the vault \\n    function withdrawAllFromInstrument(Instrument instrument) external requiresAuth{\\n    \\tuint248 total_Instrument_balance = instrument.balanceOfUnderlying(address(instrument)).safeCastTo248();\\n    \\tuint248 current_balance =  getInstrumentData[instrument].balance;\\n    \\tgetInstrumentData[instrument].balance -= Math.min(total_Instrument_balance, current_balance).safeCastTo248();\\n    \\tinstrument.redeemUnderlying(total_Instrument_balance);\\n\\n    }\\n\\n    /// @notice Stores a Instrument as trusted when its approved\\n    function trustInstrument(Instrument instrument) external requiresAuth{\\n    \\tgetInstrumentData[instrument].trusted = true;\\n\\n    }\\n\\n    /// @notice Stores a Instrument as untrusted\\n    function distrustInstrument(Instrument instrument) external requiresAuth{\\n    \\tgetInstrumentData[instrument].trusted = false; \\n    }\\n\\n\\n    /// @notice returns true if Instrument is approved\\n    function isTrusted(Instrument instrument) public view returns(bool){\\n    \\treturn getInstrumentData[instrument].trusted; \\n    }\\n\\n    /// @notice Calculates the total amount of underlying tokens the Vault holds, excluding profit \\n    function totalAssets() public view override returns(uint256){\\n    \\treturn totalInstrumentHoldings + totalFloat();\\n    }\\n\\n   \\t\\n    function totalFloat() public view returns (uint256) {\\n        return UNDERLYING.balanceOf(address(this));\\n    }\\n\\n    function fetchInstrumentData(uint256 marketId) public view returns(InstrumentData memory){\\n        return getInstrumentData[Instruments[marketId]];\\n    }\\n\\n    /// @notice add instrument proposal created by the Utilizer \\n    /// @dev Instrument instance should be created before this is called \\n    function addProposal(\\n        InstrumentData memory data\\n    ) external {\\n        require(data.principal > 0, \\\"principal must be greater than 0\\\");\\n        require(data.duration > 0, \\\"duration must be greater than 0\\\");\\n        require(data.faceValue > 0, \\\"faceValue must be greater than 0\\\");\\n        require(data.principal >= BASE_UNIT, \\\"Needs to be in decimal format\\\"); // should be collateral address, not DS. Can't be less than 1.0 X?\\n   \\n\\n        num_proposals[msg.sender] ++; \\n        getInstrumentData[Instrument(data.Instrument_address)] = (\\n        \\tInstrumentData(\\n        \\t\\tfalse, \\n                0, \\n                data.faceValue, \\n                data.marketId, \\n                data.principal, \\n                data.expectedYield, \\n                data.duration, \\n                data.description, \\n                data.Instrument_address\\n            )\\n        \\t); \\n\\n        Instruments[data.marketId] = Instrument(data.Instrument_address);\\n    }\\n}\",\"keccak256\":\"0x1e8d0114720703c084d263e80e31f3a3a2336c1b42d052bf00d390d29b8b4bf7\"},\"contracts/vaults/vault_tranche/splitter.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n\\nimport {Auth} from \\\"../auth/Auth.sol\\\";\\nimport {ERC4626} from \\\"../mixins/ERC4626.sol\\\";\\n\\nimport {SafeCastLib} from \\\"../utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {Instrument} from \\\"../instrument.sol\\\";\\nimport {tVault} from \\\"./tVault.sol\\\"; \\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n\\n\\n\\n/// @notice tokens for junior/senior tranches \\ncontract tToken is ERC20{\\n\\n\\tmodifier onlySplitter() {\\n        require(msg.sender == splitter, \\\"!Splitter\\\");\\n        _;\\n    }\\n\\n    address splitter; \\n    ERC20 asset; \\n\\n    /// @notice asset is the tVault  \\n    constructor(\\n        ERC20 _asset, \\n        string memory _name,\\n        string memory _symbol, \\n        address _splitter\\n    ) ERC20(_name, _symbol, _asset.decimals()) {\\n        asset = _asset;\\n        splitter = _splitter; \\n    }\\n\\n    function mint(address to, uint256 amount) external onlySplitter{\\n    \\t_mint(to, amount); \\n    }\\n\\n    function burn(address from, uint256 amount) external onlySplitter{\\n    \\t_burn(from, amount);\\n    }\\n\\n\\n}\\n\\n/// @notice Accepts ERC20 and splits them into senior/junior tokens\\n/// Will hold the ERC20 token in this contract\\n/// Before maturity, redemption only allowed for a pair, \\n/// After maturity, redemption allowed for individual tranche tokens, with the determined conversion rate\\n/// @dev new instance is generated for each vault\\ncontract Splitter{\\n\\tusing SafeCastLib for uint256; \\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    tVault underlying; \\n    tToken senior;\\n    tToken junior;  \\n\\n    //weight is in PRICE_PRECISION 6, i.e 5e5 = 0.5\\n    uint256 junior_weight; \\n    uint256 PRICE_PRECISION; \\n    uint promised_return; \\n\\n\\n    //Redemption Prices \\n    uint256 s_r; \\n    uint256 j_r; \\n\\n    constructor(\\n    \\ttVault _underlying //underlying vault token to split \\n    \\t){\\n    \\tunderlying = _underlying; \\n    \\tsenior = new tToken(_underlying, \\\"senior\\\", string(abi.encodePacked(\\\"se_\\\", _underlying.symbol())), address(this));\\n    \\tjunior = new tToken(_underlying, \\\"junior\\\", string(abi.encodePacked(\\\"ju_\\\", _underlying.symbol())), address(this));\\n\\n    \\tjunior_weight = underlying.getJuniorWeight(); \\n    \\tpromised_return = underlying.getPromisedReturn(); \\n    \\tPRICE_PRECISION = underlying.PRICE_PRECISION(); \\n    }\\n\\n\\t/// @notice accepts token_to_split and mints s,j tokens\\n\\t/// ex. 1 vault token-> 0.3 junior and 0.7 senior for weight of 0.3, 0.7\\n\\tfunction split(ERC20 token_to_split, uint256 amount) external returns(uint, uint) {\\n\\t\\trequire(token_to_split == underlying, \\\"Wrong Splitter\\\");\\n\\n\\t\\ttoken_to_split.safeTransferFrom(msg.sender, address(this), amount); \\n\\n\\t\\tuint junior_token_mint_amount = (amount * junior_weight)/PRICE_PRECISION;  \\n\\t\\tuint senior_token_mint_amount = amount - junior_token_mint_amount; \\n\\n\\t\\tjunior.mint(msg.sender, junior_token_mint_amount); \\n\\t\\tsenior.mint(msg.sender, senior_token_mint_amount);\\n\\n\\t\\treturn (junior_token_mint_amount, senior_token_mint_amount); \\n\\n\\t}\\n\\n\\t/// @notice aceepts junior and senior token and gives back token_to_merge(tVault tokens)\\n\\t/// Function to call when redeeming before maturity\\n\\t/// @param token_to_merge is the valut token\\n\\t/// @param junior_amount is amount of junior tokens user want to redeem\\n\\t/// @dev senior amount is automiatically computed when given junior amount \\n\\tfunction merge(ERC20 token_to_merge, uint256 junior_amount) external returns(uint){\\n\\t\\trequire(token_to_merge == underlying, \\\"Wrong Splitter\\\");\\n\\t\\tuint senior_multiplier = (PRICE_PRECISION *(PRICE_PRECISION - junior_weight))/junior_weight; //ex 2.3e6\\n\\t\\tuint senior_amount = (senior_multiplier * junior_amount)/PRICE_PRECISION; \\n\\t\\trequire(senior.balanceOf(msg.sender) >= senior_amount, \\\"Not enough senior tokens\\\"); \\n\\n\\t\\tjunior.burn(msg.sender, junior_amount);\\n\\t\\tsenior.burn(msg.sender, senior_amount);\\n\\t\\tunderlying.transfer(msg.sender, junior_amount+senior_amount); \\n\\t\\treturn junior_amount + senior_amount; \\n\\t}\\n\\n\\n\\t/// @notice only can called after set maturity by tranche token holders\\n\\tfunction redeem_after_maturity(tToken _tToken, uint256 amount) external {\\n\\t\\trequire(underlying.isMatured(), \\\"Vault not matured\\\");\\n\\t\\trequire(address(_tToken) == address(senior) || address(_tToken) == address(junior), \\\"Wrong Tranche Token\\\");\\n\\t\\tbool isSenior = (address(_tToken) == address(senior)) ? true : false; \\n\\t\\tuint redemption_price = isSenior? s_r: j_r; \\n\\t\\tuint token_redeem_amount = (redemption_price * amount)/PRICE_PRECISION; \\n\\n\\t\\t_tToken.burn(msg.sender, amount); \\n\\t\\tunderlying.transfer(msg.sender, token_redeem_amount); \\n\\t\\t\\n\\t}\\n\\n\\n\\t/// @notice calculate and store redemption Price for post maturity \\n\\t/// @dev should be only called once right after tToken matures, as totalSupply changes when redeeming \\n\\tfunction calcRedemptionPrice() private {\\n\\t\\tuint promised_return = underlying.getPromisedReturn(); //in 1e6 decimals i.e 5000 is 0.05\\n\\t\\tuint real_return = underlying.getCurrentRealReturn(); \\n\\t\\tuint _s_r = ((PRICE_PRECISION + promised_return)/(PRICE_PRECISION+real_return)) * PRICE_PRECISION; \\n\\t\\tuint max_s_r = (PRICE_PRECISION/(PRICE_PRECISION - junior_weight)) *PRICE_PRECISION; \\n\\t\\t\\n\\t\\ts_r = min(_s_r, max_s_r);\\n\\t\\t//total supply right after tVault matures \\n\\t\\tj_r = (underlying.totalSupply() - (senior.totalSupply() * s_r/PRICE_PRECISION))/(junior.totalSupply()); \\n\\n\\t}\\n\\n\\t/// @dev need to return in list format to index it easily \\n\\t/// 0 is always senior \\n\\tfunction getTrancheTokens() public view returns(address[] memory){\\n \\t\\taddress[] memory addresses = new address[](2);\\n \\t\\taddresses[0] =  address(senior); \\n \\t\\taddresses[1] =  address(junior); \\n\\t\\treturn addresses; \\n\\t}\\n\\n\\n\\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    \\treturn a >= b ? a : b;\\n\\t}\\n\\n\\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    \\treturn a <= b ? a : b;\\n\\t}\\n}\",\"keccak256\":\"0x572487c0cfe58c0818fc72792233ace06e094265c3ba7a8de697b22365a9bbe6\"},\"contracts/vaults/vault_tranche/stableswap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8;\\n\\n/*\\nInvariant - price of trade and amount of liquidity are determined by this equation\\n\\nAn^n sum(x_i) + D = ADn^n + D^(n + 1) / (n^n prod(x_i))\\n\\nTopics\\n0. Newton's method x_(n + 1) = x_n - f(x_n) / f'(x_n)\\n1. Invariant\\n2. Swap\\n   - Calculate Y\\n   - Calculate D\\n3. Get virtual price\\n4. Add liquidity\\n   - Imbalance fee\\n5. Remove liquidity\\n6. Remove liquidity one token\\n   - Calculate withdraw one token\\n   - getYD\\nTODO: test?\\n*/\\n\\nlibrary Math {\\n    function abs(uint x, uint y) internal pure returns (uint) {\\n        return x >= y ? x - y : y - x;\\n    }\\n}\\n\\ncontract StableSwap {\\n    // Number of tokens\\n    uint private constant N = 2;\\n    // Amplification coefficient multiplied by N^(N - 1)\\n    // Higher value makes the curve more flat\\n    // Lower value makes the curve more like constant product AMM\\n    uint private constant A = 1000 * (N**(N - 1));\\n    // 0.03%\\n    uint private constant SWAP_FEE = 300;\\n    // Liquidity fee is derived from 2 constraints\\n    // 1. Fee is 0 for adding / removing liquidity that results in a balanced pool\\n    // 2. Swapping in a balanced pool is like adding and then removing liquidity\\n    //    from a balanced pool\\n    // swap fee = add liquidity fee + remove liquidity fee\\n    uint private constant LIQUIDITY_FEE = (SWAP_FEE * N) / (4 * (N - 1));\\n    uint private constant FEE_DENOMINATOR = 1e6;\\n\\n    address[N] public tokens;\\n    // Normalize each token to 18 decimals\\n    // Example - DAI (18 decimals), USDC (6 decimals), USDT (6 decimals)\\n    //uint[N] private multipliers = [1, 1e12, 1e12];\\n    uint[N] private multipliers = [1, 1];\\n\\n    uint[N] public balances;\\n\\n    // 1 share = 1e18, 18 decimals\\n    uint private constant DECIMALS = 18;\\n    uint public totalSupply;\\n    mapping(address => uint) public balanceOf;\\n\\n    function _mint(address _to, uint _amount) private {\\n        balanceOf[_to] += _amount;\\n        totalSupply += _amount;\\n    }\\n\\n    function _burn(address _from, uint _amount) private {\\n        balanceOf[_from] -= _amount;\\n        totalSupply -= _amount;\\n    }\\n\\n\\n    // Return precision-adjusted balances, adjusted to 18 decimals\\n    function _xp() private view returns (uint[N] memory xp) {\\n        for (uint i; i < N; ++i) {\\n            xp[i] = balances[i] * multipliers[i];\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate D, sum of balances in a perfectly balanced pool\\n     * If balances of x_0, x_1, ... x_(n-1) then sum(x_i) = D\\n     * @param xp Precision-adjusted balances\\n     * @return D\\n     */\\n    function _getD(uint[N] memory xp) private pure returns (uint) {\\n        /*\\n        Newton's method to compute D\\n        -----------------------------\\n        f(D) = ADn^n + D^(n + 1) / (n^n prod(x_i)) - An^n sum(x_i) - D \\n        f'(D) = An^n + (n + 1) D^n / (n^n prod(x_i)) - 1\\n\\n                     (as + np)D_n\\n        D_(n+1) = -----------------------\\n                  (a - 1)D_n + (n + 1)p\\n\\n        a = An^n\\n        s = sum(x_i)\\n        p = (D_n)^(n + 1) / (n^n prod(x_i))\\n        */\\n        uint a = A * N; // An^n\\n\\n        uint s; // x_0 + x_1 + ... + x_(n-1)\\n        for (uint i; i < N; ++i) {\\n            s += xp[i];\\n        }\\n\\n        // Newton's method\\n        // Initial guess, d <= s\\n        uint d = s;\\n        uint d_prev;\\n        for (uint i; i < 255; ++i) {\\n            // p = D^(n + 1) / (n^n * x_0 * ... * x_(n-1))\\n            uint p = d;\\n            for (uint j; j < N; ++j) {\\n                p = (p * d) / (N * xp[j]);\\n            }\\n            d_prev = d;\\n            d = ((a * s + N * p) * d) / ((a - 1) * d + (N + 1) * p);\\n\\n            if (Math.abs(d, d_prev) <= 1) {\\n                return d;\\n            }\\n        }\\n        revert(\\\"D didn't converge\\\");\\n    }\\n\\n\\n   /**\\n    * @notice Calculate required dx to get dy\\n    * @param indexX is the index of the tokenIn\\n    * @dev only works in binary settins for now, indexX is 0 if senior, 1 if junior \\n    * y is tokenOut, so dy should be subtracted, x is tokenIn, so should be added\\n    */\\n\\n    function getDx(\\n        uint dy,\\n        uint indexX\\n        ) \\n    public view returns(uint){\\n        uint[N] memory xp = _xp(); \\n        uint xamount = xp[indexX]; \\n        uint yamount = xp[1-indexX]; \\n\\n        uint new_yamount = yamount - dy; \\n\\n        uint new_xamount = _getY(1-indexX, indexX, new_yamount, xp); \\n        uint dx = new_xamount - xamount; \\n        return dx; \\n    }\\n    \\n    /**\\n     * @notice Calculate the new balance of token j given the new balance of token i\\n     * @param i Index of token in\\n     * @param j Index of token out\\n     * @param x New balance of token i\\n     * @param xp Current precision-adjusted balances\\n     */\\n    function _getY(\\n        uint i,\\n        uint j,\\n        uint x,\\n        uint[N] memory xp\\n    ) private pure returns (uint) {\\n        /*\\n        Newton's method to compute y\\n        -----------------------------\\n        y = x_j\\n\\n        f(y) = y^2 + y(b - D) - c\\n\\n                    y_n^2 + c\\n        y_(n+1) = --------------\\n                   2y_n + b - D\\n\\n        where\\n        s = sum(x_k), k != j\\n        p = prod(x_k), k != j\\n        b = s + D / (An^n)\\n        c = D^(n + 1) / (n^n * p * An^n)\\n        */\\n        uint a = A * N;\\n        uint d = _getD(xp);\\n        uint s;\\n        uint c = d;\\n\\n        uint _x;\\n        for (uint k; k < N; ++k) {\\n            if (k == i) {\\n                _x = x;\\n            } else if (k == j) {\\n                continue;\\n            } else {\\n                _x = xp[k];\\n            }\\n\\n            s += _x;\\n            c = (c * d) / (N * _x);\\n        }\\n        c = (c * d) / (N * a);\\n        uint b = s + d / a;\\n\\n        // Newton's method\\n        uint y_prev;\\n        // Initial guess, y <= d\\n        uint y = d;\\n        for (uint _i; _i < 255; ++_i) {\\n            y_prev = y;\\n            y = (y * y + c) / (2 * y + b - d);\\n            if (Math.abs(y, y_prev) <= 1) {\\n                return y;\\n            }\\n        }\\n        revert(\\\"y didn't converge\\\");\\n    }\\n\\n    /**\\n     * @notice Calculate the new balance of token i given precision-adjusted\\n     * balances xp and liquidity d\\n     * @dev Equation is calculate y is same as _getY\\n     * @param i Index of token to calculate the new balance\\n     * @param xp Precision-adjusted balances\\n     * @param d Liquidity d\\n     * @return New balance of token i\\n     */\\n    function _getYD(\\n        uint i,\\n        uint[N] memory xp,\\n        uint d\\n    ) private pure returns (uint) {\\n        uint a = A * N;\\n        uint s;\\n        uint c = d;\\n\\n        uint _x;\\n        for (uint k; k < N; ++k) {\\n            if (k != i) {\\n                _x = xp[k];\\n            } else {\\n                continue;\\n            }\\n\\n            s += _x;\\n            c = (c * d) / (N * _x);\\n        }\\n        c = (c * d) / (N * a);\\n        uint b = s + d / a;\\n\\n        // Newton's method\\n        uint y_prev;\\n        // Initial guess, y <= d\\n        uint y = d;\\n        for (uint _i; _i < 255; ++_i) {\\n            y_prev = y;\\n            y = (y * y + c) / (2 * y + b - d);\\n            if (Math.abs(y, y_prev) <= 1) {\\n                return y;\\n            }\\n        }\\n        revert(\\\"y didn't converge\\\");\\n    }\\n\\n    // Estimate value of 1 share\\n    // How many tokens is one share worth?\\n    function getVirtualPrice() external view returns (uint) {\\n        uint d = _getD(_xp());\\n        uint _totalSupply = totalSupply;\\n        if (_totalSupply > 0) {\\n            return (d * 10**DECIMALS) / _totalSupply;\\n        }\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Swap dx amount of token i for token j\\n     * @param i Index of token in\\n     * @param j Index of token out\\n     * @param dx Token in amount\\n     * @param minDy Minimum token out\\n     */\\n    function swap(\\n        uint i,\\n        uint j,\\n        uint dx,\\n        uint minDy\\n    ) external returns (uint dy) {\\n        require(i != j, \\\"i = j\\\");\\n\\n        IERC20(tokens[i]).transferFrom(msg.sender, address(this), dx);\\n\\n        // Calculate dy\\n        uint[N] memory xp = _xp();\\n        uint x = xp[i] + dx * multipliers[i];\\n\\n        uint y0 = xp[j];\\n        uint y1 = _getY(i, j, x, xp);\\n        // y0 must be >= y1, since x has increased\\n        // -1 to round down\\n        dy = (y0 - y1 - 1) / multipliers[j];\\n\\n        // Subtract fee from dy\\n        uint fee = (dy * SWAP_FEE) / FEE_DENOMINATOR;\\n        dy -= fee;\\n        require(dy >= minDy, \\\"dy < min\\\");\\n\\n        balances[i] += dx;\\n        balances[j] -= dy;\\n\\n        IERC20(tokens[j]).transfer(msg.sender, dy);\\n    }\\n\\n    function addLiquidity(uint[N] calldata amounts, uint minShares)\\n        external\\n        returns (uint shares)\\n    {\\n        // calculate current liquidity d0\\n        uint _totalSupply = totalSupply;\\n        uint d0;\\n        uint[N] memory old_xs = _xp();\\n        if (_totalSupply > 0) {\\n            d0 = _getD(old_xs);\\n        }\\n\\n        // Transfer tokens in\\n        uint[N] memory new_xs;\\n        for (uint i; i < N; ++i) {\\n            uint amount = amounts[i];\\n            if (amount > 0) {\\n                IERC20(tokens[i]).transferFrom(msg.sender, address(this), amount);\\n                new_xs[i] = old_xs[i] + amount * multipliers[i];\\n            } else {\\n                new_xs[i] = old_xs[i];\\n            }\\n        }\\n\\n        // Calculate new liquidity d1\\n        uint d1 = _getD(new_xs);\\n        require(d1 > d0, \\\"liquidity didn't increase\\\");\\n\\n        // Reccalcuate D accounting for fee on imbalance\\n        uint d2;\\n        if (_totalSupply > 0) {\\n            for (uint i; i < N; ++i) {\\n                // TODO: why old_xs[i] * d1 / d0? why not d1 / N?\\n                uint idealBalance = (old_xs[i] * d1) / d0;\\n                uint diff = Math.abs(new_xs[i], idealBalance);\\n                new_xs[i] -= (LIQUIDITY_FEE * diff) / FEE_DENOMINATOR;\\n            }\\n\\n            d2 = _getD(new_xs);\\n        } else {\\n            d2 = d1;\\n        }\\n\\n        // Update balances\\n        for (uint i; i < N; ++i) {\\n            balances[i] += amounts[i];\\n        }\\n\\n        // Shares to mint = (d2 - d0) / d0 * total supply\\n        // d1 >= d2 >= d0\\n        if (_totalSupply > 0) {\\n            shares = ((d2 - d0) * _totalSupply) / d0;\\n        } else {\\n            shares = d2;\\n        }\\n        require(shares >= minShares, \\\"shares < min\\\");\\n        _mint(msg.sender, shares);\\n    }\\n\\n    function removeLiquidity(uint shares, uint[N] memory minAmountsOut)\\n        external\\n        returns (uint[N] memory amountsOut)\\n    {\\n        uint _totalSupply = totalSupply;\\n\\n        for (uint i; i < N; ++i) {\\n            uint amountOut = (balances[i] * shares) / _totalSupply;\\n            require(amountOut >= minAmountsOut[i], \\\"out < min\\\");\\n\\n            balances[i] -= amountOut;\\n            amountsOut[i] = amountOut;\\n\\n            IERC20(tokens[i]).transfer(msg.sender, amountOut);\\n        }\\n\\n        _burn(msg.sender, shares);\\n    }\\n\\n    /**\\n     * @notice Calculate amount of token i to receive for shares\\n     * @param shares Shares to burn\\n     * @param i Index of token to withdraw\\n     * @return dy Amount of token i to receive\\n     *         fee Fee for withdraw. Fee already included in dy\\n     */\\n    function _calcWithdrawOneToken(uint shares, uint i)\\n        private\\n        view\\n        returns (uint dy, uint fee)\\n    {\\n        uint _totalSupply = totalSupply;\\n        uint[N] memory xp = _xp();\\n\\n        // Calculate d0 and d1\\n        uint d0 = _getD(xp);\\n        uint d1 = d0 - (d0 * shares) / _totalSupply;\\n\\n        // Calculate reduction in y if D = d1\\n        uint y0 = _getYD(i, xp, d1);\\n        // d1 <= d0 so y must be <= xp[i]\\n        uint dy0 = (xp[i] - y0) / multipliers[i];\\n\\n        // Calculate imbalance fee, update xp with fees\\n        uint dx;\\n        for (uint j; j < N; ++j) {\\n            if (j == i) {\\n                dx = (xp[j] * d1) / d0 - y0;\\n            } else {\\n                // d1 / d0 <= 1\\n                dx = xp[j] - (xp[j] * d1) / d0;\\n            }\\n            xp[j] -= (LIQUIDITY_FEE * dx) / FEE_DENOMINATOR;\\n        }\\n\\n        // Recalculate y with xp including imbalance fees\\n        uint y1 = _getYD(i, xp, d1);\\n        // - 1 to round down\\n        dy = (xp[i] - y1 - 1) / multipliers[i];\\n        fee = dy0 - dy;\\n    }\\n\\n    function calcWithdrawOneToken(uint shares, uint i)\\n        external\\n        view\\n        returns (uint dy, uint fee)\\n    {\\n        return _calcWithdrawOneToken(shares, i);\\n    }\\n\\n    /**\\n     * @notice Withdraw liquidity in token i\\n     * @param shares Shares to burn\\n     * @param i Token to withdraw\\n     * @param minAmountOut Minimum amount of token i that must be withdrawn\\n     */\\n    function removeLiquidityOneToken(\\n        uint shares,\\n        uint i,\\n        uint minAmountOut\\n    ) external returns (uint amountOut) {\\n        (amountOut, ) = _calcWithdrawOneToken(shares, i);\\n        require(amountOut >= minAmountOut, \\\"out < min\\\");\\n\\n        balances[i] -= amountOut;\\n        _burn(msg.sender, shares);\\n\\n        IERC20(tokens[i]).transfer(msg.sender, amountOut);\\n    }\\n\\n\\n\\n\\n\\n    function xp() public view returns(uint[N] memory){\\n        return _xp(); \\n    }\\n\\n\\n\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint);\\n\\n    function balanceOf(address account) external view returns (uint);\\n\\n    function transfer(address recipient, uint amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint amount);\\n    event Approval(address indexed owner, address indexed spender, uint amount);\\n}\",\"keccak256\":\"0x7b0e970018bdfeae8a7e2e9d6c5ff250fbf85e203516c63ad56268d8d03ce3be\",\"license\":\"MIT\"},\"contracts/vaults/vault_tranche/tVault.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n\\nimport {Auth} from \\\"../auth/Auth.sol\\\";\\nimport {ERC4626} from \\\"../mixins/ERC4626.sol\\\";\\n\\nimport {SafeCastLib} from \\\"../utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {Instrument} from \\\"../instrument.sol\\\";\\nimport {Vault} from \\\"../vault.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport {TrancheFactory} from \\\"./tranchemaster.sol\\\"; \\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @notice super vault that accepts any combinations of ERC4626 instruments at initialization, and will\\n/// automatically invest/divest when minting/redeeming \\n/// @dev instance is generated for every splitter\\ncontract tVault is ERC4626{\\n\\tusing SafeCastLib for uint256; \\n    using SafeTransferLib for ERC20;\\n    using FixedPointMathLib for uint256;\\n\\n    uint256 num_instrument; \\n    uint256[] ratios; \\n    address[] instruments; \\n    uint256 init_time; \\n    uint256 junior_weight; \\n    uint256 promisedReturn; \\n    uint256 time_to_maturity; \\n    ERC20 want; \\n\\n    mapping(address=>uint256) addressToIndex; \\n\\n    uint256[] initial_exchange_rates; \\n\\n    uint256 public PRICE_PRECISION; \\n\\n    /// @notice when intialized, will take in a few ERC4626 instruments (address) as base instruments\\n    /// param _want is the base assets for all the instruments e.g usdc\\n    /// param _instruments are ERC4626 addresses that will comprise this super vault\\n    /// param _ratios are the weight of value invested for each instruments, should sum to 1 \\n    /// param _junior_weight is the allocation between junior/senior tranche (senior is 1-junior)\\n    /// param _time_to_maturity is time until the tranche tokens redemption price will be determined\\n    /// and tranche tokens can be redeemed separately \\n    /// param _promisedReturn is the promised senior return gauranteed by junior holders \\n    constructor(\\n        TrancheFactory.InitParams memory param)\\n        ERC4626(\\n            ERC20(param._want),\\n            string(abi.encodePacked(\\\"super \\\", ERC20(param._want).name(), \\\" Vault\\\")),\\n            string(abi.encodePacked(\\\"t\\\", ERC20(param._want).symbol()))\\n        )  \\n    \\t//Vault(address(_want))\\n    {\\n        want = ERC20(param._want); \\n        instruments = param._instruments; \\n        num_instrument = param._instruments.length; \\n        ratios = param._ratios; \\n        junior_weight = param._junior_weight; \\n        promisedReturn = param._promisedReturn; \\n        time_to_maturity = param._time_to_maturity; \\n        init_time = block.timestamp; \\n\\n        initial_exchange_rates = new uint[](num_instrument); \\n        PRICE_PRECISION = 10**want.decimals(); \\n\\n        //need to get initial exchange rate between the instruments and want \\n        for (uint i=0; i< num_instrument; i++){\\n            addressToIndex[instruments[i]] = i; \\n            initial_exchange_rates[i] = get_exchange_rate(instruments[i]); \\n        }\\n    }\\n\\n\\n    /// @notice get the amount of shares for the instrument one would obtain\\n    /// by depositing one want token \\n    function get_exchange_rate(address instrument) internal view returns(uint256){\\n    \\treturn ERC4626(instrument).previewDeposit(PRICE_PRECISION); \\n    }\\n\\n    /// @notice will automatically invest into the ERC4626 instruments and give out \\n    /// vault tokens as share\\n    function mint(uint256 shares, address receiver) public override returns(uint assets)  {\\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\\n        console.log('here', msg.sender);\\n\\n        asset.safeTransferFrom(msg.sender, address(this), assets);\\n        invest(shares); \\n\\n        _mint(receiver, shares);\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n        afterDeposit(assets, shares);\\n\\n    }\\n\\n\\n    /// @notice will automatically divest from the instruments\\n    function redeem(\\n        uint256 shares,\\n        address receiver,\\n        address owner\\n    ) public override returns(uint assets){\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        // Check for rounding error since we round down in previewRedeem.\\n        require((assets = previewRedeem(shares)) != 0, \\\"ZERO_ASSETS\\\");\\n        divest(assets); \\n\\n        beforeWithdraw(assets, shares);\\n        _burn(owner, shares);\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n        asset.safeTransfer(receiver, assets);\\n\\n    }\\n\\n    /// @notice will invest into the current instruments, which is equivalent to minting erc4626\\n    /// @param shares are denominated in vault token, in PRICE_PRECISION\\n    function invest(uint256 shares) internal {\\n    \\t\\n    \\tuint num_asset_for_this; \\n    \\tfor (uint i=0; i< num_instrument; i++){\\n    \\t\\tnum_asset_for_this = convertToAssets((shares*ratios[i])/PRICE_PRECISION);  \\n            asset.safeApprove(instruments[i], num_asset_for_this); \\n    \\t\\tuint receivedShares = ERC4626(instruments[i]).deposit(num_asset_for_this, address(this)); //will mint the instrument to this contract\\n    \\t}\\n    }\\n\\n    /// @notice will divest from current instruments, which is equivalent to redeeming erc4626\\n    /// @param assets are denominated in underlying token\\n    function divest(uint256 assets) internal{\\n    \\tuint num_assets_for_this; \\n    \\tfor (uint i=0; i< num_instrument; i++){\\n    \\t\\tnum_assets_for_this = (assets* ratios[i]/PRICE_PRECISION); \\n    \\t\\tERC4626(instruments[i]).withdraw(num_assets_for_this, address(this), address(this)); \\n    \\t}\\n\\n    }\\n\\n\\n    function isMatured() public view returns(bool){\\n    \\treturn (block.timestamp - init_time) > time_to_maturity; \\n    }\\n\\n    function getUnderlying() public view returns(address){\\n    \\treturn address(want); \\n    }\\n\\n    function getJuniorWeight() public view returns(uint256){\\n    \\treturn junior_weight; \\n    }\\n\\n    function getPromisedReturn() public view returns(uint256){\\n    \\treturn promisedReturn; \\n    }\\n    function getInitialExchangeRates() public view returns(uint[] memory){\\n        return initial_exchange_rates; \\n    }\\n\\n    /// @notice get average real returns collected by the vault in this supervault until now  \\n    /// real return is computed by (final_value_of_vault/initial_value_of_vault) - 1\\n    function getCurrentRealReturn() public view returns(uint256){\\n    \\tuint256[] memory real_returns = new uint256[](num_instrument); \\n    \\tuint256 sum_return; \\n    \\tfor (uint i=0; i< num_instrument; i++){\\n    \\t\\treal_returns[i] = (get_exchange_rate(instruments[i])/initial_exchange_rates[i])*PRICE_PRECISION;\\n    \\t\\tsum_return += real_returns[i] - PRICE_PRECISION; \\n\\t\\t}\\n\\n\\t\\treturn (sum_return/num_instrument); \\n\\t\\t\\n    }\\n\\n    /// @notice sums over all assets in want tokens \\n    function totalAssets() public view override returns (uint256){\\n        uint sumAssets; \\n        for (uint i=0; i< num_instrument; i++){\\n            sumAssets += ERC4626(instruments[i]).totalAssets(); \\n        }\\n        return sumAssets; \\n\\n    }\\n\\n\\n \\n\\n}\\n\",\"keccak256\":\"0xbbbc59c512a80dff2d41374a700218c626ad701456a1b711245306b3e36ae7bc\"},\"contracts/vaults/vault_tranche/tranchemaster.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n\\nimport {Auth} from \\\"../auth/Auth.sol\\\";\\nimport {ERC4626} from \\\"../mixins/ERC4626.sol\\\";\\n\\nimport {SafeCastLib} from \\\"../utils/SafeCastLib.sol\\\";\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"../utils/FixedPointMathLib.sol\\\";\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\nimport {Splitter} from \\\"./splitter.sol\\\";\\nimport {tVault} from \\\"./tVault.sol\\\";\\nimport {StableSwap} from \\\"./stableswap.sol\\\"; \\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/// @notice have to separate factories because of code size limit \\ncontract TrancheAMMFactory{\\n\\n\\tfunction newPool() external returns(address){\\n\\t\\tStableSwap amm = new StableSwap(); \\n\\t\\treturn address(amm); \\n\\t}\\n} \\n\\n\\n/// @notice contract that stores the contracts and liquidity for each tranches \\ncontract TrancheFactory{\\n\\n\\tuint256 numVaults; \\n    address owner; \\n\\n    TrancheAMMFactory ammFactory; \\n\\n\\t/// @notice initialization parameters for the vault\\n\\tstruct InitParams{\\n\\t\\taddress _want; \\n    \\taddress[]  _instruments;\\n    \\tuint256[]  _ratios;\\n    \\tuint256 _junior_weight; \\n    \\tuint256 _promisedReturn; \\n    \\tuint256 _time_to_maturity;\\n    \\tuint256 vaultId; \\n\\t}\\n\\n\\tstruct Contracts{\\n\\t\\taddress vault; \\n\\t\\taddress splitter; \\n\\t\\taddress amm; \\n\\t\\tInitParams param; \\n\\t}\\n\\n\\tmapping(uint256=>Contracts) vaultContracts;\\n\\tmapping(uint256=>mapping(address=>uint256)) lp_holdings;  //vaultId-> LP holdings for providrers\\n\\n    constructor(\\n        address _owner, \\n        address ammFactory_address\\n    ) public {\\n        owner = _owner;\\n        ammFactory = TrancheAMMFactory(ammFactory_address); \\n\\n    }\\n\\n\\n\\n\\t/// @notice adds vaults, spllitters, and amms when tranche bids are filled \\n\\t/// Bidders have to specify the \\n\\t/// param want: underlying token for all the vaults e.g(usdc,eth)\\n\\t/// param instruments: addresses of all vaults for the want they want exposure to\\n\\t/// param ratios: how much they want to split between the instruments \\n\\t/// param junior weight: how much the juniors are allocated; lower means higher leverage for juniors but lower safety for seniors\\n\\t/// param promisedReturn: how much fixed income seniors are getting paid primarily, \\n\\t/// param timetomaturity: when the tVault matures and tranche token holders can redeem their tranche for tVault \\n\\t/// @dev a bid is filled when liquidity provider agrees to provide initial liq for senior/junior or vice versa.  \\n\\t/// so initial liq should be provided nonetheless \\n\\tfunction createVault(InitParams memory param) public {\\n\\n\\t\\ttVault newvault = new tVault(param); \\n\\t\\tSplitter splitter = new Splitter(newvault);\\n\\t\\taddress amm_ad = ammFactory.newPool(); \\n\\n\\t\\tuint vaultId = param.vaultId; \\n\\t\\tContracts storage contracts = vaultContracts[vaultId]; \\n\\t\\tcontracts.vault = address(newvault); \\n\\t\\tcontracts.splitter = address(splitter);\\n\\t\\tcontracts.amm = amm_ad; \\n\\t\\tcontracts.param = param;\\n\\n\\n\\t\\tnumVaults++; \\n\\t}\\t\\n\\n\\n\\t/// @notice lp token balance is stored in this contract\\n\\tfunction increaseLPTokenBalance(address to, uint vaultId, uint lpshares) external{\\n\\t\\tlp_holdings[vaultId][to] += lpshares; \\n\\t}\\n\\tfunction decreaseLPTokenBalance(address to, uint vaultId, uint lpshares) external{\\n\\t\\tlp_holdings[vaultId][to] -= lpshares; \\n\\t}\\n\\n\\tfunction getContracts(uint vaultId) external view returns(Contracts memory){\\n\\t\\treturn vaultContracts[vaultId]; \\n\\t}\\n\\n\\tfunction getLPTokenBalance(address to, uint vaultId) external view returns(uint256){\\n\\t\\treturn lp_holdings[vaultId][to]; \\n\\t}\\n\\n\\tfunction getSuperVault(uint vaultId) external view returns(tVault){\\n\\t\\treturn tVault(vaultContracts[vaultId].vault); \\n\\t}\\n\\tfunction getSplitter(uint vaultId) external view returns(Splitter){\\n\\t\\treturn Splitter(vaultContracts[vaultId].splitter); \\n\\t}\\n\\tfunction getAmm(uint vaultId) external view returns(StableSwap){\\n\\t\\treturn StableSwap(vaultContracts[vaultId].amm); \\n\\t}\\n\\t//function getNumVaults\\n\\t// function getVaultId(InitParams memory param) external view returns(uint){\\n\\t// \\treturn vaultIdMapping[param]; \\n\\t// }\\n\\n\\n}\\n\\n/// @notice handles all trading related stuff \\ncontract TrancheMaster{\\n\\n\\tTrancheFactory tFactory;\\n\\n\\tconstructor(TrancheFactory _tFactory){\\n\\t\\ttFactory = _tFactory; \\n\\t}\\n\\n\\n\\t/// @notice adds liquidity to pool with vaultId\\n\\t/// @dev amount is denominated in want of the tVault, so want-> mint tVault-> split -> provide \\n\\tfunction addLiquidity(\\n\\t\\taddress provider,\\n\\t\\t uint amount, \\n\\t\\t uint vaultId) external \\n\\t{\\t\\n\\n\\t\\tTrancheFactory.Contracts memory contracts = tFactory.getContracts(vaultId); \\n\\t\\tERC20 want = ERC20(contracts.param._want); \\n\\t\\ttVault vault = tVault(contracts.vault); \\n\\t\\tStableSwap amm = StableSwap(contracts.amm); \\n\\t\\tSplitter splitter = Splitter(contracts.splitter); \\n\\n\\t\\t//Mint tVault\\n\\t\\twant.transferFrom(provider, address(this), amount); \\n\\t\\twant.approve(address(vault), amount ); \\n\\t\\tuint shares = vault.convertToShares(amount);\\n\\t\\tvault.mint(shares, address(this)); \\n\\n\\t\\t//Split \\n\\t\\tvault.approve(address(splitter), shares);\\n\\t\\t(uint ja, uint sa) = splitter.split(vault, shares); \\n\\n\\t\\t//provide\\n\\t\\tuint[2] memory amounts; \\n\\t\\tamounts[0] = sa; \\n\\t\\tamounts[1] = ja; \\n\\t\\tuint lpshares = amm.addLiquidity(amounts, 0); \\n\\n\\t\\t//Transfer\\n\\t\\ttFactory.increaseLPTokenBalance(provider, vaultId, lpshares);\\n\\n\\t}\\n\\n\\t/// @notice remove liquidity from the pool, and gives back merged token\\n\\tfunction removeLiquidity(\\n\\t\\taddress taker, \\n\\t\\tuint shares, \\n\\t\\tuint vaultId) external \\n\\t{\\n\\t\\tTrancheFactory.Contracts memory contracts = tFactory.getContracts(vaultId); \\n\\t\\tERC20 want = ERC20(contracts.param._want); \\n\\t\\ttVault vault = tVault(contracts.vault); \\n\\t\\tStableSwap amm = StableSwap(contracts.amm); \\n\\t\\tSplitter splitter = Splitter(contracts.splitter); \\n\\n\\t\\t//Transfer\\n\\t\\ttFactory.decreaseLPTokenBalance(taker, vaultId, shares); \\n\\n\\t\\t//Remove\\n\\t\\tuint[2] memory minAmounts;\\n\\t\\tminAmounts[0] =0;\\n\\t\\tminAmounts[1] =1;\\n\\t\\tuint[2] memory amountsOut = amm.removeLiquidity(shares,minAmounts);\\n\\t\\tuint junioramount = amountsOut[1]; \\n\\n\\t\\t//Merge-> junior and senior in, tVault out to this address\\n\\t\\tuint merged_token_amount = splitter.merge(vault, junioramount); \\n\\n\\t\\t//Redeem vault \\n\\t\\tvault.redeem(merged_token_amount, taker, address(this)); \\n\\n\\n\\t}\\n\\n\\n\\n\\t/// @notice buy tranche token in one tx from underlying tVault collatera; \\n\\t/// @param amount is collateral in \\n\\t/// @dev 1.Mints vault token\\n\\t/// 2. Splits Vault token from splitter \\n\\t/// 3. Swap unwanted tToken to wanted tToken\\n\\t/// 4. Transfer wanted tToken to user \\n\\tfunction buy_tranche(\\n\\t\\tuint vaultId, \\n\\t\\tuint amount, \\n\\t\\tbool isSenior\\n\\t\\t) external \\n\\t{\\n\\t\\tTrancheFactory.Contracts memory contracts = tFactory.getContracts(vaultId); \\n\\t\\tERC20 want = ERC20(contracts.param._want); \\n\\t\\ttVault vault = tVault(contracts.vault); \\n\\t\\tStableSwap amm = StableSwap(contracts.amm); \\n\\t\\tSplitter splitter = Splitter(contracts.splitter); \\n\\n\\t\\t//1.Mint\\n\\t\\twant.transferFrom(msg.sender, address(this), amount); \\n\\t\\twant.approve(address(vault), amount); \\n\\t\\tuint shares = vault.convertToShares(amount); \\n\\t\\tvault.mint(shares, address(this));\\n\\n\\t\\t//2. Split\\n\\t\\tvault.approve(address(splitter), shares); \\n\\t\\t(uint ja, uint sa) = splitter.split(vault, shares); //junior and senior now minted to this address \\n\\n\\t\\t//Senior tokens are indexed at 0 in each amm \\n\\t\\tuint tokenIn = isSenior? 0 : 1;\\n\\t\\tuint tokenOut = 1-tokenIn; \\n\\t\\tuint tokenInAmount = isSenior? sa: ja; \\n\\t\\taddress[] memory tranches = splitter.getTrancheTokens(); \\n\\t\\tERC20(tranches[tokenIn]).approve(address(amm), tokenInAmount); \\n\\n\\t\\t//3. Swap \\n\\t\\tuint tokenOutAmount = amm.swap(tokenIn, tokenOut, tokenInAmount, 0); //this will give this contract tokenOut\\n\\n\\t\\t//4. Transfer \\n\\t\\tERC20(tranches[tokenOut]).transfer(msg.sender, tokenOutAmount); \\n\\n\\t}\\n\\n\\t/// @notice sell tranche token for collateral in one tx\\n\\t/// 1. Transfer tToken \\n\\t/// 2. Swap tTokens to get in correct ratio\\n\\tfunction sell_tranche(\\n\\t\\tuint vaultId, \\n\\t\\tuint amount, \\n\\t\\tbool isSenior \\n\\t\\t) external \\n\\t{\\n\\t\\tTrancheFactory.Contracts memory contracts = tFactory.getContracts(vaultId); \\n\\t\\tERC20 want = ERC20(contracts.param._want); \\n\\t\\ttVault vault = tVault(contracts.vault); \\n\\t\\tStableSwap amm = StableSwap(contracts.amm); \\n\\t\\tSplitter splitter = Splitter(contracts.splitter); \\n\\n\\t\\t//1. Transfer tToken to this contract\\n\\t\\taddress[] memory tranches = splitter.getTrancheTokens(); \\n\\t\\tuint tokenIn = isSenior? 0:1; \\n\\t\\tERC20(tranches[tokenIn]).transfer(msg.sender, amount); \\n\\n\\t\\t//2. Swap to get correct ratio, if intoken is senior then need junior, \\n\\t\\t(uint pairTokenAmount, uint swappedTokenAmount) = swapToRatio(amount, !isSenior, tranches, vault, amm); \\n\\t\\tuint amountAfterSwap =  amount - swappedTokenAmount; \\n\\t\\t//amountAfterSwap, pairTokenAmount should be the amount of tranche tokens in ratio \\n\\n\\t\\t//3.Merge the tokens (merged tVault token will be directed to this contract)\\n\\t\\tuint junior_amount = isSenior? pairTokenAmount: swappedTokenAmount;  \\n\\t\\tuint totalAmountMerged = splitter.merge(vault, junior_amount); \\n\\n\\t\\t//4.Redeem merged token in tVault  \\n\\t\\tvault.redeem(totalAmountMerged, msg.sender, address(this)); \\n\\n\\n\\t}\\n\\n\\t/// @notice swap portion of tToken to another to get the correct ratio\\n\\t/// e.x 100 junior-> 30 senior, 70 junior, when ratio is 3:7\\n\\tfunction swapToRatio(\\n\\t\\tuint tokenInAmount, \\n\\t\\tbool needSenior,\\n\\t\\taddress[] memory tranches,\\n\\t\\ttVault vault, \\n\\t\\tStableSwap amm) internal returns(uint, uint){\\n\\t\\n\\t\\t//get swapping Token index; if senior is needed swap junior\\n\\t\\tuint tokenInIndex = needSenior? 1:0;\\n\\t\\tuint tokenOutIndex = 1- tokenInIndex; \\n\\t\\taddress neededToken = tranches[tokenOutIndex]; \\n\\t\\taddress swappingToken = tranches[tokenInIndex]; \\n\\t\\tuint junior_weight = vault.getJuniorWeight();\\n\\t\\tuint PRICE_PRECISION = vault.PRICE_PRECISION();   \\n\\t\\t\\n\\t\\t//ex. 100j -> 30j, 70s (determined by ratio)\\n\\t\\t// need x amount of juniors for 70s \\n\\t\\tuint neededTokenOutAmount; \\n\\t\\tif (needSenior)  neededTokenOutAmount = (PRICE_PRECISION - junior_weight) * tokenInAmount; \\n\\t\\telse  neededTokenOutAmount = junior_weight * tokenInAmount; \\n\\n\\t\\t//Get how much tokenInAmount I need to get needed tokenoutAmount \\n\\t\\tuint neededTokenInAmount = amm.getDx(neededTokenOutAmount, tokenInIndex); \\n\\t\\tuint TokenOutAmount = amm.swap(tokenInIndex, tokenOutIndex, neededTokenInAmount,0 ); \\n\\t\\t//Now this contract has the neededTokenAmountOut tokens\\n\\n\\t\\treturn (TokenOutAmount, neededTokenInAmount);\\n\\t}\\n\\n\\n\\n}\",\"keccak256\":\"0xcfeb6db32435f8d601443b2faf602efd986657a8576bc0d44a73e54314cf72cf\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611c57806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80630f11779b14610030575b600080fd5b610038610054565b6040516001600160a01b03909116815260200160405180910390f35b60008060405161006390610086565b604051809103906000f08015801561007f573d6000803e3d6000fd5b5092915050565b611b8e806100948339019056fe60c06040526001608081815260a09190915262000020906002908162000035565b503480156200002e57600080fd5b5062000094565b82600281019282156200006b579160200282015b828111156200006b578251829060ff1690559160200191906001019062000049565b50620000799291506200007d565b5090565b5b808211156200007957600081556001016200007e565b611aea80620000a46000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c80637066b5b2116100715780637066b5b21461014c57806370a082311461015f57806394edaa631461017f578063a60dc3b11461019f578063ca7b8704146101c7578063e25aa5fa146101cf57600080fd5b806313a980aa146100b957806318160ddd146100df5780634903b0d1146100e85780634f64b2be146100fb5780635673b02d146101265780636f76ab1814610139575b600080fd5b6100cc6100c7366004611866565b6101d7565b6040519081526020015b60405180910390f35b6100cc60065481565b6100cc6100f63660046117c1565b610283565b61010e6101093660046117c1565b61029a565b6040516001600160a01b0390911681526020016100d6565b6100cc6101343660046118b2565b6102ba565b6100cc610147366004611775565b610615565b6100cc61015a366004611887565b610a8d565b6100cc61016d36600461174e565b60076020526000908152604090205481565b61019261018d3660046117d9565b610bc6565b6040516100d691906118e3565b6101b26101ad366004611866565b610da1565b604080519283526020830191909152016100d6565b610192610db9565b6100cc610dce565b6000806101e2610e1e565b9050600081846002811061020657634e487b7160e01b600052603260045260246000fd5b6020020151905060008261021b866001611a56565b6002811061023957634e487b7160e01b600052603260045260246000fd5b60200201519050600061024c8783611a56565b9050600061026661025e886001611a56565b888488610ebb565b905060006102748583611a56565b96505050505050505b92915050565b6004816002811061029357600080fd5b0154905081565b600081600281106102aa57600080fd5b01546001600160a01b0316905081565b6000838514156102f95760405162461bcd60e51b815260206004820152600560248201526434901e903560d91b60448201526064015b60405180910390fd5b6000856002811061031a57634e487b7160e01b600052603260045260246000fd5b01546040516323b872dd60e01b8152336004820152306024820152604481018590526001600160a01b03909116906323b872dd90606401602060405180830381600087803b15801561036b57600080fd5b505af115801561037f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a391906117a1565b5060006103ae610e1e565b90506000600287600281106103d357634e487b7160e01b600052603260045260246000fd5b01546103df9086611a37565b8288600281106103ff57634e487b7160e01b600052603260045260246000fd5b602002015161040e9190611914565b9050600082876002811061043257634e487b7160e01b600052603260045260246000fd5b60200201519050600061044789898587610ebb565b90506002886002811061046a57634e487b7160e01b600052603260045260246000fd5b015460016104788385611a56565b6104829190611a56565b61048c919061192c565b94506000620f42406104a061012c88611a37565b6104aa919061192c565b90506104b68187611a56565b9550868610156104f35760405162461bcd60e51b8152602060048201526008602482015267323c901e1036b4b760c11b60448201526064016102f0565b8760048b6002811061051557634e487b7160e01b600052603260045260246000fd5b0160008282546105259190611914565b9091555086905060048a6002811061054d57634e487b7160e01b600052603260045260246000fd5b01600082825461055d9190611a56565b9091555060009050896002811061058457634e487b7160e01b600052603260045260246000fd5b015460405163a9059cbb60e01b8152336004820152602481018890526001600160a01b039091169063a9059cbb90604401602060405180830381600087803b1580156105cf57600080fd5b505af11580156105e3573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060791906117a1565b505050505050949350505050565b6006546000908180610625610e1e565b905082156106395761063681611092565b91505b610641611730565b60005b600281101561080957600088826002811061066f57634e487b7160e01b600052603260045260246000fd5b6020020135905080156107ad576000826002811061069d57634e487b7160e01b600052603260045260246000fd5b01546040516323b872dd60e01b8152336004820152306024820152604481018390526001600160a01b03909116906323b872dd90606401602060405180830381600087803b1580156106ee57600080fd5b505af1158015610702573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072691906117a1565b506002826002811061074857634e487b7160e01b600052603260045260246000fd5b01546107549082611a37565b84836002811061077457634e487b7160e01b600052603260045260246000fd5b60200201516107839190611914565b8383600281106107a357634e487b7160e01b600052603260045260246000fd5b60200201526107f8565b8382600281106107cd57634e487b7160e01b600052603260045260246000fd5b60200201518383600281106107f257634e487b7160e01b600052603260045260246000fd5b60200201525b5061080281611a6d565b9050610644565b50600061081582611092565b90508381116108665760405162461bcd60e51b815260206004820152601960248201527f6c6971756964697479206469646e277420696e6372656173650000000000000060448201526064016102f0565b6000851561098b5760005b600281101561097a576000868487846002811061089e57634e487b7160e01b600052603260045260246000fd5b60200201516108ad9190611a37565b6108b7919061192c565b905060006108e98684600281106108de57634e487b7160e01b600052603260045260246000fd5b602002015183611261565b9050620f4240816108fc60016002611a56565b610907906004611a37565b610914600261012c611a37565b61091e919061192c565b6109289190611a37565b610932919061192c565b86846002811061095257634e487b7160e01b600052603260045260246000fd5b602002018181516109639190611a56565b9052506109739150829050611a6d565b9050610871565b5061098483611092565b905061098e565b50805b60005b6002811015610a06578981600281106109ba57634e487b7160e01b600052603260045260246000fd5b6020020135600482600281106109e057634e487b7160e01b600052603260045260246000fd5b0160008282546109f09190611914565b909155506109ff905081611a6d565b9050610991565b508515610a34578486610a198284611a56565b610a239190611a37565b610a2d919061192c565b9650610a38565b8096505b87871015610a775760405162461bcd60e51b815260206004820152600c60248201526b39b430b932b9901e1036b4b760a11b60448201526064016102f0565b610a81338861128b565b50505050505092915050565b6000610a9984846112d5565b50905081811015610ad85760405162461bcd60e51b815260206004820152600960248201526837baba101e1036b4b760b91b60448201526064016102f0565b8060048460028110610afa57634e487b7160e01b600052603260045260246000fd5b016000828254610b0a9190611a56565b90915550610b1a90503385611578565b60008360028110610b3b57634e487b7160e01b600052603260045260246000fd5b015460405163a9059cbb60e01b8152336004820152602481018390526001600160a01b039091169063a9059cbb90604401602060405180830381600087803b158015610b8657600080fd5b505af1158015610b9a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bbe91906117a1565b509392505050565b610bce611730565b60065460005b6002811015610d8f576000828660048460028110610c0257634e487b7160e01b600052603260045260246000fd5b0154610c0e9190611a37565b610c18919061192c565b9050848260028110610c3a57634e487b7160e01b600052603260045260246000fd5b6020020151811015610c7a5760405162461bcd60e51b815260206004820152600960248201526837baba101e1036b4b760b91b60448201526064016102f0565b8060048360028110610c9c57634e487b7160e01b600052603260045260246000fd5b016000828254610cac9190611a56565b90915550819050848360028110610cd357634e487b7160e01b600052603260045260246000fd5b602002015260008260028110610cf957634e487b7160e01b600052603260045260246000fd5b015460405163a9059cbb60e01b8152336004820152602481018390526001600160a01b039091169063a9059cbb90604401602060405180830381600087803b158015610d4457600080fd5b505af1158015610d58573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d7c91906117a1565b505080610d8890611a6d565b9050610bd4565b50610d9a3385611578565b5092915050565b600080610dae84846112d5565b915091509250929050565b610dc1611730565b610dc9610e1e565b905090565b600080610de1610ddc610e1e565b611092565b6006549091508015610e155780610dfa6012600a61198f565b610e049084611a37565b610e0e919061192c565b9250505090565b60009250505090565b610e26611730565b60005b6002811015610eb75760028160028110610e5357634e487b7160e01b600052603260045260246000fd5b015460048260028110610e7657634e487b7160e01b600052603260045260246000fd5b0154610e829190611a37565b828260028110610ea257634e487b7160e01b600052603260045260246000fd5b6020020152610eb081611a6d565b9050610e29565b5090565b6000806002610ecb600182611a56565b610ed690600261198f565b610ee2906103e8611a37565b610eec9190611a37565b90506000610ef984611092565b905060008181805b6002811015610f8d578a811415610f1a57889150610f4f565b89811415610f2757610f7d565b878160028110610f4757634e487b7160e01b600052603260045260246000fd5b602002015191505b610f598285611914565b9350610f66826002611a37565b610f708685611a37565b610f7a919061192c565b92505b610f8681611a6d565b9050610f01565b50610f99856002611a37565b610fa38584611a37565b610fad919061192c565b91506000610fbb868661192c565b610fc59085611914565b9050600085815b60ff81101561104d578192508784836002610fe79190611a37565b610ff19190611914565b610ffb9190611a56565b866110068480611a37565b6110109190611914565b61101a919061192c565b915060016110288385611261565b1161103d5750975061108a9650505050505050565b61104681611a6d565b9050610fcc565b5060405162461bcd60e51b815260206004820152601160248201527079206469646e277420636f6e766572676560781b60448201526064016102f0565b949350505050565b60008060026110a2600182611a56565b6110ad90600261198f565b6110b9906103e8611a37565b6110c39190611a37565b90506000805b6002811015611113578481600281106110f257634e487b7160e01b600052603260045260246000fd5b60200201516111019083611914565b915061110c81611a6d565b90506110c9565b50806000805b60ff811015611224578260005b60028110156111855788816002811061114f57634e487b7160e01b600052603260045260246000fd5b602002015161115f906002611a37565b6111698684611a37565b611173919061192c565b915061117e81611a6d565b9050611126565b508392508061119660026001611914565b6111a09190611a37565b846111ac600189611a56565b6111b69190611a37565b6111c09190611914565b846111cc836002611a37565b6111d6888a611a37565b6111e09190611914565b6111ea9190611a37565b6111f4919061192c565b935060016112028585611261565b116112135750919695505050505050565b5061121d81611a6d565b9050611119565b5060405162461bcd60e51b815260206004820152601160248201527044206469646e277420636f6e766572676560781b60448201526064016102f0565b60008183101561127a576112758383611a56565b611284565b6112848284611a56565b9392505050565b6001600160a01b038216600090815260076020526040812080548392906112b3908490611914565b9250508190555080600660008282546112cc9190611914565b90915550505050565b6006546000908190816112e6610e1e565b905060006112f382611092565b90506000836113028984611a37565b61130c919061192c565b6113169083611a56565b905060006113258885846115b9565b905060006002896002811061134a57634e487b7160e01b600052603260045260246000fd5b015482868b6002811061136d57634e487b7160e01b600052603260045260246000fd5b602002015161137c9190611a56565b611386919061192c565b90506000805b60028110156114e2578a8114156113ea578386868984600281106113c057634e487b7160e01b600052603260045260246000fd5b60200201516113cf9190611a37565b6113d9919061192c565b6113e39190611a56565b9150611457565b858588836002811061140c57634e487b7160e01b600052603260045260246000fd5b602002015161141b9190611a37565b611425919061192c565b87826002811061144557634e487b7160e01b600052603260045260246000fd5b60200201516114549190611a56565b91505b620f42408261146860016002611a56565b611473906004611a37565b611480600261012c611a37565b61148a919061192c565b6114949190611a37565b61149e919061192c565b8782600281106114be57634e487b7160e01b600052603260045260246000fd5b602002018181516114cf9190611a56565b9052506114db81611a6d565b905061138c565b5060006114f08b88876115b9565b905060028b6002811061151357634e487b7160e01b600052603260045260246000fd5b0154600182898e6002811061153857634e487b7160e01b600052603260045260246000fd5b60200201516115479190611a56565b6115519190611a56565b61155b919061192c565b99506115678a84611a56565b985050505050505050509250929050565b6001600160a01b038216600090815260076020526040812080548392906115a0908490611a56565b9250508190555080600660008282546112cc9190611a56565b60008060026115c9600182611a56565b6115d490600261198f565b6115e0906103e8611a37565b6115ea9190611a37565b905060008381805b60028110156116715788811461162e5787816002811061162257634e487b7160e01b600052603260045260246000fd5b60200201519150611633565b611661565b61163d8285611914565b935061164a826002611a37565b6116548885611a37565b61165e919061192c565b92505b61166a81611a6d565b90506115f2565b5061167d846002611a37565b6116878784611a37565b611691919061192c565b9150600061169f858861192c565b6116a99085611914565b9050600087815b60ff81101561104d5781925089848360026116cb9190611a37565b6116d59190611914565b6116df9190611a56565b866116ea8480611a37565b6116f49190611914565b6116fe919061192c565b9150600161170c8385611261565b116117205750965061128495505050505050565b61172981611a6d565b90506116b0565b60405180604001604052806002906020820280368337509192915050565b60006020828403121561175f578081fd5b81356001600160a01b0381168114611284578182fd5b60008060608385031215611787578081fd5b6040830184811115611797578182fd5b9294923593505050565b6000602082840312156117b2578081fd5b81518015158114611284578182fd5b6000602082840312156117d2578081fd5b5035919050565b600080606083850312156117eb578182fd5b82359150602084603f8501126117ff578182fd5b6040516040810181811067ffffffffffffffff8211171561182257611822611a9e565b6040528085830160608701881015611838578485fd5b845b60028110156118575781358352918401919084019060010161183a565b50505080925050509250929050565b60008060408385031215611878578182fd5b50508035926020909101359150565b60008060006060848603121561189b578081fd5b505081359360208301359350604090920135919050565b600080600080608085870312156118c7578081fd5b5050823594602084013594506040840135936060013592509050565b60408101818360005b600281101561190b5781518352602092830192909101906001016118ec565b50505092915050565b6000821982111561192757611927611a88565b500190565b60008261194757634e487b7160e01b81526012600452602481fd5b500490565b600181815b8085111561198757816000190482111561196d5761196d611a88565b8085161561197a57918102915b93841c9390800290611951565b509250929050565b600061128483836000826119a55750600161027d565b816119b25750600061027d565b81600181146119c857600281146119d2576119ee565b600191505061027d565b60ff8411156119e3576119e3611a88565b50506001821b61027d565b5060208310610133831016604e8410600b8410161715611a11575081810a61027d565b611a1b838361194c565b8060001904821115611a2f57611a2f611a88565b029392505050565b6000816000190483118215151615611a5157611a51611a88565b500290565b600082821015611a6857611a68611a88565b500390565b6000600019821415611a8157611a81611a88565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220eb86ad887d2fd4f2adf2a45366fe2c9796f3c707d692f7db47a2486a8738aee064736f6c63430008040033a26469706673582212206b858d98f6e2621a64d7ae74e219ded5b4e4ad37afab0a0f17dfc4ecd4c01e7964736f6c63430008040033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80630f11779b14610030575b600080fd5b610038610054565b6040516001600160a01b03909116815260200160405180910390f35b60008060405161006390610086565b604051809103906000f08015801561007f573d6000803e3d6000fd5b5092915050565b611b8e806100948339019056fe60c06040526001608081815260a09190915262000020906002908162000035565b503480156200002e57600080fd5b5062000094565b82600281019282156200006b579160200282015b828111156200006b578251829060ff1690559160200191906001019062000049565b50620000799291506200007d565b5090565b5b808211156200007957600081556001016200007e565b611aea80620000a46000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c80637066b5b2116100715780637066b5b21461014c57806370a082311461015f57806394edaa631461017f578063a60dc3b11461019f578063ca7b8704146101c7578063e25aa5fa146101cf57600080fd5b806313a980aa146100b957806318160ddd146100df5780634903b0d1146100e85780634f64b2be146100fb5780635673b02d146101265780636f76ab1814610139575b600080fd5b6100cc6100c7366004611866565b6101d7565b6040519081526020015b60405180910390f35b6100cc60065481565b6100cc6100f63660046117c1565b610283565b61010e6101093660046117c1565b61029a565b6040516001600160a01b0390911681526020016100d6565b6100cc6101343660046118b2565b6102ba565b6100cc610147366004611775565b610615565b6100cc61015a366004611887565b610a8d565b6100cc61016d36600461174e565b60076020526000908152604090205481565b61019261018d3660046117d9565b610bc6565b6040516100d691906118e3565b6101b26101ad366004611866565b610da1565b604080519283526020830191909152016100d6565b610192610db9565b6100cc610dce565b6000806101e2610e1e565b9050600081846002811061020657634e487b7160e01b600052603260045260246000fd5b6020020151905060008261021b866001611a56565b6002811061023957634e487b7160e01b600052603260045260246000fd5b60200201519050600061024c8783611a56565b9050600061026661025e886001611a56565b888488610ebb565b905060006102748583611a56565b96505050505050505b92915050565b6004816002811061029357600080fd5b0154905081565b600081600281106102aa57600080fd5b01546001600160a01b0316905081565b6000838514156102f95760405162461bcd60e51b815260206004820152600560248201526434901e903560d91b60448201526064015b60405180910390fd5b6000856002811061031a57634e487b7160e01b600052603260045260246000fd5b01546040516323b872dd60e01b8152336004820152306024820152604481018590526001600160a01b03909116906323b872dd90606401602060405180830381600087803b15801561036b57600080fd5b505af115801561037f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103a391906117a1565b5060006103ae610e1e565b90506000600287600281106103d357634e487b7160e01b600052603260045260246000fd5b01546103df9086611a37565b8288600281106103ff57634e487b7160e01b600052603260045260246000fd5b602002015161040e9190611914565b9050600082876002811061043257634e487b7160e01b600052603260045260246000fd5b60200201519050600061044789898587610ebb565b90506002886002811061046a57634e487b7160e01b600052603260045260246000fd5b015460016104788385611a56565b6104829190611a56565b61048c919061192c565b94506000620f42406104a061012c88611a37565b6104aa919061192c565b90506104b68187611a56565b9550868610156104f35760405162461bcd60e51b8152602060048201526008602482015267323c901e1036b4b760c11b60448201526064016102f0565b8760048b6002811061051557634e487b7160e01b600052603260045260246000fd5b0160008282546105259190611914565b9091555086905060048a6002811061054d57634e487b7160e01b600052603260045260246000fd5b01600082825461055d9190611a56565b9091555060009050896002811061058457634e487b7160e01b600052603260045260246000fd5b015460405163a9059cbb60e01b8152336004820152602481018890526001600160a01b039091169063a9059cbb90604401602060405180830381600087803b1580156105cf57600080fd5b505af11580156105e3573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060791906117a1565b505050505050949350505050565b6006546000908180610625610e1e565b905082156106395761063681611092565b91505b610641611730565b60005b600281101561080957600088826002811061066f57634e487b7160e01b600052603260045260246000fd5b6020020135905080156107ad576000826002811061069d57634e487b7160e01b600052603260045260246000fd5b01546040516323b872dd60e01b8152336004820152306024820152604481018390526001600160a01b03909116906323b872dd90606401602060405180830381600087803b1580156106ee57600080fd5b505af1158015610702573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072691906117a1565b506002826002811061074857634e487b7160e01b600052603260045260246000fd5b01546107549082611a37565b84836002811061077457634e487b7160e01b600052603260045260246000fd5b60200201516107839190611914565b8383600281106107a357634e487b7160e01b600052603260045260246000fd5b60200201526107f8565b8382600281106107cd57634e487b7160e01b600052603260045260246000fd5b60200201518383600281106107f257634e487b7160e01b600052603260045260246000fd5b60200201525b5061080281611a6d565b9050610644565b50600061081582611092565b90508381116108665760405162461bcd60e51b815260206004820152601960248201527f6c6971756964697479206469646e277420696e6372656173650000000000000060448201526064016102f0565b6000851561098b5760005b600281101561097a576000868487846002811061089e57634e487b7160e01b600052603260045260246000fd5b60200201516108ad9190611a37565b6108b7919061192c565b905060006108e98684600281106108de57634e487b7160e01b600052603260045260246000fd5b602002015183611261565b9050620f4240816108fc60016002611a56565b610907906004611a37565b610914600261012c611a37565b61091e919061192c565b6109289190611a37565b610932919061192c565b86846002811061095257634e487b7160e01b600052603260045260246000fd5b602002018181516109639190611a56565b9052506109739150829050611a6d565b9050610871565b5061098483611092565b905061098e565b50805b60005b6002811015610a06578981600281106109ba57634e487b7160e01b600052603260045260246000fd5b6020020135600482600281106109e057634e487b7160e01b600052603260045260246000fd5b0160008282546109f09190611914565b909155506109ff905081611a6d565b9050610991565b508515610a34578486610a198284611a56565b610a239190611a37565b610a2d919061192c565b9650610a38565b8096505b87871015610a775760405162461bcd60e51b815260206004820152600c60248201526b39b430b932b9901e1036b4b760a11b60448201526064016102f0565b610a81338861128b565b50505050505092915050565b6000610a9984846112d5565b50905081811015610ad85760405162461bcd60e51b815260206004820152600960248201526837baba101e1036b4b760b91b60448201526064016102f0565b8060048460028110610afa57634e487b7160e01b600052603260045260246000fd5b016000828254610b0a9190611a56565b90915550610b1a90503385611578565b60008360028110610b3b57634e487b7160e01b600052603260045260246000fd5b015460405163a9059cbb60e01b8152336004820152602481018390526001600160a01b039091169063a9059cbb90604401602060405180830381600087803b158015610b8657600080fd5b505af1158015610b9a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bbe91906117a1565b509392505050565b610bce611730565b60065460005b6002811015610d8f576000828660048460028110610c0257634e487b7160e01b600052603260045260246000fd5b0154610c0e9190611a37565b610c18919061192c565b9050848260028110610c3a57634e487b7160e01b600052603260045260246000fd5b6020020151811015610c7a5760405162461bcd60e51b815260206004820152600960248201526837baba101e1036b4b760b91b60448201526064016102f0565b8060048360028110610c9c57634e487b7160e01b600052603260045260246000fd5b016000828254610cac9190611a56565b90915550819050848360028110610cd357634e487b7160e01b600052603260045260246000fd5b602002015260008260028110610cf957634e487b7160e01b600052603260045260246000fd5b015460405163a9059cbb60e01b8152336004820152602481018390526001600160a01b039091169063a9059cbb90604401602060405180830381600087803b158015610d4457600080fd5b505af1158015610d58573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d7c91906117a1565b505080610d8890611a6d565b9050610bd4565b50610d9a3385611578565b5092915050565b600080610dae84846112d5565b915091509250929050565b610dc1611730565b610dc9610e1e565b905090565b600080610de1610ddc610e1e565b611092565b6006549091508015610e155780610dfa6012600a61198f565b610e049084611a37565b610e0e919061192c565b9250505090565b60009250505090565b610e26611730565b60005b6002811015610eb75760028160028110610e5357634e487b7160e01b600052603260045260246000fd5b015460048260028110610e7657634e487b7160e01b600052603260045260246000fd5b0154610e829190611a37565b828260028110610ea257634e487b7160e01b600052603260045260246000fd5b6020020152610eb081611a6d565b9050610e29565b5090565b6000806002610ecb600182611a56565b610ed690600261198f565b610ee2906103e8611a37565b610eec9190611a37565b90506000610ef984611092565b905060008181805b6002811015610f8d578a811415610f1a57889150610f4f565b89811415610f2757610f7d565b878160028110610f4757634e487b7160e01b600052603260045260246000fd5b602002015191505b610f598285611914565b9350610f66826002611a37565b610f708685611a37565b610f7a919061192c565b92505b610f8681611a6d565b9050610f01565b50610f99856002611a37565b610fa38584611a37565b610fad919061192c565b91506000610fbb868661192c565b610fc59085611914565b9050600085815b60ff81101561104d578192508784836002610fe79190611a37565b610ff19190611914565b610ffb9190611a56565b866110068480611a37565b6110109190611914565b61101a919061192c565b915060016110288385611261565b1161103d5750975061108a9650505050505050565b61104681611a6d565b9050610fcc565b5060405162461bcd60e51b815260206004820152601160248201527079206469646e277420636f6e766572676560781b60448201526064016102f0565b949350505050565b60008060026110a2600182611a56565b6110ad90600261198f565b6110b9906103e8611a37565b6110c39190611a37565b90506000805b6002811015611113578481600281106110f257634e487b7160e01b600052603260045260246000fd5b60200201516111019083611914565b915061110c81611a6d565b90506110c9565b50806000805b60ff811015611224578260005b60028110156111855788816002811061114f57634e487b7160e01b600052603260045260246000fd5b602002015161115f906002611a37565b6111698684611a37565b611173919061192c565b915061117e81611a6d565b9050611126565b508392508061119660026001611914565b6111a09190611a37565b846111ac600189611a56565b6111b69190611a37565b6111c09190611914565b846111cc836002611a37565b6111d6888a611a37565b6111e09190611914565b6111ea9190611a37565b6111f4919061192c565b935060016112028585611261565b116112135750919695505050505050565b5061121d81611a6d565b9050611119565b5060405162461bcd60e51b815260206004820152601160248201527044206469646e277420636f6e766572676560781b60448201526064016102f0565b60008183101561127a576112758383611a56565b611284565b6112848284611a56565b9392505050565b6001600160a01b038216600090815260076020526040812080548392906112b3908490611914565b9250508190555080600660008282546112cc9190611914565b90915550505050565b6006546000908190816112e6610e1e565b905060006112f382611092565b90506000836113028984611a37565b61130c919061192c565b6113169083611a56565b905060006113258885846115b9565b905060006002896002811061134a57634e487b7160e01b600052603260045260246000fd5b015482868b6002811061136d57634e487b7160e01b600052603260045260246000fd5b602002015161137c9190611a56565b611386919061192c565b90506000805b60028110156114e2578a8114156113ea578386868984600281106113c057634e487b7160e01b600052603260045260246000fd5b60200201516113cf9190611a37565b6113d9919061192c565b6113e39190611a56565b9150611457565b858588836002811061140c57634e487b7160e01b600052603260045260246000fd5b602002015161141b9190611a37565b611425919061192c565b87826002811061144557634e487b7160e01b600052603260045260246000fd5b60200201516114549190611a56565b91505b620f42408261146860016002611a56565b611473906004611a37565b611480600261012c611a37565b61148a919061192c565b6114949190611a37565b61149e919061192c565b8782600281106114be57634e487b7160e01b600052603260045260246000fd5b602002018181516114cf9190611a56565b9052506114db81611a6d565b905061138c565b5060006114f08b88876115b9565b905060028b6002811061151357634e487b7160e01b600052603260045260246000fd5b0154600182898e6002811061153857634e487b7160e01b600052603260045260246000fd5b60200201516115479190611a56565b6115519190611a56565b61155b919061192c565b99506115678a84611a56565b985050505050505050509250929050565b6001600160a01b038216600090815260076020526040812080548392906115a0908490611a56565b9250508190555080600660008282546112cc9190611a56565b60008060026115c9600182611a56565b6115d490600261198f565b6115e0906103e8611a37565b6115ea9190611a37565b905060008381805b60028110156116715788811461162e5787816002811061162257634e487b7160e01b600052603260045260246000fd5b60200201519150611633565b611661565b61163d8285611914565b935061164a826002611a37565b6116548885611a37565b61165e919061192c565b92505b61166a81611a6d565b90506115f2565b5061167d846002611a37565b6116878784611a37565b611691919061192c565b9150600061169f858861192c565b6116a99085611914565b9050600087815b60ff81101561104d5781925089848360026116cb9190611a37565b6116d59190611914565b6116df9190611a56565b866116ea8480611a37565b6116f49190611914565b6116fe919061192c565b9150600161170c8385611261565b116117205750965061128495505050505050565b61172981611a6d565b90506116b0565b60405180604001604052806002906020820280368337509192915050565b60006020828403121561175f578081fd5b81356001600160a01b0381168114611284578182fd5b60008060608385031215611787578081fd5b6040830184811115611797578182fd5b9294923593505050565b6000602082840312156117b2578081fd5b81518015158114611284578182fd5b6000602082840312156117d2578081fd5b5035919050565b600080606083850312156117eb578182fd5b82359150602084603f8501126117ff578182fd5b6040516040810181811067ffffffffffffffff8211171561182257611822611a9e565b6040528085830160608701881015611838578485fd5b845b60028110156118575781358352918401919084019060010161183a565b50505080925050509250929050565b60008060408385031215611878578182fd5b50508035926020909101359150565b60008060006060848603121561189b578081fd5b505081359360208301359350604090920135919050565b600080600080608085870312156118c7578081fd5b5050823594602084013594506040840135936060013592509050565b60408101818360005b600281101561190b5781518352602092830192909101906001016118ec565b50505092915050565b6000821982111561192757611927611a88565b500190565b60008261194757634e487b7160e01b81526012600452602481fd5b500490565b600181815b8085111561198757816000190482111561196d5761196d611a88565b8085161561197a57918102915b93841c9390800290611951565b509250929050565b600061128483836000826119a55750600161027d565b816119b25750600061027d565b81600181146119c857600281146119d2576119ee565b600191505061027d565b60ff8411156119e3576119e3611a88565b50506001821b61027d565b5060208310610133831016604e8410600b8410161715611a11575081810a61027d565b611a1b838361194c565b8060001904821115611a2f57611a2f611a88565b029392505050565b6000816000190483118215151615611a5157611a51611a88565b500290565b600082821015611a6857611a68611a88565b500390565b6000600019821415611a8157611a81611a88565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220eb86ad887d2fd4f2adf2a45366fe2c9796f3c707d692f7db47a2486a8738aee064736f6c63430008040033a26469706673582212206b858d98f6e2621a64d7ae74e219ded5b4e4ad37afab0a0f17dfc4ecd4c01e7964736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "have to separate factories because of code size limit ",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}